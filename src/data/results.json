[
    {
        "id": 0,
        "name": ".QL",
        "url": "https://en.wikipedia.org/wiki/.QL",
        "summary": "<p><b>.QL</b> (pronounced \"dot-cue-el\") is an object-oriented query language used to retrieve data from relational database management systems. It is reminiscent of the standard query language SQL and the object-oriented programming language Java. .QL is an object-oriented variant of a logical query language called Datalog. Hierarchical data can therefore be naturally queried in .QL in a recursive manner.  </p><p>Queries written in .QL are optimised, compiled into SQL and can then be executed on any major relational database management system. .QL query language is being used in SemmleCode to query a relational representation of Java programs.\n</p><p>.QL is developed at Semmle Limited and is based on the company's proprietary technology.\n</p>",
        "infobox": {
            "logo": "File:dotql.png",
            "name": ".QL",
            "age": "[number]",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm",
                "logic programming language|logic-paradigm",
                "object-oriented programming language|object-oriented-paradigm"
            ],
            "year": "2007",
            "developer": "Semmle",
            "typing": [
                "static typing|static",
                "strong typing|strong"
            ],
            "implementations": "SemmleCode",
            "influenced_by": "Datalog"
        }
    },
    {
        "id": 1,
        "name": "A+ (programming language)",
        "url": "https://en.wikipedia.org/wiki/A%2B_(programming_language)",
        "summary": "<p><b>A+</b> is an array programming language descended from the programming language A, which in turn was created to replace APL in 1988. Arthur Whitney developed the <i>A</i> portion of A+, while other developers at Morgan Stanley extended it, adding a graphical user interface and other language features. A+ is a high-level, interactive, interpreted language, designed for numerically intensive applications, especially those found in financial applications.  A+ runs on many Unix variants, including Linux. It is free and open source software released under a GNU General Public License. </p><p>A+ provides an extended set of functions and operators, a graphical user interface with automatic synchronizing of widgets and variables, asynchronous executing of functions associated with variables and events, dynamic loading of user compiled subroutines, and other features. A newer graphical user interface has not yet been ported to all supported platforms\n</p><p>The A+ language implements the following changes to the APL language:\n</p>\n<ul><li>an A+ function may have up to nine formal parameters</li>\n<li>A+ code statements are separated by semicolons, so a single statement may be divided into two or more physical lines</li>\n<li>The explicit result of a function or operator is the result of the last statement executed</li>\n<li>A+ implements an object called a dependency, which is a global variable (the dependent variable) and an associated definition that is like a function with no arguments. Values can be explicitly set and referenced in exactly the same ways as for a global variable, but they can also be set through the associated definition.</li></ul><p>Interactive A+ development is primarily done in the Xemacs editor, through extensions to the editor. Because A+ code uses the original APL symbols, displaying A+ requires a font with those special characters; a font named <i>kapl</i> is provided on the web site for that purpose.\n</p><p>Arthur Whitney went on to create a proprietary array language named K.  Like J, K omits the APL character set.  It lacks some of the perceived complexities of A+, such as the existence of statements and two different modes of syntax.\n</p>",
        "infobox": {
            "name": "A+",
            "logo": "Aplus logo.jpg",
            "paradigm": "Array programming|Array",
            "released": "1988",
            "designer": "Arthur Whitney (computer scientist)|Arthur Whitney",
            "developer": "Morgan Stanley",
            "latest release version": "4.22-1",
            "latest release date": "2008|03|27",
            "typing": [
                "Dynamic typing|Dynamic",
                "strong typing|strong"
            ],
            "file_ext": [
                "mono|.. ",
                "mono|.+ ",
                "mono|.a ",
                "mono|.m"
            ],
            "implementations": "A+",
            "influenced by": "APL (programming language)|APL",
            "influenced": "K (programming language)|K",
            "license": "GNU General Public License"
        }
    },
    {
        "id": 2,
        "name": "A-0 System",
        "url": "https://en.wikipedia.org/wiki/A-0_System",
        "summary": "<p>The <b>A-0 system</b> (<i>Arithmetic Language version 0</i>), written by Grace Murray Hopper  in 1951 and 1952 for the UNIVAC I, was an early compiler related tool developed for electronic computers. The A-0 functioned more as a loader or linker than the modern notion of a compiler. A program was specified as a sequence of subroutines and arguments. The subroutines were identified by a numeric code and the arguments to the subroutines were written directly after each subroutine code. The A-0 system converted the specification into machine code that could be fed into the computer a second time to execute the said program. </p><p>The A-0 system was followed by the  A-1, A-2, A-3 (released as ARITH-MATIC), AT-3 (released as MATH-MATIC) and B-0 (released as FLOW-MATIC).\n</p><p>The A-2 system was developed at the UNIVAC division of Remington Rand in 1953 and released to customers by the end of that year.  Customers were provided the source code for A-2 and invited to send their improvements back to UNIVAC.   Thus A-2 was an early example of free and open-source software.</p>",
        "infobox": "N/A"
    },
    {
        "id": 3,
        "name": "ABAP",
        "url": "https://en.wikipedia.org/wiki/ABAP",
        "summary": "<p><b>ABAP</b> (Advanced Business Application Programming, originally <i>Allgemeiner Berichts-Aufbereitungs-Prozessor</i>, German for \"general report creation processor\") is a high-level programming language created by the German software company SAP SE. It is extracted from the base computing languages Java, C, C++ and Python. It is currently positioned, alongside Java, as the language for programming the SAP NetWeaver Application Server, which is part of the SAP NetWeaver platform for building business applications. </p>",
        "infobox": {
            "name": "ABAP/4",
            "paradigm": [
                "Object-oriented programming|Object-oriented",
                "Structured programming|structured",
                "Imperative programming|imperative"
            ],
            "year": "start date and age|1983",
            "designer": "SAP SE",
            "latest release version": "7.54",
            "latest release date": "start date and age|2019|9|20",
            "typing": [
                "Type system#Static and dynamic typing|Static",
                "Strong and weak typing|strong",
                "Type system#Safely and unsafely typed systems|safe",
                "Nominative type system|nominative"
            ],
            "implementations": [
                "SAP R/2",
                "SAP R/3",
                "SAP S/4HANA"
            ],
            "influenced_by": [
                "Objective-C",
                "May 2012 COBOL",
                "March 2016 SQL May 2012"
            ],
            "operating_system": "Cross-platform",
            "website": "[http://scn.sap.com/community/abap scn.sap.com/community/abap]"
        }
    },
    {
        "id": 4,
        "name": "ABC (programming language)",
        "url": "https://en.wikipedia.org/wiki/ABC_(programming_language)",
        "summary": "<p><b>ABC</b> is an imperative general-purpose programming language and programming environment developed at CWI, Netherlands by Leo Geurts, Lambert Meertens, and Steven Pemberton. It is interactive, structured, high-level, and intended to be used instead of BASIC, Pascal, or AWK. It is not meant to be a systems-programming language but is intended for teaching or prototyping. </p><p>The language had a major influence on the design of the Python programming language; Guido van Rossum, who developed Python, previously worked for several years on the ABC system in the mid 1980s.</p>",
        "infobox": {
            "name": "ABC",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: imperative programming|imperative",
                "procedural programming|procedural",
                "structured programming|structured"
            ],
            "designer": [
                "Leo Geurts",
                "Lambert Meertens",
                "Steven Pemberton"
            ],
            "developer": "Centrum Wiskunde & Informatica|CWI",
            "latest release version": "1.05.02",
            "typing": [
                "strongly typed programming language|strong",
                "type polymorphism|polymorphic"
            ],
            "influenced_by": "SETL & ALGOL 68",
            "influenced": "Python (programming language)|Python"
        }
    },
    {
        "id": 5,
        "name": "ABC ALGOL",
        "url": "https://en.wikipedia.org/wiki/ABC_ALGOL",
        "summary": "<p><b>ABC ALGOL</b> is an extension of the programming language ALGOL 60 with arbitrary data structures and user-defined operators, intended for computer algebra (symbolic mathematics). Despite its advances, it was never used as widely as Algol proper. </p>",
        "infobox": "N/A"
    },
    {
        "id": 6,
        "name": "ACC (programming language)",
        "url": "https://en.wikipedia.org/wiki/ACC_(programming_language)",
        "summary": "<p><b>ACC</b> is a near-C compiler for the MS-DOS operating system on the IBM PC line of computers for programs. The compiler and compiled programs will run on any Intel 80386 or above PC running MS-DOS. Included with the compiler are a 386 assembler and a linker for combining multiple object files. There are also two libraries, which are a protected mode DOS extender (based on Thomas Pytel's, AKA Tran's PMODE30B + PMODE307 DOS extenders), and a library of functions callable by C programs. </p><p>Pointers are 4 bytes, and can access all available memory. All memory can be allocated too. The compiler, assembler and linker are all very small and reportedly very fast.</p>",
        "infobox": "N/A"
    },
    {
        "id": 7,
        "name": "AIMMS",
        "url": "https://en.wikipedia.org/wiki/AIMMS",
        "summary": "<p><b>AIMMS</b> (acronym for <b>Advanced Interactive Multidimensional Modeling System</b>) is a prescriptive analytics software company with offices in the Netherlands, United States, China and Singapore. </p><p>It has two main product offerings that provide modeling and optimization capabilities across a variety of industries. The AIMMS Prescriptive Analytics Platform allows advanced users to develop optimization-based applications and deploy them to business users. AIMMS SC Navigator, launched in 2017, is built on the AIMMS Prescriptive Analytics Platform and provides configurable Apps for supply chain teams. SC Navigator provides supply chain analytics to non-advanced users.\n</p>",
        "infobox": {
            "name": "AIMMS",
            "logo": "https://aimms.com/",
            "designer": "Johannes J. Bisschop <br> Marcel Roelofs",
            "developer": "[http://www.aimms.com AIMMS B.V.] (formerly named Paragon Decision Technology B.V. )",
            "website": "[http://www.aimms.com AIMMS home page]",
            "Year Started": "1993"
        }
    },
    {
        "id": 8,
        "name": "ALGOL",
        "url": "https://en.wikipedia.org/wiki/ALGOL",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>ALGOL</b> (<span></span>; short for \"<b>Algorithmic Language</b>\") is a family of imperative computer programming languages originally developed in 1958. ALGOL heavily influenced many other languages and was the standard method for algorithm description used by the Association for Computing Machinery (ACM) in textbooks and academic sources until object-oriented languages came around, for more than thirty years.</p><p>In the sense that the syntax of most modern languages is \"Algol-like\", it was arguably the most influential of the four high-level programming languages among which it was roughly contemporary: FORTRAN, Lisp, and COBOL. It was designed to avoid some of the perceived problems with FORTRAN and eventually gave rise to many other programming languages, including PL/I, Simula, BCPL, B, Pascal, and C.\n</p><p>ALGOL introduced code blocks and the <code>begin</code>...<code>end</code> pairs for delimiting them. It was also the first language implementing nested function definitions with lexical scope. Moreover, it was the first programming language which gave detailed attention to formal language definition and through the <i>Algol 60 Report</i> introduced Backus–Naur form, a principal formal grammar notation for language design.\n</p><p>There were three major specifications, named after the years they were first published:\n</p>\n<ul><li>ALGOL 58 – originally proposed to be called <i>IAL</i>, for <i>International Algebraic Language</i>.</li>\n<li>ALGOL 60 – first implemented as <i>X1 ALGOL 60</i> in mid-1960. Revised 1963.</li>\n<li>ALGOL 68 – introduced new elements including flexible arrays, slices, parallelism, operator identification. Revised 1973.</li></ul><p>ALGOL 68 is substantially different from ALGOL 60 and was not well received, so that in general \"Algol\" means ALGOL 60 and dialects thereof.\n</p>",
        "infobox": {
            "name": "ALGOL",
            "logo": [
                "1965 ALGOL-20 A Language Manual",
                "Fierst et al - cover.jpg"
            ],
            "logo caption": "A 1965 manual for ALGOL-20",
            "paradigm": [
                "Procedural programming|Procedural",
                "Imperative programming|imperative",
                "Structured programming|structured"
            ],
            "family": "ALGOL",
            "designers": [
                "Friedrich L. Bauer|Bauer",
                "Hermann Bottenbruch|Bottenbruch",
                "Heinz Rutishauser|Rutishauser",
                "Klaus Samelson|Samelson",
                "John Backus|Backus",
                "Charles Katz|Katz",
                "Alan Perlis|Perlis",
                "Joseph Henry Wegstein|Wegstein",
                "Peter Naur|Naur",
                "Bernard Vauquois|Vauquois",
                "Adriaan van Wijngaarden|van Wijngaarden",
                "Michael Woodger|Woodger",
                "Julien Green (computer scientist)|Green",
                "John McCarthy (computer scientist)|McCarthy"
            ],
            "released": "1958",
            "typing": [
                "Static type|Static",
                "Strong and weak typing|strong"
            ],
            "scope": "Scope (computer science)|Lexical",
            "influenced": [
                "Most subsequent imperative languages (so-called ''ALGOL-like'' languages)<br/>e.g. PL/I",
                "Simula",
                "BCPL",
                "B (programming language)|B",
                "Pascal (programming language)|Pascal",
                "C (programming language)|C"
            ]
        }
    },
    {
        "id": 9,
        "name": "ALGOL 58",
        "url": "https://en.wikipedia.org/wiki/ALGOL_58",
        "summary": "<p><b>ALGOL 58</b>, originally named <b>IAL</b>, is one of the family of ALGOL computer programming languages. It was an early compromise design soon superseded by ALGOL 60. According to John Backus</p> <blockquote>\n<p>\"The Zurich ACM-GAMM Conference had two principal motives in proposing the IAL: (a) To provide a means of communicating numerical methods and other procedures between people, and (b) To provide a means of realizing a stated process on a variety of machines...\"\n</p>\n</blockquote>\n<p>ALGOL 58 introduced the fundamental notion of the compound statement, but it was restricted to control flow only, and it was not tied to identifier scope in the way that Algol 60's blocks were.\n</p>",
        "infobox": {
            "name": "ALGOL 58",
            "paradigm": [
                "Procedural programming|procedural",
                "Imperative programming language|imperative",
                "Structured programming|structured"
            ],
            "family": "ALGOL",
            "designers": [
                "Friedrich L. Bauer",
                "Hermann Bottenbruch",
                "Heinz Rutishauser",
                "Klaus Samelson",
                "John Backus",
                "Charles Katz",
                "Alan Perlis",
                "Joseph Henry Wegstein"
            ],
            "released": "1958",
            "typing": [
                "Static type|Static",
                "Strong and weak typing|strong"
            ],
            "scope": "Scope (computer science)|Lexical",
            "influenced_by": [
                "FORTRAN",
                "IT",
                "Plankalkül",
                "Superplan",
                "Sequentielle Formelübersetzung"
            ],
            "influenced": "Most subsequent imperative languages (''Algol-like'')"
        }
    },
    {
        "id": 10,
        "name": "ALGOL 60",
        "url": "https://en.wikipedia.org/wiki/ALGOL_60",
        "summary": "<p><b>ALGOL 60</b> (short for <i>Algorithmic Language 1960</i>) is a member of the ALGOL family of computer programming languages. It followed on from ALGOL 58 which had introduced code blocks and the <code>begin</code> and <code>end</code> pairs for delimiting them, representing a key advance in the rise of structured programming. ALGOL 60 was the first language implementing nested function definitions with lexical scope.  It gave rise to many other programming languages, including CPL, Simula, BCPL, B, Pascal, and C. Practically every computer of the era had a systems programming language based on ALGOL 60 concepts. </p><p>Niklaus Wirth based his own ALGOL W on ALGOL 60 before moving to develop Pascal. Algol-W was intended to be the next generation ALGOL but the ALGOL 68 committee decided on a design that was more complex and advanced rather than a cleaned simplified ALGOL 60. The official ALGOL versions are named after the year they were first published. Algol 68 is substantially different from Algol 60 and was criticised partially for being so, so that in general \"Algol\" refers to dialects of Algol 60.\n</p>",
        "infobox": {
            "name": "ALGOL 60",
            "paradigms": [
                "procedural programming|procedural",
                "imperative programming|imperative",
                "structured programming|structured"
            ],
            "family": "ALGOL",
            "designers": [
                "John Backus|Backus",
                "Friedrich L. Bauer|Bauer",
                "Julien Green (computer scientist)|Green",
                "Charles Katz|Katz",
                "John McCarthy (computer scientist)|McCarthy",
                "Peter Naur|Naur",
                "Alan Perlis|Perlis",
                "Heinz Rutishauser|Rutishauser",
                "Klaus Samelson|Samelson",
                "Adriaan van Wijngaarden|van Wijngaarden",
                "Bernard Vauquois|Vauquois",
                "Joseph Henry Wegstein|Wegstein",
                "Michael Woodger|Woodger"
            ],
            "released": "1960",
            "typing": [
                "Static type|Static",
                "Strong and weak typing|strong"
            ],
            "scope": "Scope (computer science)|Lexical",
            "influenced by": "ALGOL 58",
            "influenced": [
                "Most subsequent imperative languages (so-called ''ALGOL-like'' languages)",
                "e.g. Simula",
                "Combined Programming Language|CPL",
                "Pascal (programming language)|Pascal",
                "Ada (programming language)|Ada",
                "C (programming language)|C"
            ]
        }
    },
    {
        "id": 11,
        "name": "ALGOL 68",
        "url": "https://en.wikipedia.org/wiki/ALGOL_68",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>ALGOL 68</b> (short for <i>Algorithmic Language 1968</i>) is an imperative programming language that was conceived as a successor to the ALGOL 60 programming language, designed with the goal of a much wider scope of application and more rigorously defined syntax and semantics.\n</p><p>The complexity of the language's definition, which runs to several hundred pages filled with non-standard terminology, made compiler implementation difficult and it was said it had \"no implementations and no users\". This was only partially true; ALGOL 68 did find use in a number of niche markets, notably in the United Kingdom where it was popular on International Computers Limited (ICL) machines, and in teaching roles. Outside these circles, use was relatively limited.\n</p><p>Nevertheless, the contributions of ALGOL 68 to the field of computer science have been deep, wide-ranging and enduring, although many of these contributions were only publicly identified when they had reappeared in subsequently developed programming languages. Many languages were developed specifically as a response to the perceived complexity of the language, the most notable being Pascal, or were reimplementations for specific roles, like Ada.\n</p><p>Many languages of the 1970s trace their design specifically to ALGOL 68, selecting some features while abandoning others that were considered too complex or out-of-scope for given roles. Among these is the language C, which was directly influenced by ALGOL 68, especially by its strong typing and structures. Most modern languages trace at least some of their syntax to either C or Pascal, and thus directly or indirectly to ALGOL 68.\n</p>",
        "infobox": {
            "name": "ALGOL 68",
            "logo": "Algol68RevisedReportCover.jpg",
            "logo caption": [
                "Revised Report on the Algorithmic Language – Algol 68 Edited by: A. van Wijngaarden et al",
                "September 1973"
            ],
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Concurrent programming language|concurrent",
                "Imperative programming|imperative"
            ],
            "family": "ALGOL",
            "designers": [
                "Adriaan van Wijngaarden|A. van Wijngaarden",
                "Barry J. Mailloux|B. J. Mailloux",
                "John E. L. Peck|J. E. L. Peck and Cornelis H. A. Koster|C. H. A. Koster",
                "et al."
            ],
            "released": "Final Report: 1968 <sup>#The language of the unrevised report|r0</sup>",
            "latest release version": "Algol 68/RR",
            "latest release date": "Revised Report: 1973 <sup>#Revisions|r1</sup>",
            "typing": [
                "Type system#Type checking|static",
                "Strong and weak typing|strong",
                "Type system#Safely and unsafely typed systems|safe",
                "Structural type system|structural"
            ],
            "scope": "Scope (computer science)|Lexical",
            "implementations": [
                "ALGOL 68C",
                "Algol 68 Genie (recent)",
                "ALGOL 68-R",
                "ALGOL 68RS",
                "ALGOL 68S",
                "FLACC",
                ":ru:Алгол 68|Алгол 68 Ленинград/Leningrad Unit",
                "Odra (computer)|Odra ALGOL 68"
            ],
            "dialects": "ALGOL 68/FR (Final Report<sup>#The language of the unrevised report|r0</sup>)",
            "influenced by": [
                "ALGOL 60",
                "ALGOL Y"
            ],
            "influenced": [
                "C (programming language)|C",
                "refn|Influence on C: types",
                "structures",
                "arrays",
                "pointers and procedures – Dennis Ritchie|ref| name=\"a68-c1\" refn|Influence on C: union",
                "structure",
                "syntax and long precision – Dennis Ritchie|ref| name=\"a68-c2\" C++",
                "Bourne shell",
                "KornShell",
                "Bash (Unix shell)|Bash",
                "Steelman language requirements|Steelman",
                "Ada (programming language)|Ada",
                "Python (programming language)|Python",
                "Seed7",
                "Mary (programming language)|Mary",
                "S3 (programming language)|S3"
            ]
        }
    },
    {
        "id": 12,
        "name": "ALGOL W",
        "url": "https://en.wikipedia.org/wiki/ALGOL_W",
        "summary": "<p><b>ALGOL W</b> is a programming language. It is based on a proposal for ALGOL X by Niklaus Wirth and Tony Hoare as a successor to ALGOL 60 in International Federation for Information Processing (IFIP) IFIP Working Group 2.1. When the committee decided that the proposal was not a sufficient advance over ALGOL 60, the proposal was published as <i>A contribution to the development of ALGOL</i>. After making small modifications to the language Wirth supervised a high quality implementation for the IBM/360 at Stanford University that was widely distributed.</p><p>It represented a relatively conservative modification of ALGOL 60, adding string, bitstring, complex number and reference to record datatypes and call-by-result passing of parameters, introducing the <b>while</b> statement, replacing <b>switch</b> with the <b>case</b> statement, and generally tightening up the language. </p><p>The implementation was written in PL/360, an ALGOL-like assembly language designed by Wirth. The implementation includes influential debugging and profiling abilities.\n</p>",
        "infobox": {
            "name": "ALGOL W",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Procedural programming|procedural",
                "Imperative programming|imperative",
                "Structured programming|structured"
            ],
            "family": "ALGOL",
            "designers": [
                "Niklaus Wirth",
                "Tony Hoare"
            ],
            "released": "1966",
            "influenced by": "ALGOL 60",
            "influenced": [
                "Pascal (programming language)|Pascal",
                "Modula-2"
            ]
        }
    },
    {
        "id": 13,
        "name": "AMOS (programming language)",
        "url": "https://en.wikipedia.org/wiki/AMOS_(programming_language)",
        "summary": "<p><b>AMOS BASIC</b> is a dialect of the BASIC programming language implemented on the Amiga computer. AMOS BASIC was published by Europress Software and originally written by François Lionet with Constantin Sotiropoulos. </p>",
        "infobox": {
            "name": "AMOS",
            "paradigm": [
                "Imperative programming|Imperative",
                "Procedural programming|Procedural"
            ],
            "year": "1990",
            "developer": "François Lionet and Constantin Sotiropoulos",
            "typing": "Static",
            "dialects": [
                "AMOS",
                "Easy AMOS",
                "AMOS Professional"
            ],
            "influenced_by": "STOS BASIC",
            "operating_system": "AmigaOS",
            "license": "BSD licenses|BSD style license",
            "website": "[https://web.archive.org/web/20120204085705/http://www.clickteam.com/eng/downloadcenter.php?i=58 AMOS and STOS]"
        }
    },
    {
        "id": 14,
        "name": "AMPL",
        "url": "https://en.wikipedia.org/wiki/AMPL",
        "summary": "<p><b>AMPL</b> (<b>A Mathematical Programming Language</b>) is an algebraic modeling language to describe and solve high-complexity problems for large-scale mathematical computing (i.e., large-scale optimization and scheduling-type problems). It was developed by Robert Fourer, David Gay, and Brian Kernighan at Bell Laboratories.\nAMPL supports dozens of solvers, both open source and commercial software, including CBC, CPLEX, FortMP, Gurobi, MINOS, IPOPT, SNOPT, KNITRO, and LGO. Problems are passed to solvers as nl files.\nAMPL is used by more than 100 corporate clients, and by government agencies and academic institutions.</p><p>One advantage of AMPL is the similarity of its syntax to the mathematical notation of optimization problems. This allows for a very concise and readable definition of problems in the domain of optimization. Many modern solvers available on the NEOS Server (formerly hosted at the Argonne National Laboratory, currently hosted at the University of Wisconsin, Madison) accept AMPL input. According to the NEOS statistics AMPL is the most popular format for representing mathematical programming problems.\n</p>",
        "infobox": {
            "name": "AMPL",
            "logo": "File:AMPL (textbook cover).jpg",
            "designers": "Robert Fourer<br />David Gay<br />Brian Kernighan<br/>Bell Labs",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: Declarative programming|declarative",
                "Imperative programming|imperative"
            ],
            "developer": [
                "AMPL Optimization",
                "Inc."
            ],
            "released": "1985",
            "latest release version": "20131012",
            "latest release date": "2013|10|12",
            "influenced by": [
                "AWK",
                "C (programming language)|C"
            ],
            "influenced": "Coopr",
            "operating system": [
                "Cross-platform: Linux",
                "macOS",
                "Solaris (operating system)|Solaris",
                "IBM AIX|AIX",
                "Microsoft Windows|Windows"
            ],
            "license": "Proprietary software|Proprietary (translator),<br />Free and open source software|free and open-source (AMPL Solver Library)",
            "genre": "Algebraic modeling language (AML)",
            "website": "www.ampl.com",
            "file ext": [
                ".mod",
                ".dat",
                ".run"
            ]
        }
    },
    {
        "id": 15,
        "name": "APL (programming language)",
        "url": "https://en.wikipedia.org/wiki/APL_(programming_language)",
        "summary": "<p><b>APL</b> (named after the book <i>A Programming Language</i>) is a programming language developed in the 1960s by Kenneth E. Iverson. Its central datatype is the multidimensional array. It uses a large range of special graphic symbols to represent most functions and operators, leading to very concise code. It has been an important influence on the development of concept modeling, spreadsheets, functional programming, and computer math packages. It has also inspired several other programming languages.</p>",
        "infobox": {
            "name": "APL",
            "paradigm": [
                "Array programming|Array",
                "Functional programming|functional",
                "Structured programming|structured",
                "Modular programming|modular"
            ],
            "year": "1966|11|27",
            "designer": "Kenneth E. Iverson",
            "developer": [
                "Lawrence M. Breed|Larry Breed",
                "Richard H. Lathwell|Dick Lathwell",
                "Roger Moore (computer scientist)|Roger Moore and others"
            ],
            "latest release version": "ISO/IEC 13751:2001",
            "latest release date": "2001|02|01",
            "typing": "Type system|Dynamic",
            "platform": "Cross platform",
            "license": [
                "Proprietary software|Proprietary",
                "Open-source software|open source"
            ],
            "implementations": "startflatlist *APL\\360\n*APL\\1130\n*APL*Plus\n*Sharp APL\n*APL2\n*Dyalog APL\n*NARS2000\n*APLX\n*GNU APL endflatlist",
            "influenced by": "Mathematical notation",
            "influenced": "startflatlist * A+ (programming language)|A and A+\n* FP (programming language)|FP\n* J (programming language)|J\n* K (programming language)|K\n* LYaPAS\n* MATLAB\n* Nial\n* Polymorphic Programming Language|PPL\n* Python (programming language)|Python\n* S (programming language)|S\n* Speakeasy (computational environment)|Speakeasy\n* Wolfram Language endflatlist"
        }
    },
    {
        "id": 16,
        "name": "APT (programming language)",
        "url": "https://en.wikipedia.org/wiki/APT_(programming_language)",
        "summary": "<p><b>APT</b> or <i>Automatically Programmed Tool</i> is a high-level computer programming language most commonly used to generate instructions for numerically controlled machine tools. Douglas T. Ross is considered by many to be the father of APT: as head of the newly created Computer Applications Group of the Servomechanisms Laboratory at MIT in 1956, he led its technical effort. APT is a language and system that makes numerically controlled manufacturing possible. This early language was used widely through the 1970s and is still a standard internationally. Derivatives of APT were later developed. </p>\n\n\n",
        "infobox": "N/A"
    },
    {
        "id": 17,
        "name": "ARexx",
        "url": "https://en.wikipedia.org/wiki/ARexx",
        "summary": "<p><b>ARexx</b> is an implementation of the Rexx language for the Amiga, written in 1987 by William S. Hawes, with a number of Amiga-specific features beyond standard REXX facilities.  Like most REXX implementations, ARexx is an interpreted language. Programs written for ARexx are called \"scripts\", or \"macros\"; several programs offer the ability to run ARexx scripts in their main interface as macros. </p><p>ARexx can easily communicate with third-party software that implements an \"ARexx port\". Any Amiga application or script can define a set of commands and functions for ARexx to address, thus making the capabilities of the software available to the scripts written in ARexx.\n</p><p>ARexx can direct commands and functions to several applications from the same script, thus offering the opportunity to mix and match functions from the different programs. For example, an ARexx script could extract data from a database, insert the data into a spreadsheet to perform calculations on it, then insert tables and charts based on the results into a word processor document.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 18,
        "name": "AS/400 Control Language",
        "url": "https://en.wikipedia.org/wiki/IBM_i_Control_Language",
        "summary": "<p>The <b>IBM i Control Language</b> (<b>CL</b>) is a scripting language for the IBM's IBM i platform (previously called OS/400 when running on AS/400 systems) bearing a resemblance to the IBM Job Control Language and consisting of an ever-expanding set of command objects (*CMD) used to invoke traditional AS/400 programs and/or get help on what those programs do. CL can also be used to create CL programs (congruent to shell scripts) where there are additional commands that provide program-like functionality (IF/ELSE, variable declaration, file input, etc.) </p><p>Although CL is a scripting language for system administration, it is used mainly to create compiled programs. The use of interpreted CL scripts through the SBMDBJOB command  is in fact extremely limited.\n</p><p>While thousands of commands were written by IBM developers to perform system level tasks like compiling programs, backing up data, changing system configurations, displaying system object details, or deleting them, commands are not limited to systems level concerns and can be drafted for user applications as well.\n</p>",
        "infobox": {
            "name": "AS/400 Control Language",
            "paradigm": "Imperative programming|imperative",
            "designer": "IBM",
            "developer": "IBM",
            "influenced_by": [
                "Job Control Language",
                "PL/I"
            ],
            "influenced": "Windows PowerShell",
            "operating_system": "IBM System i"
        }
    },
    {
        "id": 19,
        "name": "AWK",
        "url": "https://en.wikipedia.org/wiki/AWK",
        "summary": "<p><b>AWK</b> is a domain-specific language designed for text processing and typically used as a data extraction and reporting tool. It is a standard feature of most Unix-like operating systems. </p><p>The AWK language is a data-driven scripting language consisting of a set of actions to be taken against streams of textual data – either run directly on files or used as part of a pipeline – for purposes of extracting or transforming text, such as producing formatted reports. The language extensively uses the string datatype, associative arrays (that is, arrays indexed by key strings), and regular expressions. While AWK has a limited intended application domain and was especially designed to support one-liner programs, the language is Turing-complete, and even the early Bell Labs users of AWK often wrote well-structured large AWK programs.</p><p>AWK was created at Bell Labs in the 1970s, and its name is derived from the surnames of its authors: Alfred Aho, Peter Weinberger, and Brian Kernighan. The acronym is pronounced the same as the bird auk, which is on the cover of <i>The AWK Programming Language</i>.  When written in all lowercase letters, as <code>awk</code>, it refers to the Unix or Plan 9 program that runs scripts written in the AWK programming language.\n</p>\n\n\n",
        "infobox": {
            "name": "AWK",
            "paradigm": [
                "scripting language|Scripting",
                "procedural programming|procedural",
                "data-driven programming|data-driven"
            ],
            "year": "start date and age|1977",
            "latest_release_version": "[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/awk.html IEEE Std 1003.1-2008] (POSIX) / 1985",
            "designer": [
                "Alfred Aho",
                "Peter J. Weinberger|Peter Weinberger",
                "and Brian Kernighan"
            ],
            "typing": [
                "none; can handle strings",
                "integers and floating-point numbers; regular expressions"
            ],
            "implementations": [
                "awk",
                "GNU Awk",
                "mawk",
                "nawk",
                "MKS AWK",
                "Thompson AWK (compiler)",
                "Awka (compiler)"
            ],
            "dialects": [
                "''old awk'' oawk 1977",
                "''new awk'' nawk 1985",
                "''GNU Awk'' gawk"
            ],
            "influenced_by": [
                "C (programming language)|C",
                "sed",
                "SNOBOL"
            ],
            "influenced": [
                "Tcl",
                "AMPL",
                "Perl ",
                "Korn Shell (''ksh93'' ",
                "''dtksh''",
                "''tksh'')",
                "Lua (programming language)|Lua"
            ],
            "operating_system": "Cross-platform"
        }
    },
    {
        "id": 20,
        "name": "A Sharp (.NET)",
        "url": "https://en.wikipedia.org/wiki/A_Sharp_(.NET)",
        "summary": "<p><b>A#</b> is a port of the Ada programming language to the Microsoft .NET platform. A# is freely distributed by the Department of Computer Science at the United States Air Force Academy as a service to the Ada community under the terms of the GNU General Public License. </p><p>AdaCore has taken over this development, and announced \"GNAT for .NET\", which is a fully supported .NET product with all of the features of A# and more.</p>",
        "infobox": {
            "name": "A#",
            "title": "A#",
            "designer": [
                "Dr. Martin C. Carlisle",
                "Lt Col Ricky Sward",
                "Maj Jeff Humphries"
            ],
            "developer": "AdaCore",
            "released": "start date and age|2004",
            "platform": "Common Language Infrastructure",
            "operating system": "Cross-platform",
            "license": "GNU General Public License",
            "website": "url|www.asharp.martincarlisle.com"
        }
    },
    {
        "id": 21,
        "name": "Accent (programming language)",
        "url": "https://en.wikipedia.org/wiki/Rational_Synergy",
        "summary": "<p><b>Rational Synergy</b> is a software tool that provides software configuration management (SCM) capabilities for all artifacts related to software development including source code, documents and images as well as the final built software executable and libraries. Rational Synergy also provides the repository for the change management tool known as Rational Change. Together these two tools form an integrated configuration management and change management environment that is used in software development organizations that need controlled SCM processes and an understanding of what is in a build of their software. </p><p>The name <i>Synergy</i> refers to its database level integration with Change Management that provides views into what is in a build in terms of defects.\n</p>",
        "infobox": {
            "name": "Rational Synergy",
            "logo": "File:RationalSoftware.png|frameless",
            "author": [
                "CaseWare",
                "Inc."
            ],
            "developer": "Rational Software",
            "released": "1990",
            "genre": "Software configuration management",
            "license": "IBM Software license|EULA",
            "website": "http://www.ibm.com/software/products/en/ratisyne",
            "latest_release_version": "7.2.1.6",
            "latest_release_date": "release date and age|2017|09|21",
            "operating_system": [
                "IBM AIX|AIX",
                "HP-UX",
                "Linux",
                "Solaris (operating system)|Solaris",
                "Microsoft Windows|Windows"
            ],
            "programming_language": [
                "Accent",
                "Java (programming language)|Java"
            ]
        }
    },
    {
        "id": 22,
        "name": "Action! (programming language)",
        "url": "https://en.wikipedia.org/wiki/Action!_(programming_language)",
        "summary": "<p><b>Action!</b> is a procedural programming language similar to ALGOL that is intended to produce high-performance programs for the Atari 8-bit family. The language was written by Clinton Parker and distributed on ROM cartridge by Optimized Systems Software (OSS) starting in 1983. It was one of the first of OSS's bank switching \"Super Cartridges\", with a total of 16 kB of code. </p><p>Working with Henry Baker, Parker had previously developed Micro-SPL, a systems programming language for the Xerox Alto. Action! was largely a port of Micro-SPL concepts to the Atari with the necessary changes to more directly handle the underlying MOS 6502 processor and add an editor and debugger.\n</p><p>Action! was used to develop at least two commercial products—the <i>HomePak</i> productivity suite and <i>Games Computers Play</i> client program—and numerous programs in <i>ANALOG Computing</i> and <i>Antic</i> magazines. The editor portion was also used as the basis for the PaperClip word processor. The language was not ported to any other platforms.\n</p><p>The 6502 assembly language source code for Action! was made available under the GNU General Public License by the author in 2015.</p>",
        "infobox": {
            "name": "Action!",
            "screenshot": "actionscr.png",
            "caption": "Action! editor",
            "screenshot alt": "Action! editor",
            "author": "Clinton Parker",
            "developer": "Optimized Systems Software",
            "discontinued": "yes",
            "released": "1983|08|df|=|yes/no",
            "latest release version": "v3.6",
            "latest release date": "1983|11|04",
            "platform": "Atari 8-bit family",
            "size": "16K bank-switched cartridge"
        }
    },
    {
        "id": 23,
        "name": "ActionScript",
        "url": "https://en.wikipedia.org/wiki/ActionScript",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>ActionScript</b> is an object-oriented programming language originally developed by Macromedia Inc. (later acquired by Adobe Systems). It is influenced by HyperTalk, the scripting language for HyperCard. It is now an implementation of ECMAScript (meaning it is a superset of the syntax and semantics of the language more widely known as JavaScript), though it originally arose as a sibling, both being influenced by HyperTalk.\n</p><p>ActionScript is used primarily for the development of websites and software targeting the Adobe Flash Player platform, used on Web pages in the form of embedded SWF files.\n</p><p>ActionScript 3 is also used with Adobe AIR system for the development of desktop and mobile applications. The language itself is open-source in that its specification is offered free of charge and both an open source compiler (as part of Apache Flex) and open source virtual machine (Mozilla Tamarin) are available.\n</p><p>ActionScript is also used with Scaleform GFx for the development of 3D video game user interfaces and HUDs.\n</p>",
        "infobox": {
            "name": "ActionScript",
            "logo": "ActionScript icon.png",
            "paradigm": [
                "Multi-paradigm: object-oriented (prototype-based programming|prototype-based)",
                "functional programming|functional",
                "imperative programming|imperative",
                "scripting language|scripting"
            ],
            "year": "1998",
            "designer": "Gary Grossman",
            "developer": "Macromedia (now dissolved into Adobe Systems)",
            "latest_release_version": "3.0",
            "latest_release_date": "release date|2006|06|27",
            "typing": [
                "strong typing|strong",
                "static typing|static"
            ],
            "implementations": [
                "Adobe Flash Player",
                "Adobe AIR",
                "Apache Flex",
                "Scaleform GFx"
            ],
            "influenced_by": [
                "JavaScript",
                "Java (programming language)|Java"
            ],
            "influenced": "Haxe",
            "website": "[https://www.adobe.com/devnet/actionscript/articles/actionscript3_overview.html adobe.com/devnet/actionscript/]"
        }
    },
    {
        "id": 24,
        "name": "Actor (programming language)",
        "url": "https://en.wikipedia.org/wiki/Actor_(programming_language)",
        "summary": "<p>The <b>Actor</b> programming language was invented by Charles Duff of The Whitewater Group in 1988. It was an offshoot of some object-oriented extensions to the Forth language he had been working on. </p><p>Actor is a pure object-oriented language in the style of Smalltalk. Like Smalltalk, everything is an object, including small integers. A Baker semi-space garbage collector is used, along with (in memory-constrained Windows 2.1 days) a software virtual memory system that swaps objects. A token threaded interpreter, written in 16-bit x86 assembly language, executes compiled code.\n</p><p>Actor only was released for Microsoft Windows 2.1 and 3.0. Actor used a pure object-oriented framework over native operating system calls as its basic GUI architecture. This allows an Actor application to look and feel exactly like a Windows application written in C, but with all the advantages of an interactive Smalltalk-like development environment. Both a downside and upside to this architecture is a tight coupling to the Windows architecture, with a thin abstraction layer into objects. This allows direct use of the rich Windows OS API, but also makes it nearly impossible to support any other OS without a significant rewrite of the application framework.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 25,
        "name": "Ada (programming language)",
        "url": "https://en.wikipedia.org/wiki/Ada_(programming_language)",
        "summary": "<p><b>Ada</b> is a structured, statically typed, imperative, and object-oriented high-level programming language, extended from Pascal and other languages. It has built-in language support for <i>design by contract</i> (DbC), extremely strong typing, explicit concurrency, tasks, synchronous message passing, protected objects, and non-determinism. Ada improves code safety and maintainability by using the compiler to find errors in favor of runtime errors. Ada is an international technical standard, jointly defined by the International Organization for Standardization (ISO), and the International Electrotechnical Commission (IEC). As of 2020, the standard, called Ada 2012 informally, is ISO/IEC 8652:2012.</p><p>Ada was originally designed by a team led by French computer scientist Jean Ichbiah of CII Honeywell Bull under contract to the United States Department of Defense (DoD) from 1977 to 1983 to supersede over 450 programming languages used by the DoD at that time. Ada was named after Ada Lovelace (1815–1852), who has been credited as the first computer programmer.</p>",
        "infobox": {
            "name": "Ada",
            "logo": "Ada Mascot with slogan.svg",
            "logo alt": [
                "Ada mascot",
                "a black and cobalt blue hummingbird",
                "flying above the slogan \"Time-tested",
                "safe and secure\""
            ],
            "paradigm": "Multi-paradigm programming language|Multi-paradigm",
            "family": "Pascal (programming language)|Pascal",
            "designers": [
                "* MIL-STD-1815",
                "Ada 83: Jean Ichbiah\n* Ada 95: Tucker Taft\n* Ada 2005: Tucker Taft\n* Ada 2012: Tucker Taft"
            ],
            "typing": [
                "Static typing|static",
                "Strong and weak typing|strong",
                "Type safety|safe",
                "Nominative type system|nominative"
            ],
            "implementations": [
                "AdaCore GNAT (free download: http://libre.adacore.com/download),<br/>Green Hills Software Optimising Ada 95 compiler,<br/>PTC",
                "Inc. PTC ApexAda and PTC ObjectAda",
                "<br/> cite web|url|=|https://www.mapusoft.com/ada-to-c-changer/|title|=|MapuSoft Ada-C/C++ changer ",
                "formerly known as \"AdaMagic with C Intermediate\"",
                "<br/>DDC-I Score"
            ],
            "dialects": [
                "SPARK (programming language)|SPARK",
                "Ravenscar profile"
            ],
            "influenced": [
                "C++",
                "Chapel (programming language)|Chapel",
                "cite web|url|=|http://www.iuma.ulpgc.es/users/gsd/Drago/|title|=|Drago ",
                "Eiffel (programming language)|Eiffel",
                "cite web|url|=|https://cs.nyu.edu/cs/faculty/goldberg/griffin.html|title|=|Griffin ",
                "Java (programming language)|Java",
                "Nim (programming language)|Nim",
                "ParaSail (programming language)|ParaSail",
                "PL/SQL",
                "PL/pgSQL",
                "Python (programming language)|Python",
                "Ruby (programming language)|Ruby",
                "Seed7",
                "cite web|url|=|https://www.sparforte.com/|title|=|SPARforte ",
                "ParaSail (programming language)#Description|Sparkel",
                "SQL/PSM",
                "VHDL"
            ],
            "website": "www.adaic.org",
            "released": "1980|02",
            "latest release version": "Ada 2012 TC1",
            "latest release date": "start date and age|2016|02|01",
            "latest preview version": "Ada 2012 TC1",
            "latest preview date": "start date and age|2015|04",
            "influenced by": [
                "ALGOL 68",
                "Pascal (programming language)|Pascal",
                "C++ (Ada 95)",
                "Smalltalk (Ada 95)",
                "Modula-2 (Ada 95) Java (programming language)|Java (Ada 2005)",
                "Eiffel (programming language)|Eiffel (Ada 2012)"
            ],
            "operating system": "Multi- or cross-platform",
            "file ext": [
                ".adb",
                ".ads"
            ],
            "wikibooks": "Ada Programming"
        }
    },
    {
        "id": 26,
        "name": "Adenine (programming language)",
        "url": "https://en.wikipedia.org/wiki/Haystack_(MIT_project)",
        "summary": "<p><b>Haystack</b> was a project at the Massachusetts Institute of Technology to research and develop several applications around personal information management and the Semantic Web. The most notable of those applications is the Haystack client, a research personal information manager (PIM) and one of the first to be based on semantic desktop technologies. The Haystack client is published as open source software under the BSD license.  </p><p>Similar to the Chandler PIM, the Haystack system unifies handling different types of unstructured information. This information has a common representation in RDF that is presented to users in a configurable human-readable way.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 27,
        "name": "Agda (theorem prover)",
        "url": "https://en.wikipedia.org/wiki/Agda_(programming_language)",
        "summary": "<p><b>Agda</b> is a dependently typed functional programming language originally developed by Ulf Norell at Chalmers University of Technology with implementation described in his PhD thesis. The original Agda system was developed at Chalmers by Catarina Coquand in 1999. The current version, originally known as Agda 2, is a full rewrite, which should be considered a new language that shares a name and tradition. </p><p>Agda is also a proof assistant based on the propositions-as-types paradigm, but unlike Coq, has no separate tactics language, and proofs are written in a functional programming style. The language has ordinary programming constructs such as data types, pattern matching, records, let expressions and modules, and a Haskell-like syntax. The system has Emacs and Atom interfaces but can also be run in batch mode from the command line.\n</p><p>Agda is based on Zhaohui Luo's unified theory of dependent types (UTT), a type theory similar to Martin-Löf type theory.\n</p><p>Agda is named after the Swedish song \"Hönan Agda\", written by Cornelis Vreeswijk, which is about a hen named Agda. This alludes to the naming of Coq.\n</p>",
        "infobox": {
            "name": "Agda",
            "logo": "Agda's official logo.svg",
            "logo alt": [
                "A stylized chicken in black lines and dots",
                "to the left of the name “Agda” in sans-serif test with the first letter slanted to the right."
            ],
            "paradigm": "functional programming|Functional",
            "year": "2007 (1.0 in 1999 )",
            "designer": "Ulf Norell; Catarina Coquand (1.0)",
            "developer": "Ulf Norell; Catarina Coquand (1.0)",
            "latest release version": "2.6.1",
            "latest release date": "2020|03|16",
            "typing": [
                "Strong typing|strong",
                "Static typing|static",
                "Dependent typing|dependent",
                "Nominal typing|nominal",
                "Manifest typing|manifest",
                "Inferred typing|inferred"
            ],
            "influenced": "Idris (programming language)|Idris",
            "programming language": "Haskell (programming language)|Haskell",
            "influenced by": [
                "Coq",
                "Epigram (programming language)|Epigram",
                "Haskell (programming language)|Haskell"
            ],
            "license": "BSD licenses|BSD-like",
            "file ext": [
                "<code>.agda</code>",
                "<code>.lagda</code>",
                "<code>.lagda.md</code>",
                "<code>.lagda.rst</code>",
                "<code>.lagda.tex</code>"
            ],
            "operating system": "Cross-platform",
            "website": "wiki.portal.chalmers.se/agda"
        }
    },
    {
        "id": 28,
        "name": "Agilent VEE",
        "url": "https://en.wikipedia.org/wiki/Keysight_VEE",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Keysight VEE</b> is a graphical dataflow programming software development environment from Keysight Technologies for automated test, measurement, data analysis and reporting. VEE originally stood for Visual Engineering Environment and developed by HP designated as HP VEE; it has since been officially renamed to Keysight VEE. Keysight VEE has been widely used in various industries, serving the entire stage of a product lifecycle, from design, validation to manufacturing. It is optimized in instrument control and automation with test and measurement devices such as data acquisition instruments like digital voltmeters and oscilloscopes, and source devices like signal generators and programmable power supplies.\n</p>",
        "infobox": {
            "name": "Keysight VEE",
            "caption": "Keysight VEE Workspace",
            "developer": "Keysight Technologies",
            "operating system": "Microsoft Windows",
            "genre": "Integrated Development Environment",
            "license": "Proprietary software|Proprietary commercial software",
            "website": "url|http://www.keysight.com/find/vee"
        }
    },
    {
        "id": 29,
        "name": "Agora (programming language)",
        "url": "https://en.wikipedia.org/wiki/Agora_(programming_language)",
        "summary": "<p><b>Agora</b> is a reflective, prototype-based, object-oriented programming language that is based exclusively on message passing and not delegation. Agora was intended to show that even subject to that limit, it is possible to build a full object-oriented language that features inheritance, cloning and reflective operators. </p>",
        "infobox": "N/A"
    },
    {
        "id": 30,
        "name": "Aldor",
        "url": "https://en.wikipedia.org/wiki/Aldor",
        "summary": "<p><b>Aldor</b> is a programming language. It is the successor of A# as the extension language of the Axiom computer algebra system. </p><p>Aldor combines imperative, functional, and object-oriented features. It has an elaborate type system,<cite class=\"citation web cs1\">\"Aldor Programming Language\". <i>Aldor.org</i><span>. Retrieved <span>12 February</span> 2017</span>.</cite><span title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=unknown&amp;rft.jtitle=Aldor.org&amp;rft.atitle=Aldor+Programming+Language&amp;rft_id=http%3A%2F%2Fwww.aldor.org&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAldor\"></span> allowing types to be used as first-class values. Aldor's syntax is heavily influenced by Pascal, but it is optionally indentation-sensitive, using whitespace characters and the off-side rule, like Python. In its current implementation, it is compiled, but an interactive listener is provided.\n</p><p>Aldor is distributed as free and open-source software, under the Apache License 2.0.\n</p>",
        "infobox": {
            "name": "Aldor",
            "file ext": [
                ".al",
                ".as"
            ],
            "paradigm": [
                "Programming paradigm#Multi-paradigm|Multi-paradigm: Object-oriented programming|object-oriented",
                "Functional programming|functional",
                "Imperative programming|imperative",
                "dependent typed",
                "Logic programming|logic"
            ],
            "released": "1990",
            "designer": [
                "Richard Dimick Jenks",
                "Barry Trager",
                "Stephen Watt",
                "James Davenport",
                "Robert Sutor",
                "Scott Morrison"
            ],
            "developer": "Thomas J. Watson Research Center",
            "latest release version": "1.0.3",
            "latest preview version": "1.1.0",
            "implementations": "Axiom (computer algebra system)|Axiom computer algebra system",
            "influenced by": [
                "A♯ (Axiom)|A#",
                "Pascal (programming language)|Pascal",
                "Haskell (programming language)|Haskell"
            ],
            "platform": "Axiom (computer algebra system)|Axiom computer algebra system",
            "operating system": [
                "Linux",
                "Solaris (operating system)|Solaris",
                "Microsoft Windows|Windows"
            ],
            "license": [
                "Aldor Public 2.0",
                "Apache License|Apache 2.0"
            ],
            "website": "www.aldor.org"
        }
    },
    {
        "id": 31,
        "name": "Alef (programming language)",
        "url": "https://en.wikipedia.org/wiki/Alef_(programming_language)",
        "summary": "<p><b>Alef</b> is a discontinued concurrent programming language, designed as part of the Plan 9 operating system by Phil Winterbottom of Bell Labs. It implemented the channel-based concurrency model of Newsqueak in a compiled, C-like language. </p>",
        "infobox": {
            "name": "Alef",
            "paradigm": [
                "Compiled language|compiled",
                "Concurrent programming|concurrent",
                "structured programming|structured"
            ],
            "year": "1992",
            "designer": "Phil Winterbottom",
            "typing": [
                "Static typing|Static",
                "Strongly-typed programming language|strong"
            ],
            "influenced_by": [
                "C (programming language)|C",
                "Newsqueak"
            ],
            "influenced": [
                "Limbo (programming language)|Limbo",
                "Rust (programming language)|Rust",
                "Go (programming language)|Go"
            ],
            "operating_system": "Plan 9 from Bell Labs"
        }
    },
    {
        "id": 32,
        "name": "Algebraic Logic Functional programming language",
        "url": "https://en.wikipedia.org/wiki/Algebraic_Logic_Functional_programming_language",
        "summary": "<p><b>Algebraic Logic Functional programming language</b>, also known as <b>ALF</b>, is a programming language which combines functional and logic programming techniques. Its foundation is Horn clause logic with equality which consists of predicates and Horn clauses for logic programming, and functions and equations for functional programming. </p><p>ALF was designed to be genuine integration of both programming paradigms, and thus any functional expression can be used in a goal literal and arbitrary predicates can occur in conditions of equations. ALF's operational semantics is based on the resolution rule to solve literals and narrowing to evaluate functional expressions. In order to reduce the number of possible narrowing steps, a leftmost-innermost basic narrowing strategy is used which, it is claimed, can be efficiently implemented. Terms are simplified by rewriting before a narrowing step is applied and equations are rejected if the two sides have different constructors at the top. Rewriting and rejection are supposed to result in a large reduction of the search tree and produce an operational semantics that is more efficient than Prolog's resolution strategy. Similarly to Prolog, ALF uses a backtracking strategy corresponding to a depth-first search in the derivation tree.\n</p><p>The ALF system was designed to be an efficient implementation of the combination of resolution, narrowing, rewriting, and rejection. ALF programs are compiled into instructions of an abstract machine. The abstract machine is based on the Warren Abstract Machine (WAM) with several extensions to implement narrowing and rewriting. In the current ALF implementation programs of this abstract machine are executed by an emulator written in C.\n</p><p>In the Carnegie Mellon University Artificial Intelligence Repository, ALF is included as an AI programming language, in particular as a functional/logic programming language Prolog implementation. A user manual describing the language and the use of the system is available. The ALF System runs under Unix and is available under a custom proprietary software license that grants the right to use for \"evaluation, research and teaching purposes\" but not commercial or military use.</p>",
        "infobox": {
            "name": "ALF",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: logic programming|logic",
                "functional programming|functional"
            ],
            "website": "[http://www.informatik.uni-kiel.de/~mh/systems/ALF/README Getting and installing ALF]"
        }
    },
    {
        "id": 33,
        "name": "Alice (programming language)",
        "url": "https://en.wikipedia.org/wiki/Alice_(programming_language)",
        "summary": "<p><b>Alice ML</b> is a programming language designed by the Programming Systems Laboratory at Saarland University, Saarbrücken, Germany. It is a dialect of Standard ML, augmented with support for lazy evaluation, concurrency (multithreading and distributed computing via remote procedure calls) and constraint programming. </p>",
        "infobox": {
            "name": "Alice",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm: imperative programming|imperative",
                "functional programming|functional",
                "distributed programming|distributed",
                "concurrent programming language|concurrent"
            ],
            "designer": "Saarland University",
            "released": "2000",
            "latest release version": "1.4",
            "latest release date": "2007|05|03",
            "typing": [
                "strong typing|strong",
                "static typing|static",
                "type inference|inferred"
            ],
            "influenced by": [
                "ML (programming language)|ML",
                "Oz (programming language)|Oz"
            ],
            "operating system": "Cross-platform",
            "license": "MIT License|MIT",
            "website": "www.ps.uni-saarland.de/alice"
        }
    },
    {
        "id": 34,
        "name": "Alma-0",
        "url": "https://en.wikipedia.org/wiki/Alma-0",
        "summary": "<p><b>Alma-0</b> is a multi-paradigm computer programming language. This language is an augmented version of the imperative Modula-2 language with logic-programming features and convenient backtracking capability. It is small, strongly typed, and combines constraint programming, a limited number of features inspired by logic programming and supports imperative paradigms. The language advocates declarative programming. The designers claim that search-oriented solutions built with it are substantially simpler than their counterparts written in purely imperative or logic programming style. [1] Alma-0 provides natural, high-level constructs for the construction of search trees.</p>",
        "infobox": {
            "name": "Alma-0",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: Constraint programming|constraint",
                "Imperative programming|imperative",
                "Logic programming|logic"
            ],
            "designer": [
                "Krzysztof Apt",
                "Marc Bezem",
                "Jacob Brunekree",
                "Vincent Partington",
                "Andrea Schaerf"
            ],
            "developer": "Centrum Wiskunde & Informatica",
            "typing": "Type system|static",
            "implementations": "Alma-0",
            "website": "[http://www.cwi.nl/en/alma/ www.cwi.nl/en/alma]"
        }
    },
    {
        "id": 35,
        "name": "AmbientTalk",
        "url": "https://en.wikipedia.org/wiki/AmbientTalk",
        "summary": "<p><b>AmbientTalk</b> is an experimental object-oriented distributed programming language developed at the Programming Technology Laboratory at the Vrije Universiteit Brussel, Belgium. The language is primarily targeted at writing programs deployed in mobile ad hoc networks. </p><p>AmbientTalk is meant to serve as an <i>experimentation platform</i> to experiment with new language features or programming abstractions to facilitate the construction of software that has to run in highly volatile networks exhibiting intermittent connectivity and little infrastructure. It is implemented in Java which enables interpretation on various platforms, including Android. The interpreter standard library also provides a seamless interface between Java and AmbientTalk objects, called the symbiosis.\n</p><p>The language's concurrency features, which include support for futures and event-loop concurrency, are founded on the actor model and have been largely influenced by the E programming language. The language's object-oriented features find their influence in languages like Smalltalk (i.e. block closures, keyworded messages) and Self (prototype-based programming, traits, delegation).\n</p>",
        "infobox": {
            "name": "AmbientTalk",
            "paradigm": "Object-oriented programming|object-oriented (prototype-based programming|prototype-based) Concurrent computing|Concurrent Event-driven programming|Event-driven Reflection (computer science)|Reflective",
            "year": "2006",
            "designer": [
                "Tom Van Cutsem",
                "Stijn Mostinckx",
                "Jessie Dedecker",
                "Wolfgang De Meuter"
            ],
            "developer": [
                "Software Languages Lab",
                "University of Brussels"
            ],
            "latest release version": "2.19",
            "latest release date": "April 2011",
            "typing": [
                "Type system|dynamic",
                "Strongly-typed programming language|strong"
            ],
            "implementations": "AmbientTalk (interpreter)",
            "influenced_by": [
                "Smalltalk",
                "Self (programming language)|Self",
                "Scheme (programming language)|Scheme",
                "E (programming language)|E",
                "Actor-Based Concurrent Language|ABCL"
            ],
            "influenced": "ECMAScript Harmony",
            "operating_system": "Platform-independent",
            "license": "MIT License",
            "website": "http://soft.vub.ac.be/amop",
            "file_ext": ".at"
        }
    },
    {
        "id": 36,
        "name": "Amiga E",
        "url": "https://en.wikipedia.org/wiki/Amiga_E",
        "summary": "<p><b>Amiga E</b>, or very often simply <b>E</b>, is a programming language created by Wouter van Oortmerssen on the Amiga. He has since moved on to develop the SHEEP programming language for the new AmigaDE platform and the CryScript language (also known as DOG) used during the development of the video game Far Cry. </p>",
        "infobox": "N/A"
    },
    {
        "id": 37,
        "name": "AngelScript",
        "url": "https://en.wikipedia.org/wiki/AngelScript",
        "summary": "<p><b>AngelScript</b> is a game-oriented compiled scripting language. </p><p>AngelScript features static typing, object handles (similar to C++ pointers but garbage collected via reference counting), object-orientation, single inheritance, multiple inheritance with interfaces. Allows operators to be registered and overloaded. AngelScript can be used with any C++ IDE, such as Netbeans, Geany, and Eclipse.\n</p><p>C and C++ functions can be called within an AngelScript environment. AngelScript's class syntax closely follows C++ classes by design: no proxy functions are required to embed AngelScript in C++ applications easing the two languages integration. There are several differences of AngelScript and C++:\n</p>\n<ul><li>AngelScript does not support multiple inheritance. Multiple-inheritance functionality may be achieved with Interfaces.</li>\n<li>It is impossible to declare methods or properties outside of the class body.</li>\n<li>All methods (including constructors and destructors) are virtual.</li></ul><p>AngelScript is used in video game development, including Amnesia: The Dark Descent, Amy, Dustforce, Gekkeiju Online, King Arthur's Gold, Legend of the Guardians: The Owls of Ga'Hoole, Overgrowth, Penumbra: Overture, Penumbra: Requiem, Puddle, Rigs of Rods, Sine Mora, Star Ruler, SuperTuxKart, Warhammer: Mark of Chaos, Warsow, Sven Co-op, Jazz Jackrabbit 2 Plus, Urho3D. AngelScript is used at the University of Ulm in interactive 3D-Animation program. AngelScript is also used in robotics, for example, to program behavioral rules of robotic agents.</p>",
        "infobox": {
            "name": "AngelScript",
            "paradigm": [
                "Multi-paradigm: scripting language|scripting",
                "imperative programming|imperative (procedural programming|procedural",
                "object-oriented programming|object-oriented)"
            ],
            "year": "2003",
            "developer": "Andreas Jönsson",
            "latest release version": "2.34.0",
            "latest release date": "2019|09|22",
            "typing": [
                "static typing|static",
                "type system#Strong typing|strong"
            ],
            "influenced by": "C++",
            "operating system": "Cross-platform",
            "license": "zlib License",
            "website": "Official URL"
        }
    },
    {
        "id": 38,
        "name": "Apex (programming language)",
        "url": "https://en.wikipedia.org/wiki/Salesforce",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Salesforce.com, inc.</b> is an American cloud-based software company headquartered in San Francisco, California. It provides customer relationship management (CRM) service and also sells a complementary suite of enterprise applications focused on customer service, marketing automation, analytics, and application development.\n</p><p>In 2020, <i>Fortune</i> magazine ranked Salesforce at number six on their Fortune List of the Top 100 Companies to Work For in 2020 based on an employee survey of satisfaction.</p>\n\n\n",
        "infobox": {
            "name": [
                "salesforce.com",
                "inc."
            ],
            "logo": "Salesforce logo.svg",
            "image": "Salesforce Tower SF 2017.jpg",
            "image_caption": "Salesforce Tower in San Francisco",
            "trade_name": "Salesforce",
            "type": "Public company|Public",
            "traded_as": "ubl|NYSE|CRM|S&P 100 component|S&P 500 component NYSE|CRM",
            "industry": "Flatlist|\n* Cloud computing\n* Software",
            "foundation": "1999",
            "location": [
                "Salesforce Tower<br />San Francisco",
                "California",
                "U.S."
            ],
            "key_people": [
                "Marc Benioff<br /><small>(Chairman",
                "CEO)</small><br />Parker Harris<br /><small>(Co-Founder)</small>"
            ],
            "products": "Sales Cloud<br />Service Cloud<br />Platform<br />Marketing Cloud<br />Commerce Cloud<br />Community Cloud",
            "services": "Cloud computing",
            "revenue": "Increase US$|17.1 billion|link|=|yes (2020)",
            "operating_income": "Decrease US$|297 million (2020)",
            "net_income": "Decrease US$|126 million (2020)",
            "assets": "nowrap| |Increase| |US$|55.13 billion| (2020)|ref| name=\"xbrlus_1\" | Increase US$|55.13 billion (2020)",
            "equity": "Increase US$|33.89 billion (2020)",
            "founders": "Marc Benioff<br />Parker Harris<br />Dave Moellenhoff<br />Frank Dominguez",
            "num_employees": "49,000 (2020)",
            "subsid": "Quip (software)|Quip<br />Demandware<br />Heroku<br />MuleSoft<br />Tableau Software",
            "website": "salesforce.com"
        }
    },
    {
        "id": 39,
        "name": "App Inventor for Android (programming language)",
        "url": "https://en.wikipedia.org/wiki/App_Inventor_for_Android",
        "summary": "<p><b>MIT App Inventor</b> is a web application integrated development environment originally provided by Google, and now maintained by the Massachusetts Institute of Technology (MIT). It allows newcomers to computer programming to create application software(apps) for two operating systems (OS): Android, and iOS, which, as of 8 July 2019, is in final beta testing. It is free and open-source software released under dual licensing: a Creative Commons Attribution ShareAlike 3.0 Unported license, and an Apache License 2.0 for the source code. </p><p>It uses a graphical user interface (GUI) very similar to the programming languages Scratch (programming language) and the StarLogo, which allows users to drag and drop visual objects to create an application that can run on android devices, while a App-Inventor Companion (The program that allows the app to run and debug on) that works on iOS running devices are still under development. In creating App Inventor, Google drew upon significant prior research in educational computing, and work done within Google on online development environments.</p><p>App Inventor and the other projects are based on and informed by constructionist learning theories, which emphasize that programming can be a vehicle for engaging powerful ideas through active learning. As such, it is part of an ongoing movement in computers and education that began with the work of Seymour Papert and the MIT Logo Group in the 1960s, and has also manifested itself with Mitchel Resnick's work on Lego Mindstorms and StarLogo.</p><p>App Inventor also supports the use of cloud data via an experimental Firebase#Firebase Realtime Database component.</p>",
        "infobox": {
            "name": "MIT App Inventor",
            "logo": "Mit app inventor.png",
            "screenshot": "App Inventor 2.png",
            "caption": "MIT App Inventor",
            "author": [
                "Hal Abelson",
                "Mark Friedman"
            ],
            "developer": [
                "Google",
                "MIT Media Lab",
                "MIT Computer Science and Artificial Intelligence Laboratory"
            ],
            "released": "2010|12|15",
            "latest release version": "nb180a",
            "latest release date": "2019|11|26",
            "repo": "github.com/mit-cml/appinventor-sources",
            "programming language": [
                "Java (programming language)|Java",
                "Kawa (Scheme implementation)|Kawa",
                "Scheme (programming language)|Scheme"
            ],
            "operating system": "Android (operating system)|Android",
            "language": [
                "English",
                "Spanish",
                "French",
                "Italian",
                "Korean",
                "Dutch",
                "Portuguese",
                "Brazilian Portuguese",
                "Russian",
                "Swedish",
                "Simplified Chinese",
                "Traditional Chinese"
            ],
            "language count": "19",
            "genre": "Application software development Integrated development environment|IDE",
            "license": [
                "Creative Commons license#Attribution|Creative Commons Attribution ShareAlike 3.0 Unported",
                "Apache License 2.0|Apache 2.0"
            ],
            "website": "appinventor.mit.edu"
        }
    },
    {
        "id": 40,
        "name": "AppleScript",
        "url": "https://en.wikipedia.org/wiki/AppleScript",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>AppleScript</b> is a scripting language created by Apple Inc. that facilitates automated control over scriptable Mac applications. First introduced in System 7, it is currently included in all versions of macOS as part of a package of system automation tools. The term \"AppleScript\" may refer to the language itself, to an individual script written in the language, or, informally, to the macOS Open Scripting Architecture that underlies the language.</p>",
        "infobox": {
            "name": "AppleScript",
            "developer": "Apple Inc.",
            "logo": "AppleScript Editor Logo.png",
            "description": "AppleScript Editor running on OS X Yosemite",
            "year": "1993",
            "paradigm": [
                "Natural language programming",
                "Scripting language|Scripting"
            ],
            "typing": [
                "weak typing|Weak",
                "dynamic typing|dynamic"
            ],
            "latest_release_version": "2.5",
            "latest_release_date": "start date and age|2014|10|16",
            "operating_system": [
                "System 7",
                "Mac OS 8",
                "Mac OS 9",
                "macOS"
            ],
            "genre": "Scripting language",
            "license": "Proprietary software|Proprietary (parts available under Apple Public Source License|APSL)",
            "website": "https://developer.apple.com/library/content/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html|https://developer.apple.com/applescript",
            "influenced_by": [
                "Natural language programming|Natural language",
                "HyperTalk"
            ],
            "file_ext": [
                ".scpt",
                ".scptd",
                ".applescript"
            ]
        }
    },
    {
        "id": 41,
        "name": "Arc (programming language)",
        "url": "https://en.wikipedia.org/wiki/Arc_(programming_language)",
        "summary": "<p><b>Arc</b> is a programming language, a dialect of the language Lisp, developed by Paul Graham and Robert Morris. It is free and open-source software released under the Artistic License 2.0. </p>",
        "infobox": {
            "name": "Arc",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Functional programming|functional",
                "Metaprogramming|meta",
                "Procedural programming|procedural"
            ],
            "family": "Lisp (programming language)|Lisp",
            "designer": "Paul Graham (programmer)|Paul Graham",
            "developers": [
                "Paul Graham",
                "Robert Morris,<br />Arc Community of practice|community"
            ],
            "released": "2008|01|29",
            "latest release version": "3.2",
            "latest release date": "2018|10|28",
            "typing": "Dynamic typing|Dynamic",
            "programming language": "Racket (programming language)|Racket",
            "platform": [
                "IA-32",
                "x86-64"
            ],
            "operating system": "Linux",
            "license": "Artistic License 2.0",
            "file ext": ".arc",
            "website": "arclanguage.org",
            "implementations": [
                "Arc",
                "Anarki",
                "Arcadia",
                "Rainbow"
            ],
            "influenced by": [
                "Lisp (programming language)|Lisp",
                "Scheme (programming language)|Scheme"
            ]
        }
    },
    {
        "id": 42,
        "name": "Argus (programming language)",
        "url": "https://en.wikipedia.org/wiki/Argus_(programming_language)",
        "summary": "<p><b>Argus</b> is a programming language created at MIT by Barbara Liskov between 1982 and 1988, in collaboration with Maurice Herlihy, Paul Johnson, Robert Scheifler, and William Weihl.  It is an extension of the CLU language, and utilizes most of the same syntax and semantics.  Argus was designed to support the creation of distributed programs, by encapsulating related procedures within objects called <i>guardians</i>, and by supporting atomic operations called <i>actions</i>.</p>",
        "infobox": "N/A"
    },
    {
        "id": 43,
        "name": "Assembly language",
        "url": "https://en.wikipedia.org/wiki/Assembly_language",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p>In computer programming,  <b>assembly language</b> (or <b>assembler language</b>), often abbreviated <b>asm</b>, is any low-level programming language in which there is a very strong correspondence between the instructions in the language and the architecture's machine code instructions. Because assembly depends on the machine code instructions, every assembler has its own assembly language which is designed for exactly one specific computer architecture. Assembly language may also be called <i>symbolic machine code</i>.</p><p>Assembly code is converted into executable machine code by a utility program referred to as an <i>assembler</i>. The conversion process is referred to as <i>assembly</i>, as in <i>assembling</i> the source code. Assembly language usually has one statement per machine instruction (1:1), but comments and statements that are assembler directives, macros, and symbolic labels of program and memory locations are often also supported.\n</p><p>The term \"assembler\" is generally attributed to Wilkes, Wheeler and Gill in their 1951 book <i>The preparation of programs for an electronic digital computer</i>, who, however, used the term to mean \"a program that assembles another program consisting of several sections into a single program\".</p><p>Each assembly language is specific to a particular computer architecture and sometimes to an operating system. However, some assembly languages do not provide specific syntax for operating system calls, and most assembly languages can be used universally with any operating system, as the language provides access to all the real capabilities of the processor, upon which all system call mechanisms ultimately rest. In contrast to assembly languages, most high-level programming languages are generally portable across multiple architectures but require interpreting or compiling, a much more complicated task than assembling.\n</p><p>The computational step when an assembler is processing a program is called <i>assembly time</i>.\n</p>",
        "infobox": {
            "screenshot": "File:Motorola 6800 Assembly Language.png",
            "screenshot caption": "Typical ''secondary output'' from an assembler&mdash;showing original assembly language (right) for the Motorola MC6800 and the assembled form",
            "paradigm": [
                "Imperative programming|Imperative",
                "Unstructured programming|unstructured"
            ],
            "released": "start date and age|1949"
        }
    },
    {
        "id": 44,
        "name": "AutoHotkey",
        "url": "https://en.wikipedia.org/wiki/AutoHotkey",
        "summary": "<p><b>AutoHotkey</b> is a free, open-source custom scripting language for Microsoft Windows, initially aimed at providing easy keyboard shortcuts or hotkeys, fast macro-creation and software automation that allows users of most levels of computer skill to automate repetitive tasks in any Windows application. User interfaces can easily be extended or modified by AutoHotkey (for example, overriding the default Windows control key commands with their Emacs equivalents). The AutoHotkey installation includes its own extensive help file, and web-based documentation is also available.</p>",
        "infobox": {
            "name": "AutoHotkey",
            "logo": "AutoHotkey logo.png",
            "developer": [
                "Chris Mallett",
                "Steve Gray"
            ],
            "released": "2003|11|10 (Chris Mallet) <br/> 2008|7|18 (Steve Gray)",
            "latest_release_version": "1.1.33.00",
            "latest_release_date": "release date and age|2020|06|30",
            "latest preview version": "2.0-a115",
            "latest preview date": "2020|07|06",
            "operating_system": "Microsoft Windows",
            "genre": "Scripting language Automation Graphical user interface|GUI Utility software|utility",
            "license": "GNU General Public License|GPL",
            "website": "autohotkey.com"
        }
    },
    {
        "id": 45,
        "name": "AutoIt",
        "url": "https://en.wikipedia.org/wiki/AutoIt",
        "summary": "<p><b>AutoIt</b> <span></span> is a freeware programming language for Microsoft Windows. In its earliest release, it was primarily intended to create automation scripts (sometimes called macros) for Microsoft Windows programs but has since grown to include enhancements in both programming language design and overall functionality. </p><p>The scripting language in AutoIt 1 and 2 was statement-driven and designed primarily for simulating user interaction. From version 3 onward, the AutoIt syntax is similar to that found in the BASIC family of languages. In this form, AutoIt is a general-purpose, third-generation programming language with a classical data model and a variant data type that can store several types of data, including arrays.\n</p><p>An AutoIt automation script can be converted into a compressed, stand-alone executable which can be run on computers even if they do not have the AutoIt interpreter installed. A wide range of function libraries (known as UDFs, or \"User Defined Functions\") are also included as standard or are available from the website to add specialized functionality. AutoIt is also distributed with an IDE based on the free SciTE editor. The compiler and help text are fully integrated and provide a <i>de facto</i> standard environment for developers using AutoIt.\n</p>",
        "infobox": {
            "name": "AutoIt",
            "logo": "Autoitlogo.png",
            "screenshot": "File:AutoIT example script.png",
            "caption": "An AutoIt script loaded into SciTE",
            "designer": "Jonathan Bennett",
            "developer": "AutoIt Consulting Ltd.",
            "paradigm": [
                "object-oriented programming|Object-oriented",
                "imperative programming|imperative",
                "functional programming|functional",
                "procedural programming|procedural",
                "reflective programming|reflective"
            ],
            "released": "Release date and age|1999|01",
            "latest_release_version": "3.3.14.5",
            "latest_release_date": "Release date and age|2018|03|16",
            "latest_preview_version": "3.3.15.3 Beta release|Beta",
            "latest_preview_date": "Release date and age|2020|05|16",
            "influenced by": "BASIC",
            "platform": "IA-32 and x64",
            "operating_system": "Windows XP SP3 and later<br/>Windows Server 2003 and later",
            "license": "Freeware",
            "File extensions": ".au3"
        }
    },
    {
        "id": 46,
        "name": "AutoLISP",
        "url": "https://en.wikipedia.org/wiki/AutoLISP",
        "summary": "<p><b>AutoLISP</b> is a dialect of the programming language Lisp built specifically for use with the full version of AutoCAD and its derivatives, which include <i>AutoCAD Map 3D</i>, <i>AutoCAD Architecture</i> and <i>AutoCAD Mechanical</i>. Neither the application programming interface (API) nor the interpreter to execute AutoLISP code are included in the AutoCAD LT product line.</p>",
        "infobox": {
            "name": "AutoLISP",
            "family": "Lisp (programming language)|Lisp",
            "designer": "David Betz",
            "developers": [
                "Autodesk",
                "Basis Software"
            ],
            "released": "1986|01",
            "latest release version": "13",
            "latest release date": "1995|02",
            "platform": "IA-32",
            "operating system": "Linux",
            "dialects": [
                "Vital-LISP",
                "Visual LISP"
            ],
            "influenced by": [
                "Lisp (programming language)|Lisp",
                "XLISP"
            ]
        }
    },
    {
        "id": 47,
        "name": "Autodesk 3ds Max",
        "url": "https://en.wikipedia.org/wiki/Autodesk_3ds_Max",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Autodesk 3ds Max</b>, formerly <b>3D Studio</b> and <b>3D Studio Max</b>, is a professional 3D computer graphics program for making 3D animations, models, games and images. It is developed and produced by Autodesk Media and Entertainment. It has modeling capabilities and a flexible plugin architecture and must be used on the Microsoft Windows platform. It is frequently used by video game developers, many TV commercial studios, and architectural visualization studios. It is also used for movie effects and movie pre-visualization. For its modeling and animation tools, the latest version of 3ds Max also features shaders (such as ambient occlusion and subsurface scattering), dynamic simulation, particle systems, radiosity, normal map creation and rendering, global illumination, a customizable user interface, new icons, and its own scripting language.</p>\n\n\n",
        "infobox": {
            "name": "Autodesk 3ds Max",
            "logo": "File:Logo for 3ds Max.png|250x200px",
            "developer": [
                "Autodesk",
                "Inc."
            ],
            "released": "start date and age|1996|4",
            "latest release version": "2021",
            "latest release date": "2020|03|25",
            "operating system": "Windows 7 or later",
            "platform": "x86-64",
            "language": [
                "English",
                "German",
                "French",
                "Brazilian Portuguese",
                "Japanese",
                "Chinese",
                "Korean"
            ],
            "genre": "3D computer graphics",
            "license": [
                "Software as a service",
                "Trialware"
            ],
            "website": "url|https://www.autodesk.com/products/3ds-max/overview"
        }
    },
    {
        "id": 48,
        "name": "Averest",
        "url": "https://en.wikipedia.org/wiki/Averest",
        "summary": "<p><b>Averest</b> is a synchronous programming language and set of tools to specify, verify, and implement reactive systems. It includes a compiler for synchronous programs, a symbolic model checker, and a tool for hardware/software synthesis. </p><p>It can be used to model and verify finite and infinite state systems, at varied abstraction levels. It is useful for hardware design, modeling communication protocols, concurrent programs, software in embedded systems, and more.\n</p><p>Components: compiler to translate synchronous programs to transition systems, symbolic model checker, tool for hardware/software synthesis. These cover large parts of the design flow of reactive systems, from specifying to implementing. Though the tools are part of a common framework, they are mostly independent of each other, and can be used with 3rd-party tools.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 49,
        "name": "Axum (programming language)",
        "url": "https://en.wikipedia.org/wiki/Axum_(programming_language)",
        "summary": "<p><b>Axum</b> (previously codenamed <b>Maestro</b>) is a domain-specific concurrent programming language, based on the Actor model, that was under active development by Microsoft between 2009 and 2011. It is an object-oriented language based on the .NET Common Language Runtime using a C-like syntax which, being a domain-specific language, is intended for development of portions of a software application that is well-suited to concurrency. But it contains enough general-purpose constructs that one need not switch to a general-purpose programming language (like C#) for the sequential parts of the concurrent components.</p><p>The main idiom of programming in Axum is an <i>Agent</i> (or an <i>Actor</i>), which is an isolated entity that executes in parallel with other Agents. In Axum parlance, this is referred to as the agents executing in separate <i>isolation domains</i>; objects instantiated within a domain cannot be directly accessed from another. Agents are loosely coupled (i.e., the number of dependencies between agents is minimal) and do not share resources like memory (unlike the shared memory model of C# and similar languages); instead a message passing model is used. To co-ordinate agents or having an agent request the resources of another, an explicit message must be sent to the agent. Axum provides <i>Channels</i> to facilitate this. </p><p><i>Channels</i> can be regarded as a directional pathway to communicate between agent instances. The member functions of a <i>Channel</i> object, after it has been bound to an agent instance, can be used to communicate with it. A <i>Channel</i> contains input and output <i>ports</i>, which are queues which are used to send data to an agent or receive data from one. To co-ordinate the communication between agents, Axum allows each channel to have a user-defined <i>protocol</i> for communication. The protocol is defined as a state machine. The data sent over a channel can be optionally restricted to conform to a certain pre-defined <i>schema</i>. The compiler and runtime will enforce the conformance with the schema. Under the hood, a <i>schema</i> is translated into a serializable .NET class that contains only properties and side effect-free methods.</p><p>The Axum project reached the state of a prototype with working Microsoft Visual Studio integration. Microsoft had made a CTP of Axum available to the public, but this has since been removed.\nAlthough Microsoft decided not to turn Axum into a project, some of the ideas behind Axum are used in TPL Dataflow in .Net 4.5.\n</p>",
        "infobox": {
            "name": "Axum",
            "logo": "File:Axum Banner.png|150px",
            "developer": "Microsoft",
            "released": [
                "May 8",
                "2009"
            ],
            "latest_release_version": "Community Technology Preview",
            "latest_release_date": "Release date|2009|05|08",
            "operating_system": "Windows XP<br />Windows Server 2003<br />Windows Vista<br />Windows Server 2008<br />Windows 7",
            "platform": [
                "x86",
                "x86-64 and Itanium"
            ],
            "license": "Closed source",
            "website": "[http://msdn.microsoft.com/en-us/devlabs/dd795202.aspx Axum at DevLabs]"
        }
    },
    {
        "id": 50,
        "name": "BASIC",
        "url": "https://en.wikipedia.org/wiki/BASIC",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>BASIC</b> (<b>Beginners' All-purpose Symbolic Instruction Code</b>) is a family of general-purpose, high-level programming languages whose design philosophy emphasizes ease of use. The original version was designed by John G. Kemeny and Thomas E. Kurtz and released at Dartmouth College in 1964. They wanted to enable students in fields other than science and mathematics to use computers. At the time, nearly all use of computers required writing custom software, which was something only scientists and mathematicians tended to learn.\n</p><p>In addition to the language itself, Kemeny and Kurtz developed the Dartmouth Time Sharing System (DTSS), which allowed multiple users to edit and run BASIC programs at the same time. This general model became very popular on minicomputer systems like the PDP-11 and Data General Nova in the late 1960s and early 1970s. Hewlett-Packard produced an entire computer line for this method of operation, introducing the HP2000 series in the late 1960s and continuing sales into the 1980s. Many early video games trace their history to one of these versions of BASIC.\n</p><p>The emergence of early microcomputers in the mid-1970s led to the development of a number of BASIC dialects, including Microsoft BASIC in 1975. Due to the tiny main memory available on these machines, often 4 kB, a variety of Tiny BASIC dialects was also created. BASIC was available for almost any system of the era, and naturally became the <i>de facto</i> programming language for the home computer systems that emerged in the late 1970s. These machines almost always had a BASIC interpreter installed by default, often in the machine's firmware or sometimes on a ROM cartridge.\n</p><p>BASIC fell from use during the later 1980s as newer machines with far greater capabilities came to market and other programming languages (such as Pascal and C) became tenable. In 1991, Microsoft released Visual Basic, combining a greatly updated version of BASIC with a visual forms builder. This reignited use of the language and \"VB\" remains a major programming language in the form of VB.NET.\n</p>",
        "infobox": {
            "screenshot": "AtariBasic.png",
            "screenshot caption": "Atari BASIC (1979) for the Atari 8-bit family",
            "paradigm": [
                "Non-structured programming|Non-structured",
                "later Procedural programming|procedural",
                "later Object-oriented programming|object-oriented"
            ],
            "designers": "plainlist|\n* John G. Kemeny\n* Thomas E. Kurtz",
            "released": "1964|5|1",
            "implementations": "flatlist|\n* Dartmouth BASIC\n* Tiny BASIC\n* Applesoft BASIC\n* Atari BASIC\n* Sinclair BASIC\n* Commodore BASIC\n* BBC BASIC\n* TI-BASIC\n* Casio BASIC\n* Microsoft BASIC\n* QB64\n* Liberty BASIC\n* PowerBASIC\n* QBASIC",
            "influenced by": "flatlist|\n* ALGOL 60\n* Fortran|FORTRAN II\n* JOSS",
            "influenced": "flatlist|\n* COMAL\n* Visual Basic\n* Visual Basic .NET\n* GRASS (programming language)|GRASS",
            "wikibooks": "BASIC Programming"
        }
    },
    {
        "id": 51,
        "name": "BCPL",
        "url": "https://en.wikipedia.org/wiki/BCPL",
        "summary": "<p><b>BCPL</b> (\"<b>Basic Combined Programming Language</b>\") is a procedural, imperative, and structured programming language.  Originally intended for writing compilers for other languages, BCPL is no longer in common use. However, its influence is still felt because a stripped down and syntactically changed version of BCPL, called B, was the language on which the C programming language was based.  BCPL introduced several features of many modern programming languages, including using curly braces to delimit code blocks. BCPL was first implemented by Martin Richards of the University of Cambridge in 1967.</p>",
        "infobox": {
            "name": "BCPL",
            "paradigm": [
                "procedural programming|procedural",
                "imperative programming|imperative",
                "structured programming|structured"
            ],
            "year": "start date and age|1967",
            "designer": "Martin Richards (computer scientist)|Martin Richards",
            "typing": "typeless (everything is a Word (computer architecture)|word)",
            "influenced_by": "CPL (programming language)|CPL",
            "influenced": [
                "B (programming language)|B",
                "C (programming language)|C",
                "Go (programming language)|Go"
            ]
        }
    },
    {
        "id": 52,
        "name": "BETA (programming language)",
        "url": "https://en.wikipedia.org/wiki/BETA_(programming_language)",
        "summary": "<p><b>BETA</b> is a pure object-oriented language originating within the \"Scandinavian School\" in object-orientation where the first object-oriented language Simula was developed. Among its notable features, it introduced nested classes, and unified classes with procedures into so called patterns. </p>",
        "infobox": {
            "name": "BETA",
            "paradigm": "Object-oriented programming|Object-oriented",
            "designer": [
                "Bent Bruun Kristensen",
                "Ole Lehrmann Madsen",
                "Birger Møller-Pedersen",
                "Kristen Nygaard"
            ],
            "influenced_by": "Simula",
            "website": "beta.cs.au.dk"
        }
    },
    {
        "id": 53,
        "name": "BLISS (programming language)",
        "url": "https://en.wikipedia.org/wiki/BLISS",
        "summary": "<p><b>BLISS</b> is a system programming language developed at Carnegie Mellon University by W. A. Wulf, D. B. Russell, and A. N. Habermann around 1970. It was perhaps the best known systems programming language right up until C made its debut a few years later. Since then, C took off and BLISS faded into obscurity. When C was in its infancy, a few projects within Bell Labs were debating the merits of BLISS vs. C. </p><p>BLISS is a typeless block-structured language based on expressions rather than statements, and includes constructs for exception handling, coroutines, and macros. It does not include a goto statement.\n</p><p>The name is variously said to be short for \"Basic Language for Implementation of System Software\" or \"System Software Implementation Language, Backwards\". It was sometimes called \"Bill's Language for Implementing System Software\", after Bill Wulf.\n</p><p>The original Carnegie Mellon compiler was notable for its extensive use of optimizations, and formed the basis of the classic book <i>The Design of an Optimizing Compiler</i>.\n</p><p>DEC developed and maintained BLISS compilers for the PDP-10, PDP-11, VAX, DEC Prism, MIPS, DEC Alpha, and Intel IA-32, The language did not become popular among customers and few had the compiler, but DEC used it heavily in-house into the 1980s; most of the utility programs for the VMS operating system were written in BLISS-32. After its acquisition of DEC, Compaq developed and maintained a BLISS compiler for Intel IA-64.</p>",
        "infobox": {
            "name": "BLISS",
            "paradigm": [
                "structured programming|Structured",
                "Imperative programming|imperative (procedural programming|procedural)"
            ],
            "year": "1970",
            "designer": [
                "W. A. Wulf",
                "D. B. Russell",
                "A. N. Habermann"
            ],
            "developer": "Carnegie Mellon University",
            "latest_release_version": "BLISS-64",
            "typing": "Typeless",
            "dialects": "Common BLISS",
            "influenced_by": "ALGOL",
            "operating_system": [
                "Cross-platform: PDP-10",
                "PDP-11",
                "VAX",
                "DEC PRISM",
                "MIPS architecture|MIPS",
                "DEC Alpha",
                "IA-32|Intel IA-32",
                "IA-64|Intel IA-64"
            ]
        }
    },
    {
        "id": 54,
        "name": "B (programming language)",
        "url": "https://en.wikipedia.org/wiki/B_(programming_language)",
        "summary": "<p><b>B</b> is a programming language developed at Bell Labs circa 1969.  It is the work of Ken Thompson with Dennis Ritchie. </p><p>B was derived from BCPL, and its name may be a contraction of BCPL.  Thompson's coworker Dennis Ritchie speculated that the name might be based on Bon, an earlier, but unrelated, programming language that Thompson designed for use on Multics.</p><p>B was designed for recursive, non-numeric, machine-independent applications, such as system and language software. It was a typeless language, with the only data type being the underlying machine's natural memory word format, whatever that might be. Depending on the context, the word was treated either as an integer or a memory address.\n</p><p>As machines with ASCII processing became common, notably the DEC PDP-11 that arrived at Bell, support for character data stuffed in memory words became important. The typeless nature of the language was seen as a disadvantage, which led Thompson and Ritchie to develop an expanded version of the language supporting new internal and user-defined types, which became the C programming language.\n</p>",
        "infobox": {
            "name": "B",
            "year": "start date and age|1969",
            "designer": "Ken Thompson (computer programmer)|Ken Thompson",
            "developer": [
                "Ken Thompson (computer programmer)|Ken Thompson",
                "Dennis Ritchie"
            ],
            "turing-complete": "yes",
            "typing": "typeless (everything is a Word (computer architecture)|word)",
            "influenced_by": [
                "BCPL",
                "PL/I",
                "TMG (language)|TMG"
            ],
            "influenced": "C (programming language)|C",
            "file_ext": ".b"
        }
    },
    {
        "id": 55,
        "name": "Babbage (programming language)",
        "url": "https://en.wikipedia.org/wiki/Babbage_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Babbage</b> is the high level assembly language for the GEC 4000 series minicomputers. It was named after Charles Babbage, an English computing pioneer.\n</p>",
        "infobox": {
            "name": "Babbage",
            "paradigm": [
                "procedural programming|procedural",
                "structured programming|structured",
                "High-level assembler"
            ],
            "year": "around 1971",
            "latest_release_version": "308",
            "influenced_by": "BCPL",
            "operating_system": [
                "COS",
                "GEC DOS",
                "OS4000"
            ]
        }
    },
    {
        "id": 56,
        "name": "Ballerina (programming language)",
        "url": "https://en.wikipedia.org/wiki/Ballerina_(programming_language)",
        "summary": "<p><b>Ballerina</b> is a general-purpose programming language with features optimized for distributed computing applications. It is easy to write and modify and is suitable for application programmers.</p><p>It is an open source project  started in 2015 by architects from WSO2 as code-based alternative to the configuration-based integration tools such as EAI, ESB, and workflow products.</p><p>Ballerina has various constructs geared toward cloud-native development including support for modern data formats and protocols, reliability, distributed transactions, APIs, and event streams.</p>",
        "infobox": {
            "name": "Ballerina",
            "logo": "Official_Ballerina_Programming_Language_Logo.png",
            "logo_size": "200px",
            "logo_alt": "Ballerina Language",
            "released": "2017",
            "designer": [
                "Sanjiva Weerawarana",
                "James_Clark_(programmer)|James Clark",
                "Sameera Jayasoma",
                "Hasitha Aravinda",
                "Srinath Perera",
                "Frank Leymann and WSO2"
            ],
            "developer": "WSO2",
            "typing": [
                "structural typing|Structural",
                "strong typing|strong",
                "static typing|static",
                "type inference|inferred"
            ],
            "influenced_by": [
                "Java (programming language)|Java",
                "Javascript (programming language)|Javascript",
                "Go (programming language)|Go",
                "Rust (programming language)|Rust",
                "C_Sharp_(programming_language)|C# "
            ],
            "operating_system": "Cross-platform",
            "license": "Apache License 2.0",
            "website": "http://ballerina.io/"
        }
    },
    {
        "id": 57,
        "name": "Bash (Unix shell)",
        "url": "https://en.wikipedia.org/wiki/Bash_(Unix_shell)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>GNU Bash</b> or simply <b>Bash</b> is a Unix shell and command language written by Brian Fox for the GNU Project as a free software replacement for the Bourne shell. First released in 1989, it has been used as the default login shell for most Linux distributions and all releases of Apple's macOS prior to macOS Catalina. A version is also available for Windows 10. It is also the default user shell in Solaris 11.</p><p>Bash is a command processor that typically runs in a text window where the user types commands that cause actions. Bash can also read and execute commands from a file, called a shell script. Like all Unix shells, it supports filename globbing (wildcard matching), piping, here documents, command substitution, variables, and control structures for condition-testing and iteration. The keywords, syntax, dynamically scoped variables and other basic features of the language are all copied from sh. Other features, e.g., history, are copied from csh and ksh. Bash is a POSIX-compliant shell, but with a number of extensions.\n</p><p>The shell's name is an acronym for <i>Bourne-again shell</i>, a pun on the name of the Bourne shell that it replaces and the notion of being \"born again\".</p><p>A security hole in Bash dating from version 1.03 (August 1989), dubbed Shellshock, was discovered in early September 2014 and quickly led to a range of attacks across the Internet. Patches to fix the bugs were made available soon after the bugs were identified.\n</p>\n\n\n",
        "infobox": {
            "name": "Bash",
            "logo": "Gnu-bash-logo.svg",
            "screenshot": "Bash screenshot.png",
            "caption": "Screenshot of a Bash session",
            "author": "Brian Fox (computer programmer)|Brian Fox",
            "released": "start date and age|1989|06|08",
            "programming language": "C (programming language)|C",
            "operating system": [
                "Plainlist|\n* Unix-like,|ref|cite web|url=ftp://ftp.cwru.edu/pub/bash/FAQ|archive-url=https://web.archive.org/web/20180901171316/ftp://ftp.cwru.edu/pub/bash/FAQ|archive-date=September 1",
                "2018|url-status=dead|title=Bash FAQ",
                "version 4.14|access-date=April 9",
                "2016|df=mdy-all|</ref>|\n* macOS (only latest GNU GPL#Version 2|GPLv2 release; GPLv3 releases available through third parties\n* Windows (newer GNU GPL#Version 3|GPLv3+ version)|ref|cite web|url=https://github.com/Microsoft/BashOnWindows/issues/107|title=Missing source code - GPL compliance? · Issue #107 · Microsoft/WSL|website=GitHub|</ref>|ref|cite web|title=GNU Bash|url=http://www.softpedia.com/get/System/System-Miscellaneous/GNU-Bash.shtml|website=Softpedia|publisher=SoftNews|accessdate=9 April 2016|</ref>| * macOS (only latest GNU GPL#Version 2|GPLv2 release; GPLv3 releases available through third parties\n* Windows (newer GNU GPL#Version 3|GPLv3+ version)"
            ],
            "platform": "GNU",
            "language": "Multilingual (gettext)",
            "genre": [
                "Unix shell",
                "command language"
            ],
            "license": "GNU GPL#Version 3|GPLv3+",
            "website": "https://www.gnu.org/software/bash/"
        }
    },
    {
        "id": 58,
        "name": "Batch file",
        "url": "https://en.wikipedia.org/wiki/Batch_file",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p>A <b>batch file</b> is a script file in DOS, OS/2 and Microsoft Windows. It consists of a series of commands to be executed by the command-line interpreter, stored in a plain text file. A batch file may contain any command the interpreter accepts interactively and use constructs that enable conditional branching and looping within the batch file, such as <code>IF</code>, <code>FOR</code>, and <code>GOTO</code> labels. The term \"batch\" is from batch processing, meaning \"non-interactive execution\", though a batch file may not process a <i>batch</i> of multiple data.\n</p><p>Similar to Job Control Language (JCL), DCL and other systems on mainframe and minicomputer systems, batch files were added to ease the work required for certain regular tasks by allowing the user to set up a script to automate them. When a batch file is run, the shell program (usually COMMAND.COM or cmd.exe) reads the file and executes its commands, normally line-by-line. Unix-like operating systems, such as Linux, have a similar, but more flexible, type of file called a shell script.</p><p>The filename extension <b>.bat</b> is used in DOS and Windows. Windows NT and OS/2 also added <b>.cmd</b>. Batch files for other environments may have different extensions, e.g., <b>.btm</b> in 4DOS, 4OS2 and 4NT related shells.\n</p><p>The detailed handling of batch files has changed significantly between versions. Some of the detail in this article applies to all batch files, while other details apply only to certain versions.\n</p>\n\n\n",
        "infobox": {
            "name": "Batch file",
            "extensions": [
                "<code>.bat</code>",
                "<code>.cmd</code>",
                "<code>.btm</code>"
            ],
            "_noextcode": "yes",
            "icon": "Batch file icon.png",
            "mime": "plainlist|\n* <code>application/bat</code>\n* <code>application/x-bat</code>\n* <code>application/x-msdos-program</code>\n* <code>text/plain</code>",
            "_nomimecode": "yes",
            "genre": "Scripting language|Scripting",
            "containerfor": "Scripting language|Scripts"
        }
    },
    {
        "id": 59,
        "name": "Bc (programming language)",
        "url": "https://en.wikipedia.org/wiki/Bc_(programming_language)",
        "summary": "<p><span></span> </p>\n<p><b>bc</b>, for <i>basic calculator</i> (often referred to as <i>bench calculator</i>), is \"<i>an arbitrary-precision calculator language</i>\" with syntax similar to the C programming language. bc is typically used as either a mathematical scripting language or as an interactive mathematical shell.\n</p>",
        "infobox": {
            "name": "bc",
            "developer": [
                "Robert Morris (cryptographer)|Robert Morris and Lorinda Cherry of Bell Labs",
                "Philip A. Nelson"
            ],
            "released": "Release year|df|=|yes|1975",
            "operating system": [
                "Unix",
                "Unix-like operating systems",
                "FreeDOS"
            ],
            "genre": "Command (computing)|Command"
        }
    },
    {
        "id": 60,
        "name": "BeanShell",
        "url": "https://en.wikipedia.org/wiki/BeanShell",
        "summary": "<p><b>BeanShell</b> is a Java-like scripting language, invented by Patrick Niemeyer. It runs in the Java Runtime Environment (JRE) and uses a variation of the Java syntax, in addition to scripting commands and syntax. </p>",
        "infobox": {
            "name": "BeanShell",
            "paradigm": [
                "Object-oriented programming|Object-oriented",
                "scripting language|scripting"
            ],
            "year": "1999",
            "designer": "Java Community Process|JCP",
            "latest_release_version": "1.3.0",
            "latest_release_date": "2003|08",
            "latest_test_version": "2.0b6",
            "latest_test_date": "2016|02|18",
            "typing": [
                "Type system#Combining static and dynamic type checking|Dynamic",
                "Strong and weak typing|strong"
            ],
            "influenced_by": [
                "Java (programming language)|Java",
                "JavaScript",
                "Perl"
            ],
            "platform": "Java virtual machine|JVM",
            "operating_system": "Cross-platform",
            "programming language": "Java (programming language)|Java",
            "license": "Apache License|Apache v2.0,<br />Sun Public License|SPL / GNU Lesser General Public License|LGPL (Versions 2.0b4 and earlier)",
            "website": "http://www.beanshell.org/"
        }
    },
    {
        "id": 61,
        "name": "Bertrand (programming language)",
        "url": "https://en.wikipedia.org/wiki/Bertrand_(programming_language)",
        "summary": "<p><b>Bertrand</b> (named after Bertrand Russell) is a computer programming language for creating constraint programming systems. The language was created by Wm Leler in the mid-1980s as part of his doctoral research. Bertrand has a declarative programming syntax and differentiates itself from other programming languages by use of a technique called augmented term rewriting. </p>",
        "infobox": "N/A"
    },
    {
        "id": 62,
        "name": "Blockly",
        "url": "https://en.wikipedia.org/wiki/Blockly",
        "summary": "<p><b>Blockly</b> is a client-side library for the programming language JavaScript for creating block-based visual programming languages (VPLs) and editors. It is a project of Google and is free and open-source software released under the Apache License 2.0. It typically runs in a web browser, and visually resembles the language Scratch. Blockly is also being implemented for the mobile operating systems Android and iOS, though not all web browser based features are available for these. </p><p>Blockly uses visual blocks that link together to make writing code easier, and can generate code in JavaScript, Lua, Dart, Python, or PHP. It can also be customised to generate code in any textual programming language.</p>",
        "infobox": {
            "name": "Blockly",
            "author": [
                "Neil Fraser",
                "Quynh Neutron",
                "Ellen Spertus",
                "Mark Friedman"
            ],
            "developer": [
                "Google",
                "Massachusetts Institute of Technology|MIT"
            ],
            "released": "2012|05",
            "latest release version": "1.20190215.0",
            "latest release date": "2019|02|15",
            "latest preview version": "1.20190419.0",
            "latest preview date": "2019|04|19",
            "repo": "github.com/google/blockly",
            "programming language": "JavaScript",
            "operating system": [
                "Android (operating system)|Android",
                "iOS"
            ],
            "platform": "Web browser",
            "size": "150 Kilobyte|KB",
            "language": "English",
            "language count": "50",
            "genre": "Library (computing)|Library",
            "license": "Apache License 2.0|Apache 2.0",
            "website": "developers.google.com/blockly"
        }
    },
    {
        "id": 63,
        "name": "BlooP and FlooP",
        "url": "https://en.wikipedia.org/wiki/BlooP_and_FlooP",
        "summary": "<p><abbr title=\"Bounded loop\"><b>BlooP</b></abbr> and <abbr title=\"Free loop\"><b>FlooP</b></abbr> are simple programming languages designed by Douglas Hofstadter to illustrate a point in his book <i>Gödel, Escher, Bach</i>. BlooP is a non-Turing-complete programming language whose main control flow structure is a bounded loop (i.e. recursion is not permitted). All programs in the language must terminate, and this language can only express primitive recursive functions.</p><p>FlooP is identical to BlooP except that it supports unbounded loops; it is a Turing-complete language and can express all computable functions. For example, it can express the Ackermann function, which (not being primitive recursive) cannot be written in BlooP. Borrowing from standard terminology in mathematical logic, Hofstadter calls FlooP's unbounded loops MU-loops. Like all Turing-complete programming languages, FlooP suffers from the halting problem: programs might not terminate, and it is not possible, in general, to decide which programs do. </p><p>BlooP and FlooP can be regarded as models of computation, and have sometimes been used in teaching computability.</p>",
        "infobox": "N/A"
    },
    {
        "id": 64,
        "name": "Boo (programming language)",
        "url": "https://en.wikipedia.org/wiki/Boo_(programming_language)",
        "summary": "<p><b>Boo</b> is an object-oriented, statically typed, general-purpose programming language that seeks to make use of the Common Language Infrastructure's support for Unicode, internationalization, and web applications, while using a Python-inspired syntax and a special focus on language and compiler extensibility. Some features of note include type inference, generators, multimethods, optional duck typing, macros, true closures, currying, and first-class functions. </p><p>Boo was one of the three scripting languages for the Unity game engine (Unity Technologies employed De Oliveira), until it was dropped in 2014 due to the small userbase. Despite official support for Boo ending, the language could still be used in Unity, until the Boo compiler was removed from the engine in 2017. </p><p>Boo is free software released under the BSD 3-Clause license. It is compatible with the Microsoft .NET and Mono frameworks.\n</p>",
        "infobox": {
            "name": "Boo",
            "logo": "File:BooLogo.png",
            "paradigm": "Object-oriented analysis and design|Object oriented",
            "year": "2003",
            "designer": "Rodrigo B. De Oliveira",
            "developer": "Rodrigo B. De Oliveira",
            "latest_release_version": "0.9.7",
            "latest_release_date": "2013|03|25|df|=|y",
            "typing": [
                "static typing|static",
                "strong typing|strong",
                "Type inference|inferred",
                "duck typing|duck"
            ],
            "influenced_by": [
                "C Sharp (programming language)|C#",
                "Python (programming language)|Python"
            ],
            "influenced": [
                "Genie (programming language)|Genie",
                "Vala (programming language)|Vala"
            ],
            "programming_language": "C Sharp (programming language)|C#",
            "platform": "Common Language Infrastructure (.NET Framework & Mono (software)|Mono)/",
            "license": "BSD licenses|BSD 3-Clause",
            "website": [
                "https://github.com/boo-lang ",
                "http://boo-lang.org"
            ]
        }
    },
    {
        "id": 65,
        "name": "Boomerang (programming language)",
        "url": "https://en.wikipedia.org/wiki/Boomerang_(programming_language)",
        "summary": "<p><b>Boomerang</b> is a programming language for writing lenses—well-behaved bidirectional transformations —that operate on ad-hoc, textual data formats. </p><p>Boomerang grew out of the Harmony generic data synchronizer, which grew out of the Unison file synchronization project.\n</p>",
        "infobox": {
            "name": "Boomerang",
            "year": "2008",
            "developer": [
                "Nate Foster",
                "Benjamin C. Pierce",
                "and Michael Greenberg88"
            ],
            "latest_release_version": "0.2",
            "latest_release_date": "2009|09|02",
            "influenced by": "OCaml",
            "influenced": "XSLT",
            "operating_system": [
                "Linux",
                "Mac OS X"
            ],
            "website": "http://www.seas.upenn.edu/~harmony/"
        }
    },
    {
        "id": 66,
        "name": "Bosque (programming language)",
        "url": "https://en.wikipedia.org/wiki/Bosque_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Bosque</b> is a free and open-source programming language developed by Microsoft that was inspired by the syntax and types of TypeScript and the semantics of ML and Node/JavaScript. Design goals for the language include better software quality and improved developer productivity.</p>",
        "infobox": {
            "name": "Bosque (programming language)",
            "title": "Bosque",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: Functional programming|functional",
                "typed language"
            ],
            "released": "2019|3|3",
            "designer": "Mark Marron",
            "developer": "Microsoft",
            "license": "MIT License",
            "file ext": ".bsq",
            "website": "https://www.microsoft.com/en-us/research/project/bosque-programming-language/",
            "influenced_by": [
                "JavaScript",
                "TypeScript",
                "ML (programming language)|ML"
            ]
        }
    },
    {
        "id": 67,
        "name": "C*",
        "url": "https://en.wikipedia.org/wiki/C*",
        "summary": "<p><b>C*</b> (or C-star) is an object-oriented, data-parallel superset of ANSI C with synchronous semantics. </p>",
        "infobox": {
            "name": "C*",
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Object-oriented programming|object-oriented",
                "Imperative programming|imperative",
                "parallel programming|parallel"
            ],
            "year": "1987",
            "designer": "Thinking Machines Corporation|Thinking Machines",
            "developer": "Thinking Machines",
            "latest_release_version": "6.x ( release date|mf|=|yes|1993|8|27 )",
            "typing": [
                "Type system|static",
                "Weak typing|weak",
                "manifest typing|manifest"
            ],
            "influenced_by": [
                "ANSI C",
                "*Lisp"
            ],
            "influenced": "Dataparallel-C",
            "operating_system": "Connection Machine",
            "file_ext": ".cs"
        }
    },
    {
        "id": 68,
        "name": "C++",
        "url": "https://en.wikipedia.org/wiki/C%2B%2B",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p class=\"mw-empty-elt\">\n</p>\n<p><b>C++</b> (<span></span>) is a general-purpose programming language created by Bjarne Stroustrup as an extension of the C programming language, or \"C with Classes\". The language has expanded significantly over time, and modern C++ now has object-oriented, generic, and functional features in addition to facilities for low-level memory manipulation. It is almost always implemented as a compiled language, and many vendors provide C++ compilers, including the Free Software Foundation, LLVM, Microsoft, Intel, Oracle, and IBM, so it is available on many platforms.</p><p>C++ was designed with a bias toward system programming and embedded, resource-constrained software and large systems, with performance, efficiency, and flexibility of use as its design highlights. C++ has also been found useful in many other contexts, with key strengths being software infrastructure and resource-constrained applications, including desktop applications, video games, servers (e.g. e-commerce, Web search, or SQL servers), and performance-critical applications (e.g. telephone switches or space probes).</p><p>C++ is standardized by the International Organization for Standardization (ISO), with the latest standard version ratified and published by ISO in December 2017 as <i>ISO/IEC 14882:2017</i> (informally known as C++17). The C++ programming language was initially standardized in 1998 as <i>ISO/IEC 14882:1998</i>, which was then amended by the C++03, C++11 and C++14 standards. The current C++17 standard supersedes these with new features and an enlarged standard library.  Before the initial standardization in 1998, C++ was developed by Danish computer scientist Bjarne Stroustrup at Bell Labs since 1979 as an extension of the C language; he wanted an efficient and flexible language similar to C that also provided high-level features for program organization. C++20 is the next planned standard, keeping with the current trend of a new version every three years.</p>\n\n\n",
        "infobox": {
            "name": "C++",
            "logo": "File:ISO C++ Logo.svg",
            "logo caption": "The C++ logo endorsed by Standard C++",
            "logo size": "150px",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: procedural programming|procedural",
                "functional programming|functional",
                "object-oriented programming|object-oriented",
                "generic programming|generic"
            ],
            "family": "C (programming language)|C",
            "designer": "Bjarne Stroustrup",
            "developer": "ISO/IEC JTC1 (Joint Technical Committee 1) / SC22 (Subcommittee 22) / WG21 (Working Group 21)",
            "released": "df|=|yes|1985",
            "latest release version": "C++17 Small|(ISO/IEC 14882:2017)",
            "latest release date": "2017|12|01",
            "latest preview version": "C++20",
            "typing": [
                "Static type|Static",
                "Nominal type system|nominative",
                "Type inference|partially inferred"
            ],
            "operating system": "Most major",
            "file ext": [
                ".C",
                ".cc",
                ".cpp",
                ".cxx",
                "nowrap|.c++ ",
                ".h",
                ".hh",
                ".hpp",
                ".hxx",
                "nowrap|.h++"
            ],
            "implementations": [
                "nowraplinks| GNU Compiler Collection|GCC",
                " Clang|LLVM Clang",
                "Microsoft Visual C++",
                "C++Builder|Embarcadero C++Builder",
                "Intel C++ Compiler",
                "IBM XL C++",
                "Edison Design Group|EDG"
            ],
            "influenced by": [
                "Ada (programming language)|Ada",
                "ALGOL 68",
                "C (programming language)|C",
                "CLU (programming language)|CLU",
                "ML (programming language)|ML",
                "Mesa (programming language)|Mesa",
                "Modula-2",
                "Simula",
                "Smalltalk"
            ],
            "influenced": [
                "Ada (programming language)|Ada 95 ",
                "C Sharp (programming language)|C# ",
                "C99 ",
                "Chapel (programming language)|Chapel",
                "Clojure",
                "D (programming language)|D ",
                "Java (programming language)|Java ",
                "JS++",
                "Lua (programming language)|Lua ",
                "Nim (programming language)|Nim",
                "Perl ",
                "PHP ",
                "Python (programming language)|Python",
                "Rust (programming language)|Rust",
                "Seed7"
            ],
            "wikibooks": "C++ Programming"
        }
    },
    {
        "id": 69,
        "name": "C--",
        "url": "https://en.wikipedia.org/wiki/C--",
        "summary": "<p><b>C--</b> (pronounced <i>cee minus minus</i>) is a C-like programming language. Its creators, functional programming researchers Simon Peyton Jones and Norman Ramsey, designed it to be generated mainly by compilers for very high-level languages rather than written by human programmers. Unlike many other intermediate languages, its representation is plain ASCII text, not bytecode or another binary format.</p><p>There are two main branches of C--. One is the original C-- branch, with the final version 2.0 released in May 2005. The other is the Cmm fork actively used by the Glasgow Haskell Compiler as its intermediate representation.</p>",
        "infobox": {
            "name": "C--",
            "paradigm": "imperative programming|imperative",
            "year": "1997",
            "typing": [
                "Type system|static",
                "Weak typing|weak"
            ],
            "designer": "Simon Peyton Jones and Norman Ramsey (computer scientist)|Norman Ramsey",
            "influenced_by": "C (programming language)|C",
            "website": "https://www.cs.tufts.edu/~nr/c--/index.html"
        }
    },
    {
        "id": 70,
        "name": "C/AL",
        "url": "https://en.wikipedia.org/wiki/C/AL",
        "summary": "<p><b>C/AL</b> (<b>C</b>lient<b>/</b>server <b>A</b>pplication <b>L</b>anguage) is the programming language used within C/SIDE the <b>C</b>lient<b>/S</b>erver <b>I</b>ntegrated <b>D</b>evelopment <b>E</b>nvironment in Microsoft Dynamics NAV (Formerly known as Navision Attain). C/AL is a Database specific programming language, and is primarily used for retrieving, inserting and modifying records in a Navision database. C/AL resembles the Pascal language on which it is based. The original C/AL compiler was written by Michael Nielsen.</p>",
        "infobox": "N/A"
    },
    {
        "id": 71,
        "name": "CDuce",
        "url": "https://en.wikipedia.org/wiki/CDuce",
        "summary": "<p><b>CDuce</b> is an XML-oriented functional language, which extends XDuce in a few directions. It features XML regular expression types, XML regular expression patterns,\nXML iterators. CDuce is not strictly speaking an XML transformation language since\nit can be used for general-purpose programming.\n</p><p>CDuce conforms to basic standards: Unicode, XML, DTD, Namespaces are fully supported, XML Schema is partially supported.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 72,
        "name": "CEEMAC",
        "url": "https://en.wikipedia.org/wiki/CEEMAC",
        "summary": "<p><b>CEEMAC</b> is a programming language developed in the 1980s for the Apple II family of computers.  It was authored by Brooke Boering and published by Vagabondo Enterprises,</p><p>CEEMAC was designed to be a visual composition language in which the programmer designed dynamic \"scores\" by programatically controlling color, shape, sound and movement. Additionally, a programmer could then \"perform\" their score through use of the Apple II keyboard or paddle input devices to introduce additional variation.</p><p>CEEMAC syntax loosely resembled a combination of BASIC and Pascal and include control commands such as GOTO, GOSUB, DO, AGAIN, FOR, SKIP, EXIT and loop control structures such as IF/WHILE and TIL/UNLESS. Additionally, 30 predefined macros were included in CEEMAC to aid in score composition.</p><p>The following is a small CEEMAC sample score:</p> <pre>\t\t    SCORE: KT\n      \t\t\t:FIRE ORGAN  KEY T\n      \t\t\tSPEED [0,0]\n      \t\t\t: - BUT 0\n      \t\t\t0\n      \t\t\tCLEAR [0,0]\n      \t\t\tXY1 = $80;$80\n     \t\t\t: MAIN LOOP\n      \t\t\tF\n     \t\t\t:FORGND SYMMETRY 0-3\n      \t\t\tVC = RND3 ORA 3\n      \t\t\t: SAVE FORGND ROTATION\n      \t\t\tVD = ROTEZ\n      \t\t\t:FORGND COLOR\n      \t\t\tCOLOR = NXTCOL</pre>\n<p>CEEMAC was originally marketed through distribution of a free demonstration program entitled Fire Organ.  This program contained several scores created by Boering and other programmers to demonstrate some of the capabilities of the language.</p>",
        "infobox": {
            "name": "CEEMAC",
            "designer": "Brooke Boering",
            "developer": "Vagabondo Enterprises",
            "paradigm": "Visual composition language",
            "platform": "Apple II"
        }
    },
    {
        "id": 73,
        "name": "CFEngine",
        "url": "https://en.wikipedia.org/wiki/CFEngine",
        "summary": "<p><b>CFEngine</b> is an open-source configuration management system, written by Mark Burgess. Its primary function is to provide automated configuration and maintenance of large-scale computer systems, including the unified management of servers, desktops, consumer and industrial devices, embedded networked devices, mobile smartphones, and tablet computers. </p>",
        "infobox": {
            "name": "CFEngine",
            "logo": "CFEngine-logo.svg",
            "logo size": "200px",
            "latest_release_version": [
                "3.16.0 ",
                "3.15.2 ",
                "3.12.5"
            ],
            "latest_release_date": [
                "June 23rd",
                "2020"
            ],
            "released": "1993",
            "operating_system": "Cross-platform",
            "platform": [
                "Unix-like",
                "Windows"
            ],
            "genre": "Configuration management System administration Network management",
            "license": "GNU General Public License#Version 3|GNU General Public License version 3",
            "website": "https://cfengine.com"
        }
    },
    {
        "id": 74,
        "name": "CHILL",
        "url": "https://en.wikipedia.org/wiki/CHILL",
        "summary": "<p>In computing, <b>CHILL</b> (an acronym for <b>CCITT High Level Language</b>) is a procedural programming language designed for use in telecommunication switches (the hardware used inside telephone exchanges). The language is still used for legacy systems in some telecommunication companies and for  signal box programming. </p><p>The CHILL language is similar in size and complexity to the original Ada language. The first specification of the CHILL language was published in 1980, a few years before Ada.\n</p><p>ITU provides a standard CHILL compiler.\nA free CHILL compiler was bundled with GCC up to version 2.95, however, was removed from later versions. An object-oriented version, called Object CHILL, was developed also.</p><p>ITU is responsible for the CHILL standard, known as ITU-T Rec. Z.200. The equivalent ISO standard is ISO/IEC 9496:2003. (The text of the two documents is the same). In late 1999 CCITT stopped maintaining the CHILL standard.\n</p><p>CHILL was used in systems of Alcatel System 12 and Siemens EWSD, for example.\n</p>",
        "infobox": {
            "name": "CHILL",
            "paradigm": "procedural language|procedural",
            "year": "1980",
            "designer": "ITU-T|CCITT",
            "latest release version": "3.0?",
            "latest release date": "2003",
            "typing": [
                "static typing|static",
                "strong typing|strong"
            ],
            "dialects": "Object CHILL",
            "influenced by": [
                "COBOL",
                "PL/1"
            ],
            "operating system": "telecommunication switches"
        }
    },
    {
        "id": 75,
        "name": "CHIP-8",
        "url": "https://en.wikipedia.org/wiki/CHIP-8",
        "summary": "<p><b>CHIP-8</b> is an interpreted programming language, developed by Joseph Weisbecker. It was initially used on the COSMAC VIP and Telmac 1800 8-bit microcomputers in the mid-1970s. CHIP-8 programs are run on a CHIP-8 virtual machine. It was made to allow video games to be more easily programmed for these computers. </p><p>Roughly fifteen years after CHIP-8 was introduced, derived interpreters appeared for some models of graphing calculators (from the late 1980s onward, these handheld devices in many ways have more computing power than most mid-1970s microcomputers for hobbyists).\n</p><p>An active community of users and developers existed in the late 1970s, beginning with ARESCO's \"VIPer\" newsletter whose first three issues revealed the machine code behind the CHIP-8 interpreter.</p>",
        "infobox": "N/A"
    },
    {
        "id": 76,
        "name": "CLIPS (programming language)",
        "url": "https://en.wikipedia.org/wiki/CLIPS",
        "summary": "<p><b>CLIPS</b> is a public domain software tool for building expert systems.  The name is an acronym for \"C Language Integrated Production System.\" The syntax and name was inspired by Charles Forgy's OPS5. The first versions of CLIPS were developed starting in 1985 at NASA-Johnson Space Center (as an alternative for existing system ART*Inference) until the mid-1990s when the development group's responsibilities ceased to focus on expert system technology. The original name of the project was <i>NASA's AI Language</i> (<i>NAIL</i>). </p><p>CLIPS is probably the most widely used expert system tool. CLIPS itself is written in C, extensions can be written in C, and CLIPS can be called from C. Its syntax resembles that of the programming language Lisp.</p><p>CLIPS incorporates a complete object-oriented language for writing expert systems. COOL combines the programming paradigms of procedural, object oriented and logical (theorem proving) languages.</p>",
        "infobox": {
            "name": "CLIPS",
            "paradigm": "expert systems",
            "year": "1985",
            "website": "http://www.clipsrules.net/"
        }
    },
    {
        "id": 77,
        "name": "CLIST",
        "url": "https://en.wikipedia.org/wiki/CLIST",
        "summary": "<p><b>CLIST (Command List)</b> (pronounced \"C-List\") is a procedural programming language for TSO in MVS systems. It originated in OS/360 Release 20 and has assumed a secondary role since the availability of Rexx in TSO/E Version 2. The term CLIST is also used for command lists written by users of NetView.</p><p>In its basic form, a CLIST program (or \"CLIST\" for short) can take the form of a simple list of commands to be executed in strict sequence (like a DOS batch file (*.bat) file).  However, CLIST also features If-Then-Else logic as well as loop constructs. </p><p>CLIST is an interpreted language.  That is, the computer must translate a CLIST every time the program is executed.  CLISTs therefore tend to be slower than programs written in compiled languages such as COBOL, FORTRAN, or PL/1.  (A program written in a compiled language is translated once to create a \"load module\" or executable.)\n</p><p>CLIST can read/write MVS files and read/write from/to a TSO terminal. It can read parameters from the caller and also features a function to hold global variables and pass them between CLISTs. A CLIST can also call an MVS application program (written in COBOL or  PL/I, for example). CLISTs can be run in background (by running JCL which executes the TSO control program (IKJEFT01)). TSO I/O screens and menus using ISPF dialog services can be displayed by CLISTs.\n</p><p>Compare the function of CLIST with that provided by REXX.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 78,
        "name": "CLU (programming language)",
        "url": "https://en.wikipedia.org/wiki/CLU_(programming_language)",
        "summary": "<p><b>CLU</b> is a  programming language created at the Massachusetts Institute of Technology (MIT) by Barbara Liskov and her students between 1974 and 1975. While it did not find extensive use, it introduced many features that are used widely now, and is seen as a step in the development of object-oriented programming (OOP). </p><p>Key contributions include abstract data types, call-by-sharing, iterators, multiple return values (a form of parallel assignment), type-safe parameterized types, and type-safe variant types. It is also notable for its use of classes with constructors and methods, but without inheritance.\n</p>",
        "infobox": {
            "name": "CLU",
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Object-oriented programming|object-oriented",
                "Procedural programming|procedural"
            ],
            "released": "1975",
            "designer": "Barbara Liskov and her students",
            "developer": "Massachusetts Institute of Technology",
            "latest release version": [
                "Native CLU 1.5 (SPARC",
                "VAX) / 1989|05|26 <br />\nPortable CLU / 2009|11|06"
            ],
            "typing": "Strong typing|strong",
            "website": "www.pmg.lcs.mit.edu/CLU.html",
            "implementations": [
                "Native CLU",
                "Portable CLU",
                "clu2c"
            ],
            "influenced by": [
                "ALGOL 60",
                "Lisp (programming language)|Lisp",
                "Simula"
            ],
            "influenced": [
                "Ada (programming language)|Ada",
                "Argus (programming language)|Argus",
                "C++",
                "Lua (programming language)|Lua",
                "Python (programming language)|Python",
                "Ruby (programming language)|Ruby",
                "Sather",
                "Swift (programming language)|Swift"
            ]
        }
    },
    {
        "id": 79,
        "name": "CMS-2 (programming language)",
        "url": "https://en.wikipedia.org/wiki/CMS-2_(programming_language)",
        "summary": "<p><b>CMS-2</b> is an embedded systems programming language used by the United States Navy. It was an early attempt to develop a standardized high-level computer programming language intended to improve code portability and reusability. CMS-2 was developed primarily for the US Navy’s tactical data systems (NTDS).</p><p>CMS-2 was developed by RAND Corporation in the early 1970s and stands for \"Compiler Monitor System\". The name \"CMS-2\" is followed in literature by a letter designating the type of target system. For example, CMS-2M targets Navy 16-bit processors, such as the AN/AYK-14.</p>",
        "infobox": {
            "name": "CMS-2",
            "paradigm": "Imperative programming|Imperative",
            "logo": "CMS-2Y_Programmers_Reference_Manual_for_the_AN_UYK-7_and_AN_UYK-43_Oct86.jpg",
            "logo caption": "CMS-2Y Programmers Reference Manual",
            "year": "1968",
            "designer": [
                "RAND Corporation|RAND",
                "Intermetrics"
            ],
            "developer": "Computer Sciences Corporation",
            "influenced_by": [
                "CS-1 (programming language)|CS-1",
                "Fortran",
                "JOVIAL and PL/I"
            ]
        }
    },
    {
        "id": 80,
        "name": "CMS EXEC",
        "url": "https://en.wikipedia.org/wiki/CMS_EXEC",
        "summary": "<p><b>CMS EXEC</b>, or <b>EXEC</b>, is an interpreted, command procedure control, computer scripting language used by the CMS EXEC Processor supplied with the IBM Virtual Machine/Conversational Monitor System (VM/CMS) operating system. </p><p>EXEC was written in 1966 by Stuart Madnick at MIT on the model of CTSS RUNCOM.  He originally called this processor COMMAND, and it was later renamed EXEC.</p><p>CMS EXEC has been superseded by EXEC 2 and REXX. All three — CMS EXEC, EXEC 2 and REXX — continue to be supported by the IBM CMS product.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 81,
        "name": "COBOL",
        "url": "https://en.wikipedia.org/wiki/COBOL",
        "summary": "<p class=\"mw-empty-elt\"> \n</p><p class=\"mw-empty-elt\">\n</p>\n<p><b>COBOL</b> (<span></span>; an acronym for \"common business-oriented language\") is a compiled English-like computer programming language designed for business use. It is imperative, procedural and, since 2002, object-oriented. COBOL is primarily used in business, finance, and administrative systems for companies and governments. COBOL is still widely used in applications deployed on mainframe computers, such as large-scale batch and transaction processing jobs. But due to its declining popularity and the retirement of experienced COBOL programmers, programs are being migrated to new platforms, rewritten in modern languages or replaced with software packages. Most programming in COBOL is now purely to maintain existing applications, however many large financial institutions were still developing new systems in COBOL in 2006 due to the mainframe processing speed.</p><p>COBOL was designed in 1959 by CODASYL and was partly based on the programming language FLOW-MATIC designed by Grace Hopper. It was created as part of a US Department of Defense effort to create a portable programming language for data processing. It was originally seen as a stopgap, but the Department of Defense promptly forced computer manufacturers to provide it, resulting in its widespread adoption. It was standardized in 1968 and has since been revised four times. Expansions include support for structured and object-oriented programming. The current standard is <i>ISO/IEC 1989:2014</i>.</p><p>COBOL statements have an English-like syntax, which was designed to be self-documenting and highly readable. However, it is verbose and uses over 300 reserved words. In contrast with modern, succinct syntax like <code class=\"mw-highlight mw-highlight-lang-c\" id=\"\" style=\"\" dir=\"ltr\"><span>y</span> <span>=</span> <span>x</span><span>;</span></code>, COBOL has a more English-like syntax (in this case, <code class=\"mw-highlight mw-highlight-lang-cobolfree\" id=\"\" style=\"\" dir=\"ltr\"><span>MOVE</span> <span>x</span> <span>TO</span> <span>y</span></code>).\nCOBOL code is split into four <i>divisions</i> (identification, environment, data, and procedure) containing a rigid hierarchy of sections, paragraphs and sentences. Lacking a large standard library, the standard specifies 43 statements, 87 functions and just one class.\n</p><p>Academic computer scientists were generally uninterested in business applications when COBOL was created and were not involved in its design; it was (effectively) designed from the ground up as a computer language for business, with an emphasis on inputs and outputs, whose only data types were numbers and strings of text.\nCOBOL has been criticized throughout its life for its verbosity, design process, and poor support for structured programming. These weaknesses result in monolithic and, though intended to be English-like, not easily comprehensible and verbose programs.\n</p>",
        "infobox": {
            "name": "COBOL",
            "logo": [
                "File:COBOL Report Apr60.djvu|200px|alt=COBOL. Report to Conference on Data Systems Languages including initial specifications for a Common Business Oriented Language (COBOL) for programming digital electronic computers. Department of Defense",
                "April 1960."
            ],
            "logo caption": "The cover of the ''COBOL 60'' report to CODASYL (April 1960)",
            "paradigm": [
                "Procedural programming|Procedural",
                "imperative programming|imperative",
                "Object-oriented programming|object-oriented"
            ],
            "year": "df|=|yes|1959",
            "designers": [
                "nowrap|Howard Bromberg ",
                "nowrap|Norman Discount ",
                "nowrap|Vernon Reeves ",
                "nowrap|Jean E. Sammet ",
                "nowrap|William Selden ",
                "nowrap|Gertrude Tierney"
            ],
            "developers": [
                "CODASYL",
                "ANSI",
                "ISO"
            ],
            "latest release version": "ISO/IEC 1989:2014",
            "latest release date": "2014",
            "typing": [
                "weak typing|Weak",
                "static typing|static"
            ],
            "implementations": [
                "nowraplinks|GnuCOBOL",
                "IBM COBOL ",
                "nowrap|Micro Focus Visual COBOL"
            ],
            "dialects": [
                "ACUCOBOL-GT",
                "COBOL-IT",
                "COBOL/2",
                "DEC COBOL-10",
                "DEC VAX COBOL",
                "DOSVS COBOL",
                "Fujitsu COBOL",
                "Hitachi COBOL2002",
                "HP3000 COBOL/II",
                "IBM COBOL SAA",
                "IBM COBOL/400",
                "IBM COBOL/II",
                "IBM Enterprise COBOL",
                "IBM ILE COBOL",
                "IBM OS/VS COBOL",
                "ICL COBOL (VME)",
                " isCOBOL",
                "Micro Focus COBOL",
                "Microsoft COBOL",
                "Realia COBOL",
                "Ryan McFarland RM/COBOL",
                "Ryan McFarland RM/COBOL-85",
                "Tandem (NonStop) COBOL85",
                "Tandem (NonStop) SCOBOL",
                "UNIVAC COBOL",
                "Unisys MCP COBOL74",
                "Unisys MCP COBOL85",
                "Unix COBOL X/Open",
                "Veryant isCOBOL",
                "Visual COBOL",
                "Wang VS COBOL"
            ],
            "influenced_by": [
                "AIMACO",
                "C++",
                "efn|name|=|2002 influence|Specifically influenced COBOL 2002's object-oriented features.|ref| name=\"SW95\"|ref| name=\"Arranga98\"|ref|cite journal | title=Cobol: Perception and Reality | journal=Computer | date=March 1997 | volume=30 | issue=3 | doi=10.1109/2.573683 | page=127 | issn=0018-9162 | first1=Edmund C. | last1=Arranga | first2=Frank P. | last2=Coyle |</ref> COMTRAN",
                "Eiffel (programming language)|Eiffel",
                "efn|name|=|2002 influence FACT computer language|FACT",
                "FLOW-MATIC",
                "Smalltalk efn|name|=|2002 influence"
            ],
            "influenced": [
                "CobolScript",
                "EGL (programming language)|EGL",
                "PL/I",
                "Programming Language for Business|PL/B citation needed | date|=|October 2017 | reason|=|Most sources on PL/B or Databus describe it is as COBOL-like",
                "not as *inspired by* COBOL."
            ],
            "file_ext": [
                "<code>.cbl</code>",
                "<code>.cob</code>",
                "<code>.cpy</code>"
            ],
            "wikibooks": "COBOL"
        }
    },
    {
        "id": 82,
        "name": "COMAL",
        "url": "https://en.wikipedia.org/wiki/COMAL",
        "summary": "<p><b>COMAL</b> (<i>Common Algorithmic Language</i>) is a computer programming language developed in Denmark by Benedict Løfstedt and Børge R. Christensen in 1973. COMAL was one of the few structured programming languages that was available for and comfortably usable on 8-bit home computers. It was based on the seminal BASIC programming language, adding multi-line statements and well-defined subroutines among other additions. </p><p>The \"COMAL Kernel Syntax &amp; Semantics\" contains the formal definition of the language. Further extensions common to many implementations are described in.</p>",
        "infobox": {
            "paradigm": "structured programming|Structured",
            "generation": "3GL",
            "year": "1973",
            "designer": "Benedict Løfstedt<br />Børge R. Christensen",
            "typing": "Strongly-typed programming language|Strong",
            "influenced_by": [
                "BASIC",
                "Pascal (programming language)|Pascal"
            ]
        }
    },
    {
        "id": 83,
        "name": "COMIT",
        "url": "https://en.wikipedia.org/wiki/COMIT",
        "summary": "<p><b>COMIT</b> was the first string processing language (compare SNOBOL, TRAC, and Perl), developed on the IBM 700/7000 series computers by Dr. Victor Yngve and collaborators at MIT from 1957 to 1965.  Yngve created the language for supporting computerized research in the field of linguistics, and more specifically, the area of machine translation for natural language processing. The creation of COMIT led to the creation of SNOBOL. </p>",
        "infobox": {
            "name": "COMIT",
            "year": "1957",
            "designer": "Victor Yngve",
            "latest release date": "1965",
            "influenced": "SNOBOL"
        }
    },
    {
        "id": 84,
        "name": "COMPASS",
        "url": "https://en.wikipedia.org/wiki/COMPASS",
        "summary": "<p><b>COMPASS</b>, <b><i>COMP</i>rehensive <i>ASS</i>embler</b>, is any of a family of macro assembly languages on Control Data Corporation's 3000 series, and on the 60-bit CDC 6000 series, 7600 and Cyber 70 and 170 series mainframe computers. While the architectures are very different, the macro and conditional assembly facilities are similar. </p>",
        "infobox": "N/A"
    },
    {
        "id": 85,
        "name": "COMTRAN",
        "url": "https://en.wikipedia.org/wiki/COMTRAN",
        "summary": "<p><b>COMTRAN</b> (COMmercial TRANslator) is an early programming language developed at IBM.  It was intended as the business programming equivalent of the scientific programming language FORTRAN (FORmula TRANslator).  It served as one of the forerunners to the COBOL language. Developed by Bob Bemer, in 1957, the language was the first to feature the programming language element known as a picture clause. </p>",
        "infobox": {
            "name": "COMTRAN",
            "released": "1957",
            "developer": "Bob Bemer",
            "influenced by": "FLOW-MATIC",
            "influenced": "COBOL"
        }
    },
    {
        "id": 86,
        "name": "COWSEL",
        "url": "https://en.wikipedia.org/wiki/COWSEL",
        "summary": "<p><b>COWSEL</b> (<i>COntrolled Working SpacE Language</i>) is a programming language designed between 1964 and 1966 by Robin Popplestone. It was based on an RPN form of Lisp combined with some ideas from CPL. </p><p>COWSEL was initially implemented on a Ferranti Pegasus computer at the University of Leeds and on a Stantec Zebra at the Bradford Institute of Technology; later, Rod Burstall implemented it on an Elliot 4120 at the University of Edinburgh.\n</p><p>COWSEL was renamed <b>POP-1</b> during the summer of 1966 and development continued under that name from then on.\n</p>",
        "infobox": {
            "name": "COWSEL",
            "released": "1964",
            "developer": [
                "Rod Burstall|Burstall",
                "Robin Popplestone|Popplestone"
            ],
            "influenced by": [
                "Combined Programming Language|CPL",
                "Lisp (programming language)|Lisp"
            ],
            "influenced": "POP-2"
        }
    },
    {
        "id": 87,
        "name": "CPL (programming language)",
        "url": "https://en.wikipedia.org/wiki/CPL_(programming_language)",
        "summary": "<p><b>CPL</b> (<b>Combined Programming Language</b>) is a multi-paradigm programming language, that was developed in the early 1960s.  It is an early ancestor of the C language via the BCPL and B languages. </p>",
        "infobox": {
            "name": "CPL",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm:\nprocedural programming|procedural",
                "Imperative programming language|imperative",
                "structured programming|structured",
                " functional programming|functional"
            ],
            "year": "start date and age|1963",
            "designer": "Christopher Strachey et al.",
            "influenced_by": "ALGOL 60",
            "influenced": [
                "BCPL",
                "POP-2"
            ]
        }
    },
    {
        "id": 88,
        "name": "C (programming language)",
        "url": "https://en.wikipedia.org/wiki/C_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p><b>C</b> (<span></span>, as in the letter <i>c</i>) is a general-purpose, procedural computer programming language supporting structured programming, lexical variable scope, and recursion, with a static type system. By design, C provides constructs that map efficiently to typical machine instructions. It has found lasting use in applications previously coded in assembly language. Such applications include operating systems and various application software for computers architectures that range from supercomputers to PLCs and embedded systems.\n</p><p>A successor to the programming language <i>B</i>, C was originally developed at Bell Labs by Dennis Ritchie between 1972 and 1973 to construct utilities running on Unix. It was applied to re-implementing the kernel of the Unix operating system. During the 1980s, C gradually gained popularity. It has become one of the most widely used programming languages, with C compilers from various vendors available for the majority of existing computer architectures and operating systems. C has been standardized by the ANSI since 1989 (ANSI C) and by the International Organization for Standardization (ISO).\n</p><p>C is an imperative procedural language. It was designed to be compiled to provide low-level access to memory and language constructs that map efficiently to machine instructions, all with minimal runtime support. Despite its low-level capabilities, the language was designed to encourage cross-platform programming. A standards-compliant C program written with portability in mind can be compiled for a wide variety of computer platforms and operating systems with few changes to its source code.\n</p>",
        "infobox": {
            "name": "C",
            "logo": "File:The C Programming Language logo.svg",
            "logo size": "140px",
            "logo alt": "Text in light blue serif capital letters on white background and very large light blue sans-serif letter C.",
            "logo caption": [
                "''The C Programming Language'' (often referred to as ''K&R'')",
                "the seminal book on C"
            ],
            "paradigm": [
                "Imperative programming|Imperative (Procedural programming|procedural)",
                "structured programming|structured"
            ],
            "designer": "Dennis Ritchie",
            "developer": "Dennis Ritchie & Bell Labs (creators); ANSI X3J11 (ANSI C); nobr|ISO/IEC JTC1/SC22/WG14 (ISO C)",
            "latest release version": "C18 (C standard revision)|C18",
            "latest release date": "start date and age|2018|06",
            "typing": [
                "Type system|Static",
                "Weak typing|weak",
                "manifest typing|manifest",
                "Nominal type system|nominal"
            ],
            "implementations": [
                "#K&R C|K&R C",
                "GNU Compiler Collection|GCC",
                "Clang",
                "nowrap|Intel C++ Compiler|Intel C",
                "C++Builder",
                "nowrap|Microsoft Visual C++ ",
                "nowrap|Watcom C/C++|Watcom C"
            ],
            "dialects": [
                "Cyclone (programming language)|Cyclone",
                "Unified Parallel C",
                "Split-C",
                "Cilk",
                "C*"
            ],
            "influenced": [
                ":Category:C programming language family|Numerous: AMPL",
                "AWK",
                "C shell|csh",
                "C++",
                "C--",
                "C Sharp (programming language)|C#",
                "Objective-C",
                "D (programming language)|D",
                "Go (programming language)|Go",
                "Java (programming language)|Java",
                "JavaScript",
                "Julia (programming language)|Julia",
                "Limbo (programming language)|Limbo",
                "LPC (programming language)|LPC",
                "Perl",
                "PHP",
                "Pike (programming language)|Pike",
                "Processing (programming language)|Processing",
                "Python (programming language)|Python",
                "Rust (programming language)|Rust",
                "Seed7",
                "Vala (programming language)|Vala",
                "Verilog (HDL)",
                "Nim (programming language)|Nim",
                "TempleOS|HolyC"
            ],
            "operating system": "Cross-platform",
            "year": "start date and age|1972",
            "turing-complete": "Yes",
            "influenced_by": [
                "B (programming language)|B (BCPL",
                "CPL (programming language)|CPL)",
                "ALGOL 68",
                "Assembly language|Assembly",
                "PL/I",
                "FORTRAN"
            ],
            "file ext": [
                ".c",
                ".h"
            ],
            "wikibooks": "C Programming"
        }
    },
    {
        "id": 89,
        "name": "C Sharp (programming language)",
        "url": "https://en.wikipedia.org/wiki/C_Sharp_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n \n<p><b>C#</b> (pronounced <i>see sharp</i>, like the musical note C♯, but written with the number sign) is a general-purpose, multi-paradigm programming language encompassing strong typing, lexically scoped, imperative, declarative, functional, generic, object-oriented (class-based), and component-oriented programming disciplines. It was developed around 2000 by Microsoft as part of its .NET initiative and later approved as an international standard by Ecma (ECMA-334) in 2002 and ISO (ISO/IEC 23270) in 2003. Mono is the name of the free and open-source project to develop a compiler and runtime for the language. C# is one of the programming languages designed for the Common Language Infrastructure (CLI).\n</p><p>C# was designed by Anders Hejlsberg, and its development team is currently led by Mads Torgersen. The most recent version is 8.0, which was released in 2019 alongside Visual Studio 2019 version 16.3.</p>",
        "infobox": {
            "name": "C#",
            "logo": "File:C Sharp logo.svg|150px",
            "paradigm": [
                "Structured programming|Structured",
                "Imperative programming|imperative",
                "Object-oriented programming|object-oriented",
                "Event-driven programming|event-driven",
                "The Task-based Asynchronous Pattern|task-driven",
                "Functional programming|functional",
                "Generic programming|generic",
                "Reflective programming|reflective",
                "Concurrent computing|concurrent"
            ],
            "family": "C (programming language)|C",
            "year": "start date and age|2000",
            "designer": "Microsoft",
            "developer": "Microsoft",
            "latest release version": "8.0",
            "latest release date": "start date and age|2019|09|23",
            "latest preview version": "9.0",
            "latest preview date": "start date and age|2020|05|20",
            "typing": [
                "Static typing|Static",
                "Dynamic typing|dynamic",
                "Type system#Strong and weak typing|strong",
                "Type system#Safely and unsafely typed systems|safe",
                "Nominative type system|nominative",
                "Type inference|partially inferred"
            ],
            "implementations": [
                "Microsoft Visual C Sharp|Visual C#",
                ".NET Framework",
                "Mono (software)|Mono",
                ".NET Core",
                "DotGNU|DotGNU (discontinued)",
                "Universal Windows Platform"
            ],
            "dialects": [
                "Cω",
                "Spec Sharp|Spec#",
                "Polyphonic C Sharp|Polyphonic C#",
                "[http://ecsharp.net Enhanced C#]"
            ],
            "influenced_by": [
                "C++",
                "Cω",
                "Eiffel (programming language)|Eiffel",
                "F Sharp (programming language)|F#",
                "efn|for async Haskell (programming language)|Haskell",
                "Icon (programming language)|Icon",
                "J Sharp|J#",
                "Visual J++|J++",
                "Java (programming language)|Java",
                "ML (programming language)|ML",
                "Modula-3",
                "Object Pascal",
                "Rust (programming language)|Rust",
                "Visual Basic|VB"
            ],
            "influenced": [
                "Chapel (programming language)|Chapel",
                "Clojure",
                "Crystal (programming language)|Crystal",
                "D (programming language)|D",
                "J Sharp|J#",
                "Dart (programming language)|Dart",
                "F Sharp (programming language)|F#",
                "Hack (programming language)|Hack",
                "Java (programming language)|Java",
                "Kotlin (programming language)|Kotlin",
                "Nemerle",
                "Oxygene (programming language)|Oxygene",
                "Ring",
                "Rust (programming language)|Rust",
                "Swift (programming language)|Swift",
                "Vala (programming language)|Vala",
                "TypeScript"
            ],
            "platform": "Common Language Infrastructure",
            "license": [
                "plainlist|\n*Roslyn (compiler)|Roslyn compiler: MIT License|MIT/X11|ref| name=\"auto\"|Cite web|url=https://github.com/dotnet/roslyn|title=The Roslyn .NET compiler provides C# and Visual Basic languages with rich code analysis APIs.: dotnet/roslyn|date=November 13",
                "2019|via=GitHub|</ref>|<br/>\n*.NET Core|.NET Core CLR: MIT License|MIT/X11|ref|Cite web|url=https://github.com/dotnet/coreclr|title=CoreCLR is the runtime for .NET Core. It includes the garbage collector",
                "JIT compiler",
                "primitive data types and low-level classes.: dotnet/coreclr|date=November 13",
                "2019|via=GitHub|</ref>|\n*Mono (software)|Mono compiler: dual GPLv3 and MIT/X11<br/>\n*DotGNU: dual GPL and LGPL <br/>\n*.NET Core|.NET Core CLR: MIT License|MIT/X11 *Mono (software)|Mono compiler: dual GPLv3 and MIT/X11<br/>\n*DotGNU: dual GPL and LGPL"
            ],
            "file_ext": "<code>.cs</code>",
            "website": "http://csharp.net",
            "wikibooks": "C Sharp Programming",
            "versions": "See #Versions|§ Versions"
        }
    },
    {
        "id": 90,
        "name": "C Shell",
        "url": "https://en.wikipedia.org/wiki/C_shell",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p>The <b>C shell</b> (<b>csh</b> or the improved version, <b>tcsh</b>) is a Unix shell created by Bill Joy while he was a graduate student at University of California, Berkeley in the late 1970s.  It has been widely distributed, beginning with the 2BSD release of the Berkeley Software Distribution (BSD) which Joy first distributed in 1978.  Other early contributors to the ideas or the code were Michael Ubell, Eric Allman, Mike O'Brien and Jim Kulp.</p><p>The C shell is a command processor typically run in a text window, allowing the user to type commands.  The C shell can also read commands from a file, called a script.  Like all Unix shells, it supports filename wildcarding, piping, here documents, command substitution, variables and control structures for condition-testing and iteration.  What differentiated the C shell from others, especially in the 1980s, were its interactive features and overall style.  Its new features made it easier and faster to use.  The overall style of the language looked more like C and was seen as more readable.\n</p><p>On many systems, such as macOS and Red Hat Linux, csh is actually tcsh, an improved version of csh.  Often one of the two files is either a hard link or a symbolic link to the other, so that either name refers to the same improved version of the C shell.\n</p><p>On Debian and some derivatives (including Ubuntu), there are two different packages: csh and tcsh. The former is based on the original BSD version of csh and the latter is the improved tcsh.</p><p>tcsh added filename and command completion and command line editing concepts borrowed from the Tenex system, which is the source of the \"t\".  Because it only added functionality and did not change what was there, tcsh remained backward compatible with the original C shell.  Though it started as a side branch from the original source tree Joy had created, tcsh is now the main branch for ongoing development.  tcsh is very stable but new releases continue to appear roughly once a year, consisting mostly of minor bug fixes.</p>",
        "infobox": {
            "name": "C shell",
            "screenshot": "Tcsh ejecutándose en escritorio Mac OSX.png",
            "caption": "tcsh and sh side-by-side on a Mac OS X desktop",
            "author": "Bill Joy",
            "released": "start date and age|1978",
            "latest_release_version": "6.20.00",
            "latest_release_date": "2016|11|24",
            "programming language": "C (programming language)|C",
            "operating system": [
                "Berkeley Software Distribution|BSD",
                "UNIX",
                "Linux",
                "macOS"
            ],
            "genre": "Unix shell",
            "license": "BSD license"
        }
    },
    {
        "id": 91,
        "name": "Caché ObjectScript",
        "url": "https://en.wikipedia.org/wiki/Cach%C3%A9_ObjectScript",
        "summary": "<p><b>Caché ObjectScript</b> is a part of the Caché database system sold by InterSystems. The language is a functional superset of the ANSI-standard MUMPS programming language. Since Caché is at its core a MUMPS implementation, it can run ANSI MUMPS routines with no change. To appeal as a commercial product, Caché implements support for object-oriented programming, a macro preprocessing language, embedded SQL for ANSI-standard SQL access to M's built-in database, procedure and control blocks using C-like brace syntax, procedure-scoped variables, and relaxed whitespace syntax limitations. </p><p>The language has private and public variables and globals. Global has a different meaning in this language than in most; such variables are global across routines, processes, and sessions. Thus, editing a global variable is making permanent and immediate changes to a system-universal database (which survives reboots, etc.).  The scope of a private variable is the local function, the scope of a public variable is the entire process. Variables, private and public, may be single elements or complete multi-dimensional arrays.\n</p><p>The great majority of Caché's feature-set is inherited from the ANSI MUMPS standard.  See that article for details on how data is represented and the different ways a programmer can think about the data during development.\n</p>",
        "infobox": {
            "name": "Caché ObjectScript",
            "year": "1997",
            "influenced_by": "MUMPS",
            "operating_system": "Cross-platform"
        }
    },
    {
        "id": 92,
        "name": "Caml",
        "url": "https://en.wikipedia.org/wiki/Caml",
        "summary": "<p><b>Caml</b> (originally an acronym for <b>Categorical Abstract Machine Language</b>) is a multi-paradigm, general-purpose programming language which is a dialect of the ML programming language family.  Caml was developed in France at INRIA and ENS. </p><p>Caml is statically typed, strictly evaluated, and uses automatic memory management. OCaml, the main descendant of Caml, adds many features to the language, including an object layer.\n</p>",
        "infobox": {
            "name": "Caml",
            "logo": "File:Caml.gif",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: functional programming language|functional",
                "imperative programming|imperative"
            ],
            "family": "ML (programming language)|ML",
            "year": "1985",
            "typing": [
                "Type inference|Inferred",
                "static typing|static",
                "strongly-typed programming language|strong"
            ],
            "designer": [
                "Gérard Huet",
                "Guy Cousineau (computer scientists)|Guy Cousineau",
                "Ascánder Suárez",
                "Pierre Weis",
                "Michel Mauny (Heavy Caml)",
                "Xavier Leroy (Caml Light)"
            ],
            "latest release version": "0.75",
            "latest release date": "start date and age|2002|01|26",
            "influenced by": "ML (programming language)|ML",
            "influenced": "OCaml",
            "operating system": "Cross-platform",
            "website": "caml.inria.fr"
        }
    },
    {
        "id": 93,
        "name": "Cayenne (programming language)",
        "url": "https://en.wikipedia.org/wiki/Cayenne_(programming_language)",
        "summary": "<p><b>Cayenne</b> is a dependently typed functional programming language created by Lennart Augustsson in 1998, making it one of the earliest dependently typed programming languages (as opposed to proof assistants or logical frameworks). A notable design decision is that the language allows unbounded recursive functions to be used on the type level, making type checking undecidable. Most dependently typed proof assistants and later dependently typed languages such as Agda included a termination checker to prevent the type checker from looping, while the contemporary Dependent ML restricted the expressivity of the type-level language to maintain decidability. </p><p>There are very few building blocks in the language, but much syntactic sugar to make it more readable. The basic types are functions, products, and sums. Functions and products use dependent types to gain additional power. The syntax is largely borrowed from Haskell. There is no special module system, because with dependent types records (products) are powerful enough to define modules.\n</p><p>The Cayenne implementation was written in Haskell, and it also translated to Haskell, but is currently no longer being maintained.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 94,
        "name": "Cecil (programming language)",
        "url": "https://en.wikipedia.org/wiki/Cecil_(programming_language)",
        "summary": "<p><b>Cecil</b> is a pure object-oriented programming language that was developed by Craig Chambers at the University of Washington in 1992 to be part of the Vortex project there. Cecil has many similarities to other object-oriented languages, most notably Objective-C, Modula-3, and Self. The main goals of the project were extensibility, orthogonality, efficiency, and ease-of-use. </p><p>The language supports multiple dispatch and multimethods, dynamic inheritance, and optional static type checking. Unlike most other OOP systems, Cecil allows subtyping and code inheritance to be used separately, allowing run-time or external extension of object classes or instances. Like Objective-C, all object services in Cecil are invoked by message passing, and the language supports run-time class identification. These features allow Cecil to support dynamic, exploratory programming styles. Parameterized types and methods (generics, polymorphism), garbage collection, and delegation are also supported. Cecil also supports a module mechanism for isolating independent libraries or packages. Cecil does not presently support threads or any other form of concurrency. A standard library for Cecil is also available and includes various collection, utility, system, I/O, and GUI classes.\n</p><p>The Diesel language was the successor of Cecil.</p><p>There was also an assembler type language known as Cesil (Computer Education in Schools Instructional Language) used in the late-1970s developed by ICL. It was quite similar to the later language MASM.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 95,
        "name": "Cesil",
        "url": "https://en.wikipedia.org/wiki/CESIL",
        "summary": "<p><b>Cesil</b>, or <b>C</b>omputer <b>E</b>ducation in <b>S</b>chools <b>I</b>nstruction <b>L</b>anguage, was a programming language designed to introduce pupils in British schools to Assembly language.  It is a low level language containing a total of fourteen instructions: </p>\n<ul><li>Load value - place the immediate value or the contents of the variable named in the accumulator.</li>\n<li>Store variable - place the contents of the accumulator in the variable.</li>\n<li>Jump label - transfer control to location labelled.</li>\n<li>Jineg label - transfer control to location labelled if the accumulator contains a negative value.</li>\n<li>Jizero label - transfer control to location labelled if the accumulator contains zero.</li>\n<li>Print literal - output the following string, delimited by single quotes.</li>\n<li>Line - output a carriage return</li>\n<li>In - allow user to input a numerical value from the console.</li>\n<li>Out - Output the contents of the accumulator as a decimal integer, signed if negative.</li>\n<li>Add value - add the variable or immediate integer value to the accumulator.</li>\n<li>Subtract value - subtract the variable or immediate integer from the accumulator.</li>\n<li>Multiply value - place the product of the accumulator and the variable or immediate integer in the accumulator.</li>\n<li>Divide value - place the contents of the accumulator divided by the value in the accumulator.</li>\n<li>Halt - return control to console.</li></ul>",
        "infobox": "N/A"
    },
    {
        "id": 96,
        "name": "Ceylon (programming language)",
        "url": "https://en.wikipedia.org/wiki/Ceylon_(programming_language)",
        "summary": "<p><b>Ceylon</b> is an object-oriented, strongly statically typed programming language with an emphasis on immutability, created by Red Hat. Ceylon programs run on the Java virtual machine (JVM), and can be compiled to JavaScript. The language design focuses on source code readability, predictability, toolability, modularity, and metaprogrammability.</p><p>Important features of Ceylon include:</p>\n<ul><li>A type system enforcing null safety and list element existence at compile time</li>\n<li>Regular syntax and semantics, avoiding special cases and primitively-defined constructs in favor of syntactic sugar</li>\n<li>Support for generic programming and metaprogramming, with reified generics</li>\n<li>Modularity built into the language, based on JBoss modules, interoperable with OSGi and Maven</li>\n<li>powerful tools, including an Eclipse-based IDE</li></ul><p>The name \"Ceylon\" is an oblique reference to Java, in that Java and Sri Lanka, formerly known as Ceylon, are islands known for growth and export of coffee and tea.\n</p><p>In August 2017, Ceylon was donated to the Eclipse Foundation.\n</p>",
        "infobox": {
            "name": "Ceylon",
            "logo": "Ceylon (programming language) logo.png",
            "paradigm": "Object-oriented programming|Object-oriented",
            "designer": "Gavin King",
            "developer": "Eclipse Foundation",
            "released": "2011",
            "latest release version": "1.3.3",
            "latest release date": "2017|08|21",
            "typing": [
                "Type system|Static",
                "strong",
                "safe"
            ],
            "platform": [
                "Java virtual machine",
                "JavaScript"
            ],
            "license": "Apache License 2.0",
            "website": "ceylon-lang.org",
            "file ext": ".ceylon",
            "influenced by": [
                "Java (programming language)|Java",
                "Scala (programming language)|Scala",
                "Smalltalk",
                "ML (programming language)|ML",
                "Lisp (programming language)|Lisp",
                "Whiley (programming language)|Whiley"
            ]
        }
    },
    {
        "id": 97,
        "name": "Cg (programming language)",
        "url": "https://en.wikipedia.org/wiki/Cg_(programming_language)",
        "summary": "<p><b>Cg</b> (short for <b>C for Graphics</b>) is a high-level shading language developed by Nvidia for programming vertex and pixel shaders. Cg is based on the C programming language and although they share the same syntax, some features of C were modified and new data types were added to make Cg more suitable for programming graphics processing units. This language is only suitable for GPU programming and is not a general programming language. The Cg compiler outputs DirectX or OpenGL shader programs. Since 2012, Cg was deprecated, with no additional development or support available.</p><p>A significant subset of Cg is shared with HLSL, as the language was developed in close collaboration with Microsoft. In early documentation, they are considered the same language marketed differently.</p>",
        "infobox": "N/A"
    },
    {
        "id": 98,
        "name": "Ch (computer programming)",
        "url": "https://en.wikipedia.org/wiki/Ch_(computer_programming)",
        "summary": "<p><b>Ch</b> <span></span> is a proprietary cross-platform C and C++ interpreter and scripting language environment, originally designed by Harry H. Cheng as a scripting language for beginners to learn mathematics, computing, numerical analysis (numeric methods), and programming in C/C++. Ch is now developed and marketed by SoftIntegration, Inc. A student edition is freely available. Ch Professional Edition for Raspberry Pi is free for non-commercial use. </p><p>Ch can be embedded in C/C++ application programs. It has numerical computing and graphical plotting features. Ch is a combined shell and IDE. Ch shell combines the features of common shell and C language. ChIDE provides quick code navigation and symbolic debugging.  It is based on embedded Ch, Scite and Scintilla.</p><p>Ch is written in C and runs on Windows, Linux, macOS, FreeBSD, AIX, Solaris, QNX, and HP-UX. It supports C90 and major C99 features, but it does not support the full set of C++ features. C99 complex number, IEEE-754 floating-point arithmetic, and variable-length array features were supported in Ch before they became part of the C99 standard. An article published by <i>Computer Reseller News</i> (CRN) named Ch as notable among C-based virtual machines for its functionality and the availability of third-party libraries.</p><p>Ch has many toolkits that extend its functions. For example, Ch Mechanism Toolkit is used for design and analysis of commonly used mechanisms such as fourbar linkage, five-bar linkage, six-bar linkage, crank-slider mechanism, and cam-follower system. Ch Control System Toolkit is used for modeling, design, and analysis of continuous-time or discrete-time linear time invariant (LTI) control systems. Both toolkits includes the source code.\n</p><p>Ch is now used and integrated into curriculum by many high schools and universities to teach computing and programming in C/C++. Ch has been integrated into free C-STEM Studio, a platform for learning  computing, science, technology, engineering, and mathematics (C-STEM) with robotics. C-STEM Studio is developed by UC Davis Center for Integrated Computing and STEM Education (C-STEM). It offers the curriculum for K-12 students.\n</p><p>Ch supports LEGO Mindstorms NXT and EV3, Arduino, Linkbot, Finch Robot, RoboTalk and Raspberry Pi, Pi Zero, and ARM for robot programming and learning. It can also be embedded into the LabVIEW system-design platform and development environment.</p>",
        "infobox": {
            "name": "Ch C/C++ interpreter",
            "author": "Harry H. Cheng",
            "developer": [
                "SoftIntegration",
                "Inc."
            ],
            "released": "2001|10|01",
            "latest release version": "8.0.0",
            "latest release date": "2017|11|19",
            "programming language": "C (programming language)|C",
            "operating system": [
                "Microsoft Windows|Windows",
                "OS X",
                "Linux",
                "IBM AIX|AIX",
                "HP-UX",
                "Solaris (operating system)|Solaris (SPARC and x86)",
                "QNX",
                "FreeBSD"
            ],
            "platform": [
                "x86",
                "SPARC"
            ],
            "language": "English",
            "genre": "Integrated development environment",
            "license": "Proprietary software<br/>'''Standard edition:''' freeware<br />'''Student edition:''' freeware for students<br />'''Professional edition:''' trialware for 30 days",
            "website": "www.softintegration.com"
        }
    },
    {
        "id": 99,
        "name": "Chapel (programming language)",
        "url": "https://en.wikipedia.org/wiki/Chapel_(programming_language)",
        "summary": "<p><b>Chapel</b>, the <b>Cascade High Productivity Language</b>, is a parallel programming language developed by Cray. It is being developed as part of the Cray Cascade project, a participant in DARPA's High Productivity Computing Systems (HPCS) program, which had the goal of increasing supercomputer productivity by the year 2010. It is being developed as an open source project, under version 2 of the Apache license.</p>",
        "infobox": {
            "name": "Chapel",
            "logo": "File:Cray Chapel Logo.png",
            "file ext": ".chpl",
            "paradigm": "Object-oriented programming|Object-oriented <br/> Partitioned global address space <br/> Parallel programming model|Parallel programming",
            "released": "2009",
            "designer": [
                "David Callahan",
                "Hans Zima",
                "Brad Chamberlain",
                "John Plevyak"
            ],
            "developer": "Cray|Cray Inc.",
            "latest release version": "1.20",
            "latest release date": "start date and age|2019|09|19",
            "typing": "Type system|static <br/> Type inference|inferred",
            "influenced by": [
                "Ada (programming language)|Ada",
                "C Sharp (programming language)|C#",
                "C (programming language)|C",
                "Fortran",
                "C++",
                "Java (programming language)|Java",
                "High Performance Fortran|HPF",
                "ZPL (programming language)|ZPL",
                "Cray MTA / Cray XMT|XMT extensions to C and Fortran."
            ],
            "platform": "multiplatform",
            "operating system": [
                "Mac OS",
                "Linux",
                "POSIX",
                "Windows (with Cygwin)"
            ],
            "license": "Apache 2",
            "website": "https://chapel-lang.org/"
        }
    },
    {
        "id": 100,
        "name": "Charm (language)",
        "url": "https://en.wikipedia.org/wiki/Charm_(programming_language)",
        "summary": "<p><b>Charm</b> is a computer programming language devised in the early 1990s with similarities to the RTL/2, Pascal and C languages in addition to containing some unique features of its own. The Charm language is defined by a context-free grammar amenable to being processed by recursive descent parser as described in seminal books on compiler design.</p><p>A set of Charm tools including a compiler, assembler and linker released for the Acorn market has been reviewed in Acorn User magazine under the category of programming software. Charm reworked for RISC OS platforms has subsequently been reviewed in Archive magazine.</p><p>Charm is further described in the e-book <i>Programming in Charm on the Raspberry Pi</i>.</p>",
        "infobox": {
            "name": "Charm",
            "paradigm": "Structured programming",
            "year": "1996",
            "designer": "P. Nowosad",
            "influenced_by": [
                "RTL/2",
                "C (programming language)|C",
                "Pascal (programming language)|Pascal"
            ],
            "operating_system": "RISC OS",
            "website": "charm.qu-bit.co.uk"
        }
    },
    {
        "id": 101,
        "name": "Chicken",
        "url": "https://en.wikipedia.org/wiki/Chicken",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p class=\"mw-empty-elt\">\n\n</p>\n<p>The <b>chicken</b> (<i>Gallus gallus domesticus</i>) is a type of domesticated fowl, a subspecies of the red junglefowl (<i>Gallus gallus</i>). Chickens are one of the most common and widespread domestic animals, with a total population of 23.7 billion as of 2018, up from more than 19 billion in 2011. There are more chickens in the world than any other bird or domesticated fowl. Humans keep chickens primarily as a source of food (consuming both their meat and eggs) and, less commonly, as pets. Originally raised for cockfighting or for special ceremonies, chickens were not kept for food until the Hellenistic period (4th–2nd centuries BC).</p><p>Genetic studies have pointed to multiple maternal origins in South Asia, Southeast Asia, and East Asia, but with the clade found in the Americas, Europe, the Middle East and Africa originating in the Indian subcontinent. From ancient India, the domesticated chicken spread to Lydia in western Asia Minor, and to Greece by the 5th century BC. Fowl had been known in Egypt since the mid-15th century BC, with the \"bird that gives birth every day\" having come to Egypt from the land between Syria and Shinar, Babylonia, according to the annals of Thutmose III.</p>",
        "infobox": {
            "name": "Chicken",
            "status": "DOM",
            "image": "Female pair.jpg",
            "image_caption": "A rooster or cock (left) and wikt:hen|hen (right) perching on a roost.",
            "genus": "Gallus",
            "species": "gallus",
            "species_link": "Red junglefowl",
            "subspecies": "domesticus",
            "authority": [
                "(Carl Linnaeus|Linnaeus",
                "10th edition of Systema Naturae|1758)"
            ]
        }
    },
    {
        "id": 102,
        "name": "Chomski",
        "url": "https://en.wikipedia.org/wiki/Chomski",
        "summary": "<p><span></span> </p>\n<p><b>pattern parsing virtual machine</b>  (previously called 'chomski' after Noam Chomsky) and <b>pep</b> refer to both a command line computer language and utility (interpreter for that language) which can be used to parse and transform text patterns and (formal mathematical) languages. The utility reads input files character by character (sequentially), applying the operation which has been specified via the command line or a <i>pep script</i>, and then outputs the line. It was developed from 2006 in the C language. Pep has derived a number of ideas and syntax elements from Sed, a command line text stream editor.\n</p>",
        "infobox": {
            "name": [
                "pep",
                "pep virtual machine"
            ],
            "paradigm": "scripting language",
            "year": "2007",
            "designer": "mj bishop",
            "typing": "none; all data is treated as a string",
            "implementations": "bumble.sourceforge.net/books/pars/",
            "influenced_by": [
                "Sed",
                "Awk"
            ],
            "operating_system": "Cross-platform"
        }
    },
    {
        "id": 103,
        "name": "ChucK",
        "url": "https://en.wikipedia.org/wiki/ChucK",
        "summary": "<p><b>ChucK</b> is a concurrent, strongly timed audio programming language for real-time synthesis, composition, and performance, which runs on Linux, Mac OS X, Microsoft Windows, and iOS. It is designed to favor readability and flexibility for the programmer over other considerations such as raw performance. It natively supports deterministic concurrency and multiple, simultaneous, dynamic control rates. Another key feature is the ability to live code; adding, removing, and modifying code on the fly, while the program is running, without stopping or restarting. It has a highly precise timing/concurrency model, allowing for arbitrarily fine granularity. It offers composers and researchers a powerful and flexible programming tool for building and experimenting with complex audio synthesis programs, and real-time interactive control.</p><p>ChucK was created and chiefly designed by Ge Wang as a graduate student working with Perry R. Cook.  ChucK is distributed freely under the terms of the GNU General Public License on Mac OS X, Linux and Microsoft Windows. On iPhone and iPad, ChiP (ChucK for iPhone) is distributed under a limited, closed source license, and is not currently licensed to the public. However, the core team has stated that it would like to explore \"ways to open ChiP by creating a beneficial environment for everyone\".</p>",
        "infobox": {
            "logo": "ChucK logo2.jpg",
            "paradigm": "Multi-paradigm programming language|Multi-paradigm",
            "year": "2003",
            "latest release version": "1.4.0.0",
            "latest release date": "start date and age|2018|02|09",
            "designer": "Ge Wang",
            "typing": "Strong typing|Strong",
            "operating_system": "Cross-platform",
            "license": [
                "Mac OS X|Mac",
                "Linux",
                "Microsoft Windows|Windows: GNU General Public License<br/>\niOS: Closed Source (Not Public)"
            ],
            "website": "chuck.cs.princeton.edu"
        }
    },
    {
        "id": 104,
        "name": "Cilk",
        "url": "https://en.wikipedia.org/wiki/Cilk",
        "summary": "<p><b>Cilk</b>, <b>Cilk++</b> and <b>Cilk Plus</b> are general-purpose programming languages designed for multithreaded parallel computing. They are based on the C and C++ programming languages, which they extend with constructs to express parallel loops and the fork–join idiom. </p><p>Originally developed in the 1990s at the Massachusetts Institute of Technology (MIT) in the group of Charles E. Leiserson, Cilk was later commercialized as Cilk++ by a spinoff company, Cilk Arts. That company was subsequently acquired by Intel, which increased compatibility with existing C and C++ code, calling the result Cilk Plus.\n</p>",
        "infobox": {
            "name": "Cilk",
            "paradigm": [
                "imperative programming|imperative (Procedural programming|procedural)",
                "structured programming|structured",
                "parallel programming|parallel"
            ],
            "year": "1994",
            "designer": "Massachusetts Institute of Technology|MIT Laboratory for Computer Science",
            "developer": "Intel",
            "typing": [
                "Type system|static",
                "Weak typing|weak",
                "manifest typing|manifest"
            ],
            "dialects": [
                "Cilk++",
                "Cilk Plus"
            ],
            "influenced_by": "C (programming language)|C",
            "influenced": "OpenMP 3.0"
        }
    },
    {
        "id": 105,
        "name": "Citrine (programming language)",
        "url": "https://en.wikipedia.org/wiki/Citrine_(programming_language)",
        "summary": "<p><b>Citrine</b> is a general-purpose programming language for Cross-platform (multi-platform) operating systems. It focuses on readability and maintainability. Readability is achieved by syntactic and conceptual minimalism. The language is heavily inspired by Smalltalk and Self but has some very distinctive features. Like Smalltalk, Citrine treats everything as an object and focuses on sending messages to these objects. However unlike Smalltalk, Citrine lacks the concept of a class. In this regard, Citrine is more like Self and JavaScript because it uses prototypes. The combination of Smalltalk like messages and prototypes is what makes Citrine unique. </p><p>As of the 0.7 version Citrine has focused on supporting native human languages instead of just English to help people reduce the number of bugs because of confusion and misunderstanding due to language barriers. As such Citrine 0.7 and higher feature a translator to translate between human languages.\n</p>",
        "infobox": {
            "name": "Citrine",
            "logo": "Citrine programming language logo.png",
            "paradigm": [
                "Object-oriented programming|Object-oriented",
                "Prototype-based programming|prototype-based"
            ],
            "year": "2014",
            "designer": [
                "Gabor de Mooij",
                "Aavesh Jilani"
            ],
            "developer": [
                "Gabor de Mooij",
                "Aavesh Jilani"
            ],
            "latest release version": "0.9.2",
            "latest release date": "2020|df|=|y",
            "typing": "dynamic typing|dynamic",
            "implementations": "C",
            "influenced by": "Smalltalk Self (programming language)|Self",
            "operating system": "Cross-platform|Cross-platform (multi-platform)",
            "license": "BSD licenses|BSD",
            "website": "citrine-lang.org",
            "file ext": "ctr"
        }
    },
    {
        "id": 106,
        "name": "Claire (programming language)",
        "url": "https://en.wikipedia.org/wiki/Claire_(programming_language)",
        "summary": "<p><b>Claire</b> is a high-level functional and object-oriented programming language with rule processing abilities. It was designed by Yves Caseau at Bouygues' e-Lab research laboratory, and received its final definition in 2004. </p><p>Claire provides:\n</p>\n<ul><li>a simple object system with parametric classes and methods</li>\n<li>polymorphic and parametric functional programming</li>\n<li>production rules triggered by events</li>\n<li>versioned snapshots of the state of the whole system, or any part, supporting rollback and easy exploration of search spaces</li>\n<li>explicit relations between entities; for example, two entities might be declared inverses of one another</li>\n<li>first-class sets with convenient syntax for set-based programming</li>\n<li>an expressive set-based type system allowing both second-order static and dynamic typing</li></ul><p>Claire's reference implementation, consisting of an interpreter and compiler, was fully open-sourced with the release of version 3.3.46 in February 2009. Another implementation, WebClaire, is commercially supported.\n</p>",
        "infobox": {
            "name": "Claire",
            "file_ext": "<code>.cl</code>",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: functional programming|functional",
                "object-oriented programming|object-oriented (class (computer programming)|class-based)",
                "Production system (computer science)|rule processing",
                "reflection (computer programming)|reflective"
            ],
            "year": "start date|1994",
            "designer": "Yves Caseau",
            "latest_release_version": "3.3.46",
            "latest_release_date": "start date and age|2009|2|17",
            "typing": [
                "strongly typed programming language|strong",
                "both static typing|static and dynamic typing|dynamic"
            ],
            "implementations": [
                "Claire (reference implementation)",
                "WebClaire"
            ],
            "influenced_by": [
                "Smalltalk",
                "SETL",
                "OPS5",
                "Lisp (programming language)|Lisp",
                "ML (programming language)|ML",
                "C (programming language)|C",
                "LORE",
                "LAURE"
            ],
            "operating_system": "Cross-platform",
            "license": "Permissive free software licence"
        }
    },
    {
        "id": 107,
        "name": "Clarion (programming language)",
        "url": "https://en.wikipedia.org/wiki/Clarion_(programming_language)",
        "summary": "<p><b>Clarion</b> is a commercial, proprietary, 4GL, multi-paradigm, programming language and Integrated Development Environment from SoftVelocity used to program database applications. It is compatible with ISAM, SQL and ADO data access methods, reads and writes several flat file desktop database formats including ASCII, CSV, DOS (Binary), FoxPro, Clipper, dBase, and some relational databases via ODBC, MS SQL Server, Sybase SQL Anywhere and Oracle through the use of accelerated native database drivers, and XML, Clarion can be used to output to HTML, XML, plaintext, and PDF, among others. </p><p><br></p><p>\nThe Clarion Development Environment (IDE) sits on top of the Clarion Programming Language. The IDE provides code generation facilities via a system of templates which allow programmers to describe the program from an abstract level higher than actual code statements. The generator then turns this higher level into code, which in turn is then compiled and linked using a normal compiler and linker. This generation layer is sometimes referred to as 4GL programming.</p><p>The generation layer is not required. It is possible to create programs completely at the code level (the so-called 3GL layer), bypassing all the code generation facilities.\n</p><p>If the templates are used to generate code then programmers are able to inject their own code into the generated code to alter, or extend, the functionality offered by the template layer. This process of embedding code can be done while viewing the surrounding generated code. This mixing of template code and generated code allows the template settings to be updated, and the code regenerated, without the loss of the embedded code.\n</p><p>The templates (from which the code is generated) are provided in source form and developers are free to create their own templates. A large collection of templates have been written by various developers some of which are offered as commercial add-ons and some of which are free.\n</p><p>There are several Clarion products available; Clarion Professional Edition, Clarion Enterprise Edition and Clarion.Net.\n</p>",
        "infobox": {
            "name": "Clarion",
            "developer": [
                "Jensen & Partners International|JPI",
                "Clarion International",
                "SoftVelocity"
            ],
            "latest release version": "Clarion 11",
            "operating_system": "Microsoft Windows",
            "genre": "Integrated development environment",
            "website": "[http://www.softvelocity.com www.softvelocity.com]"
        }
    },
    {
        "id": 108,
        "name": "Clean (programming language)",
        "url": "https://en.wikipedia.org/wiki/Clean_(programming_language)",
        "summary": "<p><b>Clean</b> is a general-purpose purely functional computer programming language. For much of the language's active development history it was called <b>Concurrent Clean</b>, but this was dropped at some point. Clean is being developed by a group of researchers from the Radboud University in Nijmegen since 1987. </p>\n\n\n",
        "infobox": {
            "name": "Clean",
            "logo": "Clean_3.0_(programming_language)_logo.svg",
            "paradigm": "functional programming|functional",
            "year": "1987",
            "designer": "Software Technology Research Group of Radboud University Nijmegen",
            "latest_release_version": "3.0",
            "latest_release_date": "2018|10|19",
            "typing": [
                "strong typing|strong",
                "static typing|static",
                "dynamic typing|dynamic"
            ],
            "operating_system": "Cross-platform",
            "license": "Simplified BSD License|Simplified BSD",
            "influenced_by": [
                "Lean (programming language)|Lean",
                "Miranda (programming language)|Miranda",
                "Haskell (programming language)|Haskell"
            ],
            "influenced": [
                "Haskell (programming language)|Haskell",
                "Idris (programming language)|Idris"
            ],
            "file_ext": [
                ".icl",
                ".dcl",
                ".abc"
            ],
            "website": "clean.cs.ru.nl"
        }
    },
    {
        "id": 109,
        "name": "Clipper (programming language)",
        "url": "https://en.wikipedia.org/wiki/Clipper_(programming_language)",
        "summary": "<p>Clipper is an xBase compiler that implements a variant of the <i>xBase</i> computer programming language. It is used to create  or extend software programs that originally operated primarily under MS-DOS. Although it is a powerful general-purpose programming\nlanguage, it was primarily used to create database/business programs.\n</p><p>One major dBase feature  not implemented in Clipper is the dot-prompt (. prompt) interactive command set, which was an important part of the original dBase implementation.\n</p><p>Clipper, from Nantucket Corp and later Computer Associates, started out as a native code compiler for dBase III databases, and later evolved.</p>",
        "infobox": {
            "name": "Clipper",
            "year": "1985",
            "latest_release_version": "CA Clipper 5.3b",
            "latest_release_date": "1997|05|20",
            "operating_system": "MS-DOS",
            "website": "http://www.grafxsoft.com/clipper.htm"
        }
    },
    {
        "id": 110,
        "name": "Clojure",
        "url": "https://en.wikipedia.org/wiki/Clojure",
        "summary": "<p><b>Clojure</b> (<span></span>, like <i>closure</i>) is a modern, dynamic, and functional dialect of the Lisp programming language on the Java platform. Like other Lisps, Clojure treats code as data and has a Lisp macro system. The current development process is community-driven, overseen by Rich Hickey as its benevolent dictator for life (BDFL).</p><p>Clojure advocates immutability and immutable data structures and encourages programmers to be explicit about managing identity and its states. This focus on programming with immutable values and explicit progression-of-time constructs is intended to facilitate developing more robust, especially concurrent, programs that are simple and fast. While its type system is entirely dynamic, recent efforts have also sought the implementation of gradual typing.</p><p>Commercial support for Clojure is provided by Cognitect. Clojure conferences are organized every year across the globe, the most famous of them being Clojure/conj.</p> \n\n",
        "infobox": {
            "name": "Clojure",
            "logo": "Clojure logo.svg",
            "paradigm": "multi-paradigm programming language|multi-paradigm: flatlist|\n* agent-oriented programming|agent-oriented|ref| name=\"reference/agents\"|cite web |url=https://clojure.org/reference/agents |website=Clojure.org |title=Agents and Asynchronous Actions |access-date=2019-07-07|</ref>|\n* concurrent programming|concurrent|ref|cite web |url=https://clojure.org/about/concurrent_programming |website=Clojure.org |title=Concurrent Programming |access-date=2019-07-07|</ref>|ref|cite web |url=https://github.com/clojure/core.async |website=GitHub.com |title=core.async |last1=Hickey |first1=Rich |author2=contributors |access-date=2019-07-07|</ref>|\n* functional programming|functional|ref|cite web |url=https://clojure.org/about/functional_programming |website=Clojure.org |title=Functional Programming |access-date=2019-07-07|</ref>|\n* logic programming|logic|ref|cite web |url=https://github.com/clojure/core.logic/ |website=GitHub.com |title=core.logic |last1=Nolen |first1=David |last2=Hickey |first2=Rich |author3=contributors |access-date=2019-07-07|</ref>|\n* macro (computer science)|macro|ref| name=\"reference/macros\"|cite web |url=https://clojure.org/reference/macros |website=Clojure.org |title=Macros |access-date=2019-07-07|</ref>|\n* pipeline (software)|pipeline|ref|cite web |url=https://clojure.org/guides/threading_macros |website=Clojure.org |title=Threading Macros Guide |last=Esterhazy |first=Paulus |access-date=2019-07-07|</ref>| * concurrent programming|concurrent * functional programming|functional * logic programming|logic * macro (computer science)|macro * pipeline (software)|pipeline",
            "family": "Lisp (programming language)|Lisp",
            "released": "2007",
            "designer": "Rich Hickey",
            "latest release version": "1.10.1",
            "latest release date": "start date and age|2019|06|06",
            "latest preview version": "1.10.2-alpha1",
            "latest preview date": "start date and age|2020|03|05",
            "typing": "flatlist|\n* dynamic typing|dynamic\n* strong typing|strong",
            "influenced by": "flatlist|\n* C Sharp (programming language)|C#\n* C++|ref|cite web |url=http://www.codequarterly.com/2011/rich-hickey/ |website=CodeQuarterly.com |title=Rich Hickey Q&A |last=Fogus |first=Michael |year=2011 |archive-url=https://web.archive.org/web/20170111184835/http://www.codequarterly.com/2011/rich-hickey/ |archive-date=2017-01-11|</ref>|\n* Common Lisp\n* Erlang (programming language)|Erlang\n* Haskell (programming language)|Haskell\n* Java (programming language)|Java\n* Mathematica|ref|cite web |url=https://www.amazon.com/gp/richpub/listmania/fullview/R3LG3ZBZS4GCTH |website=Amazon.com |title=Clojure Bookshelf |last=Hickey |first=Rich |archive-url=https://web.archive.org/web/20171003001051/https://www.amazon.com/gp/richpub/listmania/fullview/R3LG3ZBZS4GCTH |archive-date=2017-10-03 |access-date=2019-07-07|</ref>|\n* ML (programming language)|ML\n* Prolog\n* Racket (programming language)|Racket|ref|cite thesis |last=Bonnaire-Sergeant |first=Ambrose |title=A Practical Optional Type System for Clojure |publisher=The University of Western Australia |year=2012|</ref>|\n* Ruby (programming language)|Ruby|ref|cite web |url=http://cdn.oreilly.com/oreilly/booksamplers/9781449394707_sampler.pdf |website=OReilly.com |title=Clojure Programming |access-date=2013-04-30|</ref>|\n* Scheme (programming language)|Scheme * Common Lisp\n* Erlang (programming language)|Erlang\n* Haskell (programming language)|Haskell\n* Java (programming language)|Java\n* Mathematica * ML (programming language)|ML\n* Prolog\n* Racket (programming language)|Racket * Ruby (programming language)|Ruby * Scheme (programming language)|Scheme",
            "influenced": "flatlist|\n* Elixir (programming language)|Elixir\n* Hy\n* LFE (programming language)|LFE\n* Pixie|ref|cite web |url=https://www.pixielang.org/ |website=PixieLang.org |title=Pixie |last=Baldridge |first=Timothy |access-date=2019-07-07|</ref>|\n* Rhine|ref|cite web |url=https://github.com/artagnon/rhine-ml |website=GitHub.org |title=Rhine |last=Ramachandra |first=Ramkumar |access-date=2019-07-07|</ref>| * Rhine",
            "platform": "flatlist|\n* Java (software platform)|Java\n* JavaScript engine|JavaScript\n* Common Language Infrastructure|.NET",
            "license": "Eclipse Public License",
            "website": "https://clojure.org",
            "file ext": "flatlist|\n* .clj\n* .cljs\n* .cljc\n* .edn",
            "wikibooks": "Clojure Programming"
        }
    },
    {
        "id": 111,
        "name": "CobolScript",
        "url": "https://en.wikipedia.org/wiki/CobolScript",
        "summary": "<p><b>CobolScript</b> is a programming language created by Matthew Dean and Charles Schereda of Deskware in 1999. The language was intended to provide web-enabled COBOL, and was targeted at businesses using legacy software written in that language.</p>",
        "infobox": "N/A"
    },
    {
        "id": 112,
        "name": "Cobra (programming language)",
        "url": "https://en.wikipedia.org/wiki/Cobra_(programming_language)",
        "summary": "<p><b>Cobra</b> is a discontinued general-purpose, object-oriented programming language. Cobra is designed by Charles Esterbrook, and runs on the Microsoft .NET and Mono platforms. It is strongly influenced by Python, C#, Eiffel, Objective-C, and other programming languages. It supports both static and dynamic typing. It has support for unit tests and contracts. It has lambda expressions, closures, list comprehensions, and generators.</p><p>Cobra is an open-source project; it was released under the MIT License on February 29, 2008.</p>",
        "infobox": {
            "name": "Cobra",
            "paradigm": "Multi-paradigm programming language|Multi-paradigm: Object-oriented programming|object-oriented",
            "discontinued": "yes",
            "year": "2006",
            "designer": "Charles Esterbrook",
            "developer": "Cobra Language LLC",
            "latest_release_version": "0.9.6",
            "latest_release_date": "2013|12|23",
            "typing": [
                "strong typing|strong",
                "static typing|static",
                "dynamic typing|dynamic",
                "Inferred typing|inferred"
            ],
            "influenced_by": [
                "Python (programming language)|Python",
                "Eiffel (programming language)|Eiffel",
                "C Sharp (programming language)|C#",
                "Objective-C"
            ],
            "operating_system": [
                "Microsoft .NET",
                "Mono (software)|Mono"
            ],
            "website": "url|http://cobra-language.com/",
            "license": "MIT License|MIT",
            "file_ext": ".cobra"
        }
    },
    {
        "id": 113,
        "name": "CoffeeScript",
        "url": "https://en.wikipedia.org/wiki/CoffeeScript",
        "summary": "<p><b>CoffeeScript</b> is a programming language that compiles to JavaScript. It adds syntactic sugar inspired by Ruby, Python and Haskell in an effort to enhance JavaScript's brevity and readability. Specific additional features include list comprehension and destructuring assignment. </p><p>CoffeeScript support is included in Ruby on Rails version 3.1 and Play Framework. In 2011, Brendan Eich referenced CoffeeScript as an influence on his thoughts about the future of JavaScript.</p>",
        "infobox": {
            "name": "CoffeeScript",
            "logo": "CoffeeScript-logo.png",
            "paradigm": [
                "Multi-paradigm: prototype-based programming|prototype-based",
                "functional programming|functional",
                "imperative programming|imperative",
                "scripting language|scripting"
            ],
            "released": "start date and age|2009|12|13",
            "designer": "Jeremy Ashkenas",
            "developer": "Jeremy Ashkenas",
            "latest_release_version": "2.5.1",
            "latest_release_date": "start date and age|2020|01|31",
            "influenced_by": [
                "Haskell (programming language)|Haskell",
                "JavaScript",
                "Perl",
                "January 2016 Python (programming language)|Python",
                "Ruby (programming language)|Ruby",
                "YAML"
            ],
            "influenced": [
                "MoonScript",
                "LiveScript",
                "JavaScript"
            ],
            "operating_system": "Cross-platform",
            "license": "MIT License",
            "file_ext": [
                ".coffee",
                ".litcoffee"
            ]
        }
    },
    {
        "id": 114,
        "name": "ColdFusion",
        "url": "https://en.wikipedia.org/wiki/Adobe_ColdFusion",
        "summary": "<p>Adobe <b>ColdFusion</b> is a commercial rapid web-application development computing platform created by J. J. Allaire in 1995. (The programming language used with that platform is also commonly called ColdFusion, though is more accurately known as CFML.) ColdFusion was originally designed to make it easier to connect simple HTML pages to a database. By version 2 (1996), it became a full platform that included an IDE in addition to a full scripting language. </p>",
        "infobox": {
            "name": "Adobe ColdFusion",
            "logo": "Image:ColdFusion.png|64px|Adobe ColdFusion 10",
            "developer": "Adobe Systems Incorporated",
            "author": "Joseph J. Allaire|J. J. Allaire",
            "released": "1995",
            "ver layout": "stacked",
            "latest release version": "Latest stable software release/Adobe ColdFusion",
            "language": "English",
            "genre": "Application server",
            "programming language": "Java (programming language)|Java",
            "operating system": "Cross-platform",
            "license": "Proprietary",
            "website": "https://www.adobe.com/products/coldfusion-family.html"
        }
    },
    {
        "id": 115,
        "name": "Combined Programming Language",
        "url": "https://en.wikipedia.org/wiki/CPL_(programming_language)",
        "summary": "<p><b>CPL</b> (<b>Combined Programming Language</b>) is a multi-paradigm programming language, that was developed in the early 1960s.  It is an early ancestor of the C language via the BCPL and B languages. </p>",
        "infobox": {
            "name": "CPL",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm:\nprocedural programming|procedural",
                "Imperative programming language|imperative",
                "structured programming|structured",
                " functional programming|functional"
            ],
            "year": "start date and age|1963",
            "designer": "Christopher Strachey et al.",
            "influenced_by": "ALGOL 60",
            "influenced": [
                "BCPL",
                "POP-2"
            ]
        }
    },
    {
        "id": 116,
        "name": "Common Intermediate Language",
        "url": "https://en.wikipedia.org/wiki/Common_Intermediate_Language",
        "summary": "<p><b>Common Intermediate Language</b> (<b>CIL</b>), formerly called <b>Microsoft Intermediate Language</b> (<b>MSIL</b>) or <b>Intermediate Language</b> (<b>IL</b>), is the intermediate language binary instruction set defined within the Common Language Infrastructure (CLI) specification. CIL instructions are executed by a CLI-compatible runtime environment such as the Common Language Runtime. Languages which target the CLI compile to CIL. CIL is object-oriented, stack-based bytecode. Runtimes typically just-in-time compile CIL instructions into native code. </p><p>CIL was originally known as Microsoft Intermediate Language (MSIL) during the beta releases of the .NET languages. Due to standardization of C# and the CLI, the bytecode is now officially known as CIL. Windows Defender virus definitions continue to refer to binaries compiled with it as MSIL.</p>",
        "infobox": "N/A"
    },
    {
        "id": 117,
        "name": "Common Lisp",
        "url": "https://en.wikipedia.org/wiki/Common_Lisp",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p><b>Common Lisp</b> (<b>CL</b>) is a dialect of the Lisp programming language, published in ANSI standard document <i>ANSI INCITS 226-1994 (R2004)</i> (formerly <i>X3.226-1994 (R1999)</i>). The Common Lisp HyperSpec, a hyperlinked HTML version, has been derived from the ANSI Common Lisp standard.</p><p>The Common Lisp language was developed as a standardized and improved successor of Maclisp. By the early 1980s several groups were already at work on diverse successors to MacLisp: Lisp Machine Lisp (aka ZetaLisp), Spice Lisp, NIL and S-1 Lisp. Common Lisp sought to unify, standardise, and extend the features of these MacLisp dialects. Common Lisp is not an implementation, but rather a language specification. Several implementations of the Common Lisp standard are available, including free and open-source software and proprietary products.\nCommon Lisp is a general-purpose, multi-paradigm programming language. It supports a combination of procedural, functional, and object-oriented programming paradigms. As a dynamic programming language, it facilitates evolutionary and incremental software development, with iterative compilation into efficient run-time programs. This incremental development is often done interactively without interrupting the running application.\n</p><p>It also supports optional type annotation and casting, which can be added as necessary at the later profiling and optimization stages, to permit the compiler to generate more efficient code. For instance, <code>fixnum</code> can hold an unboxed integer in a range supported by the hardware and implementation, permitting more efficient arithmetic than on big integers or arbitrary precision types.  Similarly, the compiler can be told on a per-module or per-function basis which type of safety level is wanted, using <i>optimize</i> declarations.\n</p><p>Common Lisp includes CLOS, an object system that supports multimethods and method combinations. It is often implemented with a Metaobject Protocol.\n</p><p>Common Lisp is extensible through standard features such as <i>Lisp macros</i> (code transformations) and <i>reader macros</i> (input parsers for characters).\n</p><p>Common Lisp provides some backwards compatibility to Maclisp and to John McCarthy's original Lisp. This allows older Lisp software to be ported to Common Lisp.</p>\n\n\n",
        "infobox": {
            "name": "Common Lisp",
            "family": "Lisp (programming language)|Lisp",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: procedural programming|procedural",
                "functional programming|functional",
                "object-oriented programming|object-oriented",
                "metaprogramming|meta",
                "reflective programming|reflective",
                "generic programming|generic"
            ],
            "generation": "3GL",
            "released": [
                "1984|p|=|y ",
                "1994|p|=|y for ANSI Common Lisp"
            ],
            "designer": [
                "Scott Fahlman",
                "Richard P. Gabriel",
                "David A. Moon",
                "Kent Pitman",
                "Guy Steele",
                "Dan Weinreb"
            ],
            "developer": "ANSI X3J13 committee",
            "standard reference": "Common Lisp HyperSpec",
            "typing": [
                "Dynamic typing|Dynamic",
                "Strongly-typed programming language|strong"
            ],
            "scope": [
                "Lexical",
                "optionally dynamic"
            ],
            "namespace style": "Lisp-2",
            "implementations": [
                "Allegro Common Lisp|Allegro CL",
                "Armed Bear Common Lisp|ABCL",
                "CLISP",
                "Clozure CL",
                "CMUCL",
                "Embeddable Common Lisp|ECL",
                "GNU Common Lisp|GCL",
                "LispWorks",
                "Scieneer Common Lisp|Scieneer CL",
                "SBCL",
                "Genera (operating system)|Symbolics Common Lisp"
            ],
            "dialects": [
                "CLtL1",
                "CLtL2",
                "ANSI Common Lisp"
            ],
            "influenced_by": [
                "Lisp (programming language)|Lisp",
                "Lisp Machine Lisp",
                "Maclisp",
                "Scheme (programming language)|Scheme",
                "Interlisp"
            ],
            "influenced": [
                "Clojure",
                "Dylan (programming language)|Dylan",
                "Emacs Lisp",
                "EuLisp",
                "ISLISP",
                "*Lisp",
                "AutoLisp",
                "Julia (programming language)|Julia",
                "Moose (Perl)|Moose",
                "R (programming language)|R",
                "Cadence SKILL|SKILL",
                "SubL"
            ],
            "operating_system": "Cross-platform",
            "website": "http://common-lisp.net/",
            "file_ext": [
                ".lisp",
                ".lsp",
                ".l",
                ".cl",
                ".fasl"
            ]
        }
    },
    {
        "id": 118,
        "name": "Comparison of programming languages",
        "url": "https://en.wikipedia.org/wiki/Comparison_of_programming_languages",
        "summary": "<p>Programming languages are used for controlling the behavior of a machine (often a computer). Like natural languages, programming languages conform to rules for syntax and semantics. </p><p>There are thousands of programming languages and new ones are created every year. Few languages ever become sufficiently popular that they are used by more than a few people, but professional programmers may use dozens of languages in a career.\n</p><p>Most programming languages are not standardized by an international (or national) standard, even widely used ones, such as Perl or Standard ML (despite the name). Notable standardized programming languages include ALGOL, C, C++, JavaScript (under the name ECMAScript), Smalltalk, Prolog, Common Lisp, Scheme (IEEE standard), Ada, Fortran, COBOL, SQL and XQuery.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 119,
        "name": "Component Pascal",
        "url": "https://en.wikipedia.org/wiki/Component_Pascal",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Component Pascal</b> is a programming language in the tradition of Niklaus Wirth's Pascal, Modula-2, Oberon and Oberon-2. It bears the name of the Pascal programming language and it preserves its heritage, but it is not compatible with Pascal. Instead, it is a minor variant and refinement of Oberon-2 with a more expressive type system and built-in string support. Component Pascal was originally designed and supported by a small ETH Zürich spin-off company called Oberon microsystems under the name Oberon/L. They developed an IDE (Integrated development environment) called BlackBox Component Builder. Since 2014 development and support has been taken over by a small group of volunteers. At the time the first version of the IDE was released (1994 as <i>Oberon/F</i>) it presented a novel approach to graphical user interface (GUI) construction based on editable forms, where fields and command buttons are linked to exported variables and executable procedures. This approach bears some similarity to the code-behind way used in Microsoft's .NET 3.0 to access code in XAML, which was released in 2008.\n</p><p>An open-source implementation of Component Pascal exists for the .NET and Java Virtual Machine platforms, from the Gardens Point team around John Gough at Queensland University of Technology in Australia.\n</p><p>On 23 June 2004 Oberon microsystems announced that the BlackBox Component Builder was made available as a free download and that an open-source version was planned. The beta open-source version was initially released in December 2004 and updated to a final v1.5 release in December 2005.  It includes the complete source code of the IDE, compiler, debugger, source analyser, profiler and interfacing libraries and can also be downloaded from their website. Several release candidates for v1.6 appeared in the years 2009 – 2011, the latest one (1.6rc6) appeared on Oberon microsystems web pages in 2011. At the end of 2013 Oberon Microsystems released the final release 1.6. It is most probably last release bundled by Oberon Microsystems and a small community took over the ongoing development.\n</p><p>BlackBox Component Pascal uses the extensions .odc (<i>= <b>O</b>beron <b>d</b>o<b>c</b>ument</i>) for document files, such as source files for example, and .osf (<i>= <b>O</b>beron <b>s</b>ymbol <b>f</b>ile</i>) for symbol files while Gardens Point Component Pascal uses .cp for source and .cps for symbol files. BlackBox Component Pascal has its own executable and loadable object format .ocf (<i>= <b>O</b>beron <b>c</b>ode <b>f</b>ile</i>); it includes a runtime linking loader for this format. The document format (.odc) is a rich text binary format, which allows nice formatting, supports conditional folding, and allows active content to be embedded in the source text. It also handles user interface elements in editable  forms. This is in tradition of the Oberon Text format.</p>",
        "infobox": {
            "name": "Component Pascal",
            "paradigm": [
                "imperative programming|imperative",
                "structured programming|structured",
                "modular programming|modular",
                "object-oriented programming|object-oriented"
            ],
            "year": "1997",
            "designer": "Oberon microsystems",
            "typing": [
                "strong typing|strong",
                "static typing|static"
            ],
            "influenced_by": "Oberon-2",
            "website": "http://www.oberon.ch/blackbox.html"
        }
    },
    {
        "id": 120,
        "name": "Computer Sciences Corporation",
        "url": "https://en.wikipedia.org/wiki/Computer_Sciences_Corporation",
        "summary": "<p class=\"mw-empty-elt\">   \n</p>\n\n<p><b>Computer Sciences Corporation</b> (<b>CSC</b>) was an American multinational corporation that provided information technology (IT) services and professional services. On April 3, 2017, it merged with the Enterprise Services line of business of HP Enterprise (formerly Electronic Data Systems) to create DXC Technology.</p>",
        "infobox": {
            "name": "Computer Sciences Corporation",
            "logo": "Image:CSC Logo.svg|220px|The CSC logo since 2008",
            "type": "Public company|Public",
            "traded_as": "NYSE: CSC",
            "founder": "Roy Nutt<br />Fletcher R. Jones",
            "fate": "Mergers and acquisitions|Merged with HP Enterprise Services; formed DXC Technology",
            "successor": "DXC Technology",
            "area_served": "Worldwide",
            "key_people": [
                "John Michael Lawrie<br> small|(Chairman",
                "President and CEO)"
            ],
            "industry": [
                "IT service management|IT services",
                "Information technology consulting|IT consulting"
            ],
            "services": [
                "IT",
                "business consulting and outsourcing services"
            ],
            "subsid": [
                "Computer Sciences Raytheon",
                "Xchanging"
            ],
            "location_city": [
                "Tysons Corner",
                "Virginia"
            ],
            "location_country": "nowrap|United States",
            "foundation": "1959|04",
            "defunct": "End date|2017|04|03"
        }
    },
    {
        "id": 121,
        "name": "Constraint Handling Rules",
        "url": "https://en.wikipedia.org/wiki/Constraint_Handling_Rules",
        "summary": "<p><b>Constraint Handling Rules</b> (<b>CHR</b>) is a declarative, rule-based language, introduced in 1991 by Thom Frühwirth at the time with ECRC (European Computer-Industry Research Centre) in Munich, Germany. Originally intended for constraint programming, CHR finds applications in grammar induction, abductive reasoning, multi-agent systems, natural language processing, compilation, scheduling, spatial-temporal reasoning, testing and verification, and type systems. </p><p>A CHR program, sometimes called a <i>constraint handler</i>, is a set of rules that maintain a <i>constraint store</i>, a multi-set of logical formulas. Execution of rules may add or remove formulas from the store, thus changing the state of the program. The order in which rules \"fire\" on a given constraint store is non-deterministic, according to its <i>abstract semantics</i> and deterministic (top-down rule application), according to its <i>refined semantics</i>.</p><p>Although CHR is Turing complete, it is not commonly used as a programming language in its own right.  Rather, it is used to extend a <i>host language</i> with constraints. Prolog is by far the most popular host language and CHR is included in several Prolog implementations, including SICStus and SWI-Prolog, although CHR implementations also exist for Haskell, Java, C, SQL, and JavaScript. In contrast to Prolog, CHR rules are multi-headed and are executed in a committed-choice manner using a forward chaining algorithm.\n</p>",
        "infobox": {
            "paradigm": "Constraint logic programming",
            "year": "1991",
            "designer": "Thom Frühwirth",
            "influenced by": "Prolog"
        }
    },
    {
        "id": 122,
        "name": "Cool (programming language)",
        "url": "https://en.wikipedia.org/wiki/Cool_(programming_language)",
        "summary": "<p><b>Cool</b>, an acronym for <b>Classroom Object Oriented Language</b>, is a computer programming language designed by Alexander Aiken for use in an undergraduate compiler course project. While small enough for a one term project, Cool still has many of the features of modern programming languages, including objects, automatic memory management, strong static typing and simple reflection. </p><p>The reference Cool compiler is written in C++, built fully on the public domain tools. It generates code for a MIPS simulator, SPIM. Thus, the language should port easily to other platforms. It has been used for teaching compilers at many institutions (such as the University of California at Berkeley, where it was first used or Shahid Beheshti University of Iran) and the software is stable.\n</p><p>This language is unrelated to the COOL language included in CLIPS.\n</p>",
        "infobox": {
            "name": "COOL",
            "paradigm": "Object-oriented programming language|Object-oriented",
            "year": "1996",
            "designer": "Alexander Aiken",
            "developer": "Alexander Aiken",
            "typing": [
                "Type system|Static",
                "Strongly-typed programming language|strong",
                "Manifest typing|manifest"
            ],
            "dialects": [
                "Cool 2004",
                "Cool 2005",
                "Cool 2006",
                "Cool 2007",
                "Cool 2008",
                "unCool"
            ],
            "influenced_by": [
                "Java (programming language)|Java",
                "ML (programming language)|ML",
                "Pascal (programming language)|Pascal",
                "Sather"
            ]
        }
    },
    {
        "id": 123,
        "name": "Coq",
        "url": "https://en.wikipedia.org/wiki/Coq",
        "summary": "<p><b>Coq</b> is an interactive theorem prover first released in 1989. It allows for the expression of mathematical assertions, mechanically checks proofs of these assertions, helps to find formal proofs, and extracts a certified program from the constructive proof of its formal specification. Coq works within the theory of the calculus of inductive constructions, a derivative of the calculus of constructions. Coq is not an automated theorem prover but includes automatic theorem proving tactics (procedures) and various decision procedures. </p><p>The Association for Computing Machinery rewarded Thierry Coquand, Gérard Huet, Christine Paulin-Mohring, Bruno Barras, Jean-Christophe Filliâtre, Hugo Herbelin, Chetan Murthy, Yves Bertot, and Pierre Castéran with the 2013 ACM Software System Award for Coq.\n</p><p>Coq is named after its principal developer, Thierry Coquand.</p>",
        "infobox": {
            "name": "Coq (software)",
            "logo": "Coq logo.png",
            "developer": "The Coq development team",
            "released": "1989|5|1 (version 4.10)",
            "latest release version": "8.11.2",
            "latest release date": "start date and age|2020|06|09",
            "latest preview version": "8.12+beta1",
            "latest preview date": "start date and age|2020|06|17",
            "operating system": "Cross-platform",
            "language": "English",
            "programming language": "OCaml",
            "genre": "Proof assistant",
            "license": "GNU Lesser General Public License|LGPLv2.1",
            "website": "url|https://coq.inria.fr/",
            "repo": "url|https://github.com/coq/coq"
        }
    },
    {
        "id": 124,
        "name": "CorVision",
        "url": "https://en.wikipedia.org/wiki/CorVision",
        "summary": "<p><b>CorVision</b> is a fourth generation programming tool (4GL) currently owned by Attunity, Inc. CorVision was developed by Cortex Corporation for the VAX/VMS ISAM environment. Although Cortex beta tested CorVision-10 which was generated for PCs but CorVision itself stayed anchored on VMS. CorVision-10 proved more difficult than hoped, and was never released. </p>",
        "infobox": {
            "name": "CorVision",
            "released": "1986",
            "developer": "Cortex",
            "influenced by": "Inform"
        }
    },
    {
        "id": 125,
        "name": "Coral 66",
        "url": "https://en.wikipedia.org/wiki/Coral_66",
        "summary": "<p class=\"mw-empty-elt\"> \n</p>\n<p><b>CORAL</b> (<b>Computer On-line Real-time Applications Language</b>) is a programming language originally developed in 1964 at the Royal Radar Establishment (RRE), Malvern, Worcestershire, United Kingdom (UK). It was influenced by ALGOL and JOVIAL, but is not a subset of either. Coral 66 was subsequently developed by I. F. Currie and M. Griffiths under the auspices of the <i>Inter-Establishment Committee for Computer Applications</i> (IECCA). Its official definition, edited by Woodward, Wetherall, and Gorman, was first published in 1970.</p>",
        "infobox": {
            "name": "Coral 66",
            "paradigms": [
                "Procedural programming|procedural",
                "Imperative programming language|imperative",
                "Structured programming|structured"
            ],
            "family": "ALGOL",
            "designers": [
                "Philip Woodward",
                "I. F. Currie",
                "M. Griffiths"
            ],
            "developer": "Royal Radar Establishment",
            "released": "1964",
            "typing": [
                "Static type|Static",
                "Strong and weak typing|strong"
            ],
            "scope": "Scope (computer science)|Lexical",
            "programming language": "BCPL",
            "platform": [
                "Computer Technology Limited|CTL Computer Technology Limited#Modular One|Modular-1",
                "DEC Alpha",
                "General Electric Company|GEC",
                "Ferranti",
                "Honeywell",
                "HP Integrity",
                "Interdata 8/32",
                "PDP-11",
                "SPARC",
                "VAX",
                "x86"
            ],
            "operating system": [
                "OpenVMS|VAX/VMS; Berkeley Software Distribution|BSD Unix",
                "Linux",
                "Solaris (operating system)|Solaris"
            ],
            "influenced by": [
                "ALGOL",
                "JOVIAL",
                "Fortran"
            ]
        }
    },
    {
        "id": 126,
        "name": "Core War",
        "url": "https://en.wikipedia.org/wiki/Core_War",
        "summary": "<p><i><b>Core War</b></i> is a 1984 programming game created by D. G. Jones and A. K. Dewdney in which two or more battle programs (called \"warriors\") compete for control of a virtual computer. These battle programs are written in an abstract assembly language called <i>Redcode</i>. </p>",
        "infobox": {
            "title": "Core War",
            "image": "File:Core War PMars Screenshot.png|Core War screenshot",
            "caption": "A game of Core War running under the pMARS simulator",
            "developer": "D. G. Jones & A. K. Dewdney",
            "released": "March 1984",
            "genre": "Programming game"
        }
    },
    {
        "id": 127,
        "name": "Cryptol",
        "url": "https://en.wikipedia.org/wiki/Cryptol",
        "summary": "<p><b>Cryptol</b> is a domain specific programming language for cryptography developed by the Portland, Oregon based software development firm, Galois, Inc.. The language was originally developed for use by the United States National Security Agency. The language is also used by private firms that provide information technology systems, such as the American company Rockwell Collins provides to aerospace and defense contractors in the United States.</p><p>The programming language is used for all aspects of developing and using cryptography, such as the design and implementation of new ciphers and the verification of existing cryptographic algorithms.  Cryptol is designed to allow the cryptographer to watch how stream processing functions in the program manipulate the ciphers or encryption algorithms.</p>\n",
        "infobox": "N/A"
    },
    {
        "id": 128,
        "name": "Crystal (programming language)",
        "url": "https://en.wikipedia.org/wiki/Crystal_(programming_language)",
        "summary": "<p><b>Crystal</b> is a general-purpose, object-oriented programming language, designed and developed by Ary Borenszweig, Juan Wajnerman, Brian Cardiff and more than 300 contributors. With syntax inspired by the language Ruby, it is a compiled language with static type-checking, but specifying the types of variables or method arguments is generally unneeded. Types are resolved by an advanced global type inference algorithm. Crystal  is currently in active development. It is released as free and open-source software under the Apache License version 2.0.\n</p>",
        "infobox": {
            "name": "Crystal",
            "logo": "Crystal language logo.svg",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: Object-oriented programming|object-oriented",
                "Concurrent computing|concurrent"
            ],
            "released": "2014|06|18",
            "designer": [
                "Ary Borenszweig",
                "Juan Wajnerman",
                "Brian Cardiff"
            ],
            "developer": "Manas Technology Solutions",
            "latest preview version": "0.35.1",
            "latest preview date": "2020|06|19",
            "typing": [
                "Type system#Static type checking|static",
                "Type system#Inferred type checking|inferred",
                "Type system#structural type system|structural",
                "Type system#duck typing|duck"
            ],
            "influenced by": [
                "Ruby (programming language)|Ruby",
                "C (programming language)|C",
                "Rust (programming language)|Rust",
                "Go (programming language)|Go",
                "C Sharp (programming language)|C#",
                "Python (programming language)|Python"
            ],
            "programming language": "Crystal",
            "platform": [
                "IA-32 (i386)",
                "x86-64",
                "AArch64"
            ],
            "operating system": [
                "Linux",
                "macOS",
                "FreeBSD",
                "OpenBSD"
            ],
            "license": "Apache License 2.0",
            "file ext": ".cr",
            "website": "https://crystal-lang.org"
        }
    },
    {
        "id": 129,
        "name": "Csound",
        "url": "https://en.wikipedia.org/wiki/Csound",
        "summary": "<p><b>Csound</b> is a Domain-specific computer programming language for audio programming. It is called Csound because it is written in C, as opposed to some of its predecessors. </p><p>It is free software, available under the LGPL.\n</p><p>Csound was originally written at MIT by Barry Vercoe in 1985, based on his earlier system called Music 11, which in its turn followed the MUSIC-N model initiated by Max Mathews at the Bell Labs. \nIts development continued throughout\nthe 1990s and 2000s, led by John Fitch at the University of Bath. \nThe first documented version 5 release is version 5.01 on March 18, 2006. \nMany developers have contributed to it, most notably Istvan Varga, Gabriel Maldonado, Robin Whittle, Richard Karpen, Iain McCurdy, Michael Gogins, Matt Ingalls,  Steven Yi, Richard Boulanger, and Victor Lazzarini.\n</p><p>Developed over many years, it currently has nearly 1700 unit generators. \nOne of its greatest strengths is that it is completely modular and extensible by the user. \nCsound is closely related to the underlying language for the Structured Audio extensions to MPEG-4, SAOL.\n</p>",
        "infobox": {
            "name": "Csound",
            "released": "1986|df|=|yes/no",
            "status": "Active",
            "latest release version": "6.13.0",
            "latest release date": "release date|2019|7|12",
            "operating system": "Cross-platform",
            "programming language": "C (programming language)|C",
            "license": "GNU Lesser General Public License|LGPL",
            "website": "csound.com"
        }
    },
    {
        "id": 130,
        "name": "Cuneiform (programming language)",
        "url": "https://en.wikipedia.org/wiki/Cuneiform_(programming_language)",
        "summary": "<p><b>Cuneiform</b> is an open-source workflow language for large-scale scientific data analysis.\nIt is a statically typed functional programming language promoting parallel computing. It features a versatile foreign function interface allowing users to integrate software from many external programming languages. At the organizational level Cuneiform provides facilities like conditional branching and general recursion making it Turing-complete. In this, Cuneiform is the attempt to close the gap between scientific workflow systems like Taverna, KNIME, or Galaxy and large-scale data analysis programming models like MapReduce or Pig Latin while offering the generality of a functional programming language.\n</p><p>Cuneiform is implemented in distributed Erlang. If run in distributed mode it drives a POSIX-compliant distributed file system like Gluster or Ceph (or a FUSE integration of some other file system, e.g., HDFS). Alternatively, Cuneiform scripts can be executed on top of HTCondor or Hadoop.</p><p>Cuneiform is influenced by the work of Peter Kelly who proposes functional programming as a model for scientific workflow execution.\nIn this, Cuneiform is distinct from related workflow languages based on dataflow programming like Swift.</p>",
        "infobox": {
            "name": "Cuneiform",
            "logo": "G18225.png",
            "screenshot": "Cf screenshot.jpg",
            "caption": "Screenshot of the Cuneiform editor and command line shell",
            "paradigm": [
                "functional programming|functional",
                "Scientific workflow system|scientific workflow"
            ],
            "designer": "Jörgen Brandt",
            "status": "Active",
            "latest release version": "3.0.3",
            "latest release date": "release date|2018|04|17",
            "typing": "simple types",
            "influenced_by": "Swift (parallel scripting language)|Swift",
            "operating system": [
                "Linux",
                "Mac OS"
            ],
            "programming language": "Erlang (programming language)|Erlang",
            "license": "Apache License 2.0",
            "website": "https://cuneiform-lang.org/",
            "file_ext": ".cfl",
            "year": "2013"
        }
    },
    {
        "id": 131,
        "name": "Curl (programming language)",
        "url": "https://en.wikipedia.org/wiki/Curl_(programming_language)",
        "summary": "<p><b>Curl</b> is a reflective object-oriented programming language for interactive web applications whose goal is to provide a smoother transition between formatting and programming. It makes it possible to embed complex objects in simple documents without needing to switch between programming languages or development platforms. The Curl implementation initially consisted of just an interpreter, but a compiler was added later. </p><p>Curl combines text markup (as in HTML), scripting (as in JavaScript), and heavy-duty computing (as in Java, C#, or C++) within one unified framework.  It is used in a range of internal enterprise, B2B, and B2C applications.\n</p><p>Curl programs may be compiled into Curl applets, that are viewed using the Curl RTE, a runtime environment with a plugin for web browsers. Currently, it is supported on Microsoft Windows. Linux, and macOS was dropped on March 25, 2019. Curl supports \"detached applets\", which is a web deployed applet which runs on the user's desktop independent of a browser window much as in Silverlight 3 and Adobe AIR.\n</p><p>SCSK announced on 2019-03-25 that Curl will stop new releases on Linux and MacOS, which means Curl will no longer run over Linux and MacOS from version 8.0.8 .\n</p>",
        "infobox": {
            "name": "Curl",
            "logo": "File:Curl logo.gif",
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Object-oriented programming|object-oriented",
                "markup language|markup"
            ],
            "year": "1998",
            "designer": [
                "Steve Ward (computer scientist)|Steve Ward",
                "Massachusetts Institute of Technology|MIT"
            ],
            "developer": [
                "Curl",
                "Inc.",
                "Sumisho Computer Systems Corp.",
                "SCSK Corporation"
            ],
            "latest_release_version": "8.0.10",
            "latest release date": "2019|08|30",
            "typing": "strong typing|strong",
            "dialects": "none",
            "influenced_by": [
                "HTML",
                "JavaScript",
                "Lisp (programming language)|Lisp"
            ],
            "operating_system": "Microsoft Windows|Windows",
            "website": "www.curl.com",
            "wikibooks": "Curl"
        }
    },
    {
        "id": 132,
        "name": "Curry (programming language)",
        "url": "https://en.wikipedia.org/wiki/Curry_(programming_language)",
        "summary": "<p><b>Curry</b> is an experimental functional logic programming language, based on the Haskell language. It merges elements of functional and logic programming, including constraint programming integration. </p><p>It is nearly a superset of Haskell, lacking support mostly for overloading using type classes, which some implementations provide anyway as a language extension, such as the Münster Curry Compiler.</p>",
        "infobox": {
            "name": "Curry",
            "paradigm": [
                "functional programming|functional",
                "logic programming|logic",
                "non-strict",
                "modular"
            ],
            "designer": [
                "Michael Hanus",
                "Sergio Antoy",
                "et al."
            ],
            "typing": [
                "static typing|static",
                "strong typing|strong",
                "type inference|inferred"
            ],
            "implementations": [
                "[http://www.informatik.uni-kiel.de/~pakcs PAKCS] (with Prolog (programming language)|Prolog as the target)",
                "[http://danae.uni-muenster.de/curry/ mcc] (with C (programming language)|C as the target)",
                "[http://www-ps.informatik.uni-kiel.de/kics2/ KiCS2] (with Haskell (programming language)|Haskell as the target)"
            ],
            "influenced by": "Haskell (programming language)|Haskell and Prolog (programming language)|Prolog",
            "operating_system": "portable",
            "website": "[http://curry-language.org/ Curry]"
        }
    },
    {
        "id": 133,
        "name": "Cybil (programming language)",
        "url": "https://en.wikipedia.org/wiki/Cybil_(programming_language)",
        "summary": "<p><b>Cybil</b> (short for the <b>Cyber Implementation Language of the Control Data Network Operating System</b>) was a Pascal-like language developed at Control Data Corporation for the Cyber computer family.  Cybil was used as the implementation language for the NOS/VE operating system on the CDC Cyber series and was also used to write the eOS operating system for the ETA10 supercomputer in the 1980s. </p>",
        "infobox": "N/A"
    },
    {
        "id": 134,
        "name": "Cyclone (programming language)",
        "url": "https://en.wikipedia.org/wiki/Cyclone_(programming_language)",
        "summary": "<p>The <b>Cyclone</b> programming language is intended to be a safe dialect of the C language. Cyclone is designed to avoid buffer overflows and other vulnerabilities that are possible in C programs, without losing the power and convenience of C as a tool for system programming. </p><p>Cyclone development was started as a joint project of AT&amp;T Labs Research and Greg Morrisett's group at Cornell in 2001. Version 1.0 was released on May 8, 2006.\n</p>",
        "infobox": {
            "name": "Cyclone",
            "released": "start date|2002",
            "designer": "AT&T Labs",
            "latest release version": "1.0",
            "latest release date": "start date and age|2006|05|08",
            "influenced by": "C (programming language)|C",
            "influenced": "Rust (programming language)|Rust",
            "website": "http://cyclone.thelanguage.org",
            "discontinued": "yes"
        }
    },
    {
        "id": 135,
        "name": "Cypher Query Language",
        "url": "https://en.wikipedia.org/wiki/Cypher_(query_language)",
        "summary": "<p><b>Cypher</b> is a declarative graph query language that allows for expressive and efficient data querying in a property graph.</p><p>Cypher was largely an invention of Andrés Taylor while working for Neo4j, Inc. (formerly Neo Technology) in 2011. Cypher was originally intended to be used with the graph database Neo4j, but was opened up through the openCypher project in October 2015.</p><p>The language was designed with the power and capability of SQL (standard query language for the relational database model) in mind, but Cypher was based on the components and needs of a database built upon the concepts of graph theory. In a graph model, data is structured as nodes (vertices in math and network science) and relationships (edges in math and network science) to focus on how entities in the data are connected and related to one another. </p>",
        "infobox": "N/A"
    },
    {
        "id": 136,
        "name": "Cython",
        "url": "https://en.wikipedia.org/wiki/Cython",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Cython</b> is a programming language that aims to be a superset of the Python programming language, designed to give C-like performance with code that is written mostly in Python with optional additional C-inspired syntax.</p><p>Cython is a compiled language that is typically used to generate CPython extension modules. Annotated Python-like code is compiled to C or C++ then automatically wrapped in interface code, producing extension modules that can be loaded and used by regular Python code using the import statement, but with significantly less computational overhead at run time. Cython also facilitates wrapping independent C or C++ code into python-importable modules.\n</p><p>Cython is written in Python and C and works on Windows, macOS, and Linux, producing source files compatible with CPython 2.6, 2.7, and 3.3 through 3.8.\n</p><p>Cython 3.0.0 is in development.</p>\n\n\n",
        "infobox": {
            "name": "Cython",
            "logo": "Cython-logo.svg",
            "developer": [
                "Robert Bradshaw",
                "Stefan Behnel",
                "et al."
            ],
            "released": "df|=|yes|2007|07|28",
            "programming language": [
                "Python (programming language)|Python",
                "C (programming language)|C"
            ],
            "genre": "Programming language",
            "license": "Apache License 2.0",
            "website": "official URL"
        }
    },
    {
        "id": 137,
        "name": "Céu (programming language)",
        "url": "https://en.wikipedia.org/wiki/C%C3%A9u_(programming_language)",
        "summary": "<p><b>Céu</b> is \"Structured Synchronous Reactive Programming\"  According to its web page, Céu supports synchronous concurrency with shared memory and deterministic execution and has a small memory footprint.</p>",
        "infobox": "N/A"
    },
    {
        "id": 138,
        "name": "DATATRIEVE",
        "url": "https://en.wikipedia.org/wiki/DATATRIEVE",
        "summary": "<p><b>DATATRIEVE</b> is a database query and report writer tool from Hewlett-Packard. It runs on the OpenVMS operating system, as well as several PDP-11 operating systems.  DATATRIEVE's command structure is nearly plain English, and it is an early example of a Fourth Generation Language (4GL).  </p>",
        "infobox": {
            "name": "DATATRIEVE",
            "developer": "Hewlett-Packard",
            "latest release version": "7.3",
            "operating system": "OpenVMS,<br />PDP-11 operating systems",
            "language": "English"
        }
    },
    {
        "id": 139,
        "name": "DBase",
        "url": "https://en.wikipedia.org/wiki/DBase",
        "summary": "<p><span></span> </p>\n<p><b>dBase</b> (also stylized <b>dBASE</b>) was one of the first database management systems for microcomputers, and the most successful in its day. The dBase system includes the core database engine, a query system, a forms engine, and a programming language that ties all of these components together. dBase's underlying file format, the <span>.dbf</span> file, is widely used in applications needing a simple format to store structured data.\n</p><p>Originally released as <b>Vulcan</b> for PTDOS in 1978, the CP/M port caught the attention of Ashton-Tate in 1980. They licensed it and re-released it as <b>dBASE II</b>, and later ported to Apple II and IBM PC computers running DOS. On the PC platform, in particular, dBase became one of the best-selling software titles for a number of years. A major upgrade was released as <b>dBase III</b>, and ported to a wider variety of platforms, adding UNIX, and VMS. By the mid-1980s, Ashton-Tate was one of the \"big three\" software publishers in the early business software market, the others being Lotus Development and WordPerfect.\n</p><p>Starting in the mid-1980s, several companies produced their own variations on the dBase product and especially the dBase programming language. These included FoxBASE+ (later renamed FoxPro), Clipper, and other so-called xBase products. Many of these were technically stronger than dBase, but could not push it aside in the market. This changed with the disastrous introduction of <b>dBase IV</b>, whose design and stability were so poor that many users switched to other products. At the same time, there was growing use of IBM-invented SQL (Structured Query Language) in database products. Another factor was user adoption of Microsoft Windows on desktop computers. The shift toward SQL and Windows put pressure on the makers of xBase products to invest in major redesign to provide new capabilities.\n</p><p>In the early 1990s xBase products constituted the leading database platform for implementing business applications. The size and impact of the xBase market did not go unnoticed, and within one year, the three top xBase firms were acquired by larger software companies:\n</p>\n<ul><li>Borland purchased Ashton-Tate</li>\n<li>Microsoft bought Fox Software, and</li>\n<li>Computer Associates acquired Nantucket.</li></ul><p>By the following decade most of the original xBase products had faded from prominence and several disappeared. Products known as dBase still exist, owned by dBase LLC.\n</p>",
        "infobox": {
            "logo": "DBaseLogo BlackWithRed glass 300.png",
            "paradigm": [
                "Imperative programming|Imperative",
                "Declarative programming|declarative"
            ],
            "developer": "C. Wayne Ratliff|Cecil Wayne Ratliff",
            "released": "1979",
            "latest release version": "dBASE PLUS 11",
            "latest release date": "2016|12|14|df|=|yes/no",
            "programming language": "C (programming language)|C",
            "operating system": "Microsoft DOS<br>Microsoft Windows",
            "license": "Proprietary software|Proprietary",
            "website": "www.dbase.com",
            "influenced": [
                "Clipper (programming language)|Clipper",
                "WordTech products",
                "Harbour (software)|Harbour. FoxPro|FoxBASE+",
                "FoxPro",
                "Visual FoxPro",
                "VP-Info"
            ]
        }
    },
    {
        "id": 140,
        "name": "DIBOL",
        "url": "https://en.wikipedia.org/wiki/DIBOL",
        "summary": "<p><b>DIBOL</b> or <b>Digital's Business Oriented Language</b> is a general-purpose, procedural, imperative programming language, designed for use in Management Information Systems (MIS) software development. It has a syntax similar to FORTRAN and BASIC, along with BCD arithmetic. It shares the COBOL program structure of data and procedure divisions. </p>",
        "infobox": {
            "name": "DIBOL",
            "paradigm": [
                "procedural programming|procedural",
                "Imperative programming language|imperative",
                "structured programming|structured"
            ],
            "year": "1970",
            "developer": "Digital Equipment Corporation|DEC",
            "latest_release_version": "DIBOL 1992",
            "latest_release_date": "2002",
            "typing": "Type system#Static type-checking|static",
            "implementations": [
                "Synergex DBL",
                "DEC VAX DIBOL",
                "others"
            ],
            "influenced_by": [
                "BASIC",
                "Fortran",
                "COBOL"
            ]
        }
    },
    {
        "id": 141,
        "name": "DIGITAL Command Language",
        "url": "https://en.wikipedia.org/wiki/DIGITAL_Command_Language",
        "summary": "<p><b>DIGITAL Command Language</b> (<b>DCL</b>) is the standard command language adopted by most of the operating systems (OSs) that were sold by the former Digital Equipment Corporation (which was acquired by Compaq, which was in turn acquired by Hewlett-Packard). DCL had its roots in the IAS, TOPS-20, and RT-11 OSs and was implemented as a standard across most of Digital's OSs, notably RSX-11, but took its most powerful form in the OpenVMS OS.\n</p><p>Written when the programming language Fortran was in heavy use, DCL is a scripting language supporting several datatypes, including strings, integers, bit arrays, arrays and booleans, but not floating point numbers. Access to OpenVMS <i>system services</i> (kernel API) is through lexical functions, which perform the same as their compiled language counterparts and allow scripts to get information on system state. DCL includes IF-THEN-ELSE, access to all the Record Management Services (RMS) file types including stream, indexed, and sequential, but unfortunately lacks a DO-WHILE or other looping construct, requiring users to make do with IF and GOTO-label statements instead.\n</p><p>DCL is available for other operating systems as well, including \n</p>\n<ul><li>VCL and VX/DCL for Unix,</li>\n<li>VCL for MS-DOS, OS/2 and Windows,</li>\n<li>PC-DCL and Open DCL for Windows/Linux</li>\n<li>and Accelr8 DCL Lite for Windows.</li></ul><p>DCL is the basis of the XLNT language, implemented on Windows by an interpreter-IDE-WSH engine combination with CGI capabilities distributed by Advanced System Concepts Inc. from 1997.\n</p>",
        "infobox": {
            "name": "DIGITAL Command Language",
            "paradigm": "Imperative programming|imperative",
            "designer": "Digital Equipment Corporation",
            "developer": "Digital Equipment Corporation",
            "influenced": "Windows PowerShell",
            "operating system": [
                "RSTS/E",
                "RSX-11",
                "RT-11",
                "OpenVMS",
                "VAXELN"
            ]
        }
    },
    {
        "id": 142,
        "name": "DRAKON",
        "url": "https://en.wikipedia.org/wiki/DRAKON",
        "summary": "<p><b>DRAKON</b> is an algorithmic visual programming and modeling language developed within the Buran space project following ergonomic design principles. The language provides a uniform way to represent flowcharts of any complexity that are easy to read and understand. </p><p>The DRAKON Editor, which was released in September 2011, is an implementation of the language available in the public domain. It can be used for creating documentation, or for creating visual programs that can be converted to source code in other languages.\n</p><p>Unlike UML's philosophy, DRAKON's language philosophy is based on being augmented if needed, by using a hybrid language, which can be illustrated as \"incrustating code snippets from text language used into shape DRAKON requires\". This way, DRAKON always remains a simple visual language that can be used as an augmentation for a programmer who is interested in making their own project code easier to support or other long-term needs for example improving the ergonomics of the coding process or to making code easier to review and understand.\n</p><p>The name DRAKON is the Russian acronym for \"Дружелюбный Русский Алгоритмический [язык], Который Обеспечивает Наглядность\", which translates to \"Friendly Russian algorithmic [language] that illustrates (or provides clarity)\". \nThe word \"наглядность\" (pronounced approximately as \"naa-glya-dno-st-th\") refers to a concept or idea being easy to imagine and understand, and may be translated as \"clarity\".\n</p><p>The DRAKON language can be used both as a modelling/\"markup\" language (which is considered a standalone \"pure DRAKON\" program) and as a programming language (as part of a hybrid language).\n</p><p>Integration of a stricter, \"academic\", variant of a markup language into programming, such as provided by DRAKON, adds syntactic sugar allowing users of different programming languages to comprehend each other's contributions to the overall project and even provide commentary if needed.\n</p>",
        "infobox": {
            "name": "DRAKON",
            "paradigm": "Visual programming language|visual",
            "class": "defined by the second language that is part of the selected hybrid language",
            "year": "1996",
            "extension": [
                ".drt",
                ".drn"
            ],
            "typing": "defined by the second language that is part of the selected hybrid language",
            "implementations": [
                "GRAFIT-FLOKS (1996)",
                "IS Drakon (2008)",
                "DRAKON Editor (2011)",
                "DrakonHub (2018)",
                "Drakon.Tech (2019)"
            ],
            "influenced_by": [
                "PROL2",
                "DIPOL",
                "LAKS"
            ],
            "influenced": "QReal DSM platform",
            "website": "http://drakon-editor.sourceforge.net/"
        }
    },
    {
        "id": 143,
        "name": "DYNAMO (programming language)",
        "url": "https://en.wikipedia.org/wiki/DYNAMO_(programming_language)",
        "summary": "<p><b>DYNAMO</b> (<b>DYNAmic MOdels</b>) is a historically important simulation language and accompanying graphical notation developed within the system dynamics analytical framework.  It was originally for industrial dynamics but was soon extended to other applications, including population and resource studies and urban planning.</p><p>DYNAMO was initially developed under the direction of Jay Wright Forrester in the late 1950s, by Dr. Phyllis Fox,\nAlexander L. Pugh III, Grace Duren,\nand others\nat the M.I.T. Computation Center.</p><p>DYNAMO was used for the system dynamics simulations of global resource-depletion reported in the Club of Rome's Limits to Growth, but has since fallen into disuse.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 144,
        "name": "D (programming language)",
        "url": "https://en.wikipedia.org/wiki/D_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>D</b>, also known as <b>Dlang</b>, is a multi-paradigm system programming language created by Walter Bright at Digital Mars and released in 2001. Andrei Alexandrescu joined the design and development effort in 2007. Though it originated as a re-engineering of C++, D is a distinct language. It has redesigned some core C++ features, while also sharing characteristics of other languages, notably Java, Python, Ruby, C#, and Eiffel.\n</p><p>The design goals of the language attempted to combine the performance and safety of compiled languages with the expressive power of modern dynamic languages. Idiomatic D code is commonly as fast as equivalent C++ code, while also being shorter.  The language as a whole is not memory-safe but does include optional attributes designed to check memory safety.</p><p>Type inference, automatic memory management and syntactic sugar for common types allow faster development, while bounds checking, design by contract features and a concurrency-aware type system help reduce the occurrence of bugs.</p>",
        "infobox": {
            "name": "D programming language",
            "logo": "D Programming Language logo.svg",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: functional programming|functional",
                "imperative programming|imperative",
                "object-oriented programming|object-oriented"
            ],
            "released": "start date and age|df|=|no|2001|12|08",
            "designer": [
                "Walter Bright",
                "Andrei Alexandrescu (since 2007)"
            ],
            "developer": "D Language Foundation",
            "typing": [
                "Inferred typing|Inferred",
                "static typing|static",
                "strong typing|strong"
            ],
            "implementations": [
                "[https://github.com/dlang/dmd DMD] (reference implementation)",
                "[https://gcc.gnu.org/ GCC]",
                "[https://github.com/ldc-developers/ldc LDC]",
                "[https://github.com/SDC-Developers/SDC SDC]"
            ],
            "influenced": [
                "Genie (programming language)|Genie",
                "MiniD",
                "Qore (programming language)|Qore",
                "Swift (programming language)|Swift",
                "Vala (programming language)|Vala",
                "C++11",
                "C++14",
                "C++17",
                "C++20",
                "Go (programming language)|Go",
                "C Sharp (programming language)|C#",
                "and others."
            ],
            "license": "Boost Software License|Boost",
            "website": "//dlang.org",
            "wikibooks": "D Programming",
            "file_ext": "<code>.d</code>",
            "latest_release_version": "2.093.0",
            "latest_release_date": "df|=|no|2020|07|07",
            "influenced_by": [
                "C (programming language)|C",
                "C++",
                "C Sharp (programming language)|C#",
                "Eiffel (programming language)|Eiffel",
                "Java (programming language)|Java",
                "Python (programming language)|Python"
            ],
            "operating_system": [
                "FreeBSD",
                "Linux",
                "macOS",
                "Microsoft Windows|Windows"
            ]
        }
    },
    {
        "id": 145,
        "name": "Dart (programming language)",
        "url": "https://en.wikipedia.org/wiki/Dart_(programming_language)",
        "summary": "<p><b>Dart</b> is a client-optimized programming language for apps on multiple platforms. It is developed by Google and is used to build mobile, desktop, server, and web applications.</p><p>Dart is an object-oriented, class-based, garbage-collected language with C-style syntax. Dart can compile to either native code or JavaScript. It supports interfaces, mixins, abstract classes, reified generics, and type inference.</p>",
        "infobox": {
            "title": "Dart",
            "logo": "Dart programming language logo.svg",
            "paradigm": [
                "Multi-paradigm: functional programming|functional",
                "imperative programming|imperative",
                "object-oriented programming|object-oriented",
                "reflection (computer programming)|reflective"
            ],
            "released": "2011|10|10",
            "designer": "Lars Bak (computer programmer)|Lars Bak and Kasper Lund",
            "developer": "Google",
            "latest release version": "2.8.4",
            "latest release date": "2020|06|03",
            "latest preview version": "2.9.0-13.0.dev",
            "latest preview date": "2020|05|29",
            "typing": [
                "1.x: Optional typing|Optional<br>2.x: Type inference|Inferred (static typing|static",
                "strong typing|strong)"
            ],
            "implementations": [
                "Dart VM",
                "dart2native",
                "dart2js",
                "DDC",
                "Flutter (software)|Flutter"
            ],
            "influenced by": [
                "C (programming language)|C",
                "C Sharp (programming language)|C#",
                "Erlang (programming language)|Erlang",
                "Java (programming language)|Java",
                "JavaScript",
                "Kotlin (programming language)|Kotlin",
                "Ruby (programming language)|Ruby",
                "Smalltalk",
                "Strongtalk",
                "TypeScript"
            ],
            "platform": "Cross-platform",
            "operating system": "Cross-platform",
            "license": "BSD licenses|BSD",
            "website": "dart.dev",
            "file ext": ".dart"
        }
    },
    {
        "id": 146,
        "name": "Darwin (programming language)",
        "url": "https://en.wikipedia.org/wiki/Darwin_(programming_language)",
        "summary": "<p>Darwin is a closed source programming language developed by Gaston Gonnet and colleagues at ETH Zurich.  It is used to develop the OMA orthology inference software, which was also initially developed by Gonnet. The language backend consists of the kernel, responsible for performing simple mathematical calculations, for transporting and storing data and for interpreting the user's commands, and the library, a set of programs which can perform more complicated calculations. The target audience for the language is the biosciences, so the library consisted of routines such as those to compute pairwise alignments, phylogenetic trees, multiple sequence alignments, and to make secondary structure predictions. </p>",
        "infobox": {
            "file_ext": [
                ".drw",
                "(none)"
            ],
            "paradigm": [
                "Imperative programming|imperative",
                "Structured programming|structured",
                "Object-oriented programming|object-oriented"
            ],
            "released": "1991",
            "designer": "Gaston Gonnet",
            "typing": [
                "Dynamic_typing|Dynamic",
                "Strong_and_weak_typing|Strong"
            ],
            "influenced_by": "Maple (software)|Maple"
        }
    },
    {
        "id": 147,
        "name": "DataFlex",
        "url": "https://en.wikipedia.org/wiki/DataFlex",
        "summary": "<p><b>DataFlex</b> is an object-oriented high-level programming language and a fourth generation visual tool 4GL for developing Windows, web and mobile software applications on one framework-based platform. It was introduced and developed by <i>Data Access Corporation</i> beginning in 1982. </p>",
        "infobox": {
            "screenshot": "DF Logo Compact RGB.png",
            "developer": "Data Access Worldwide",
            "latest release version": "19.1.",
            "latest release date": "2019|04|10",
            "operating system": "Microsoft Windows",
            "genre": [
                "Object-oriented programming|Object-oriented",
                "Integrated development environment",
                "programming language",
                "application framework",
                "Structured programming|structured",
                "Imperative programming|imperative"
            ],
            "license": "Commercial software|Commercial proprietary software",
            "website": "www.DataAccess.com/DataFlex"
        }
    },
    {
        "id": 148,
        "name": "Data analysis expressions",
        "url": "https://en.wikipedia.org/wiki/Data_analysis_expressions",
        "summary": "<p><b>Data Analysis Expressions</b> (<b>DAX</b>) is the native formula and query language for Microsoft PowerPivot, Power BI Desktop and SQL Server Analysis Services (SSAS) Tabular models. DAX includes some of the functions that are used in Excel formulas with additional functions that are designed to work with relational data and perform dynamic aggregation. It is, in part, an evolution of the Multidimensional Expression (MDX) language developed by Microsoft for Analysis Services multidimensional models (often called cubes) combined with Excel formula functions. It is designed to be simple and easy to learn, while exposing the power and flexibility of PowerPivot and SSAS tabular models. </p>",
        "infobox": "N/A"
    },
    {
        "id": 149,
        "name": "Datalog",
        "url": "https://en.wikipedia.org/wiki/Datalog",
        "summary": "<p><b>Datalog</b> is a declarative logic programming language that syntactically is a subset of Prolog.  It is often used as a query language for deductive databases.  In recent years, Datalog has found new application in data integration, information extraction, networking, program analysis, security, cloud computing and machine learning.</p><p>Its origins date back to the beginning of logic programming, but it became prominent as a separate area around 1977 when Hervé Gallaire and Jack Minker organized a workshop on logic and databases. David Maier is credited with coining the term Datalog.</p>",
        "infobox": "N/A"
    },
    {
        "id": 150,
        "name": "Dc (computer program)",
        "url": "https://en.wikipedia.org/wiki/Dc_(computer_program)",
        "summary": "<p><span></span> </p>\n<p><b>dc</b> (<i>desk calculator</i>) is a cross-platform reverse-polish calculator which supports arbitrary-precision arithmetic. Written by Robert Morris while at Bell Labs, it is one of the oldest Unix utilities, preceding even the invention of the C programming language. Like other utilities of that vintage, it has a powerful set of features but terse syntax.\nTraditionally, the bc calculator program (with infix notation) was implemented on top of dc.\n</p><p>This article provides some examples in an attempt to give a general flavour of the language; for a complete list of commands and syntax, one should consult the man page for one's specific implementation.\n</p>\n\n\n",
        "infobox": {
            "name": "dc",
            "author": "Robert Morris (cryptographer)|Robert Morris",
            "developer": "AT&T Bell Laboratories",
            "programming language": "B (programming language)|B",
            "operating system": "Unix and Unix-like",
            "genre": "Command (computing)|Command"
        }
    },
    {
        "id": 151,
        "name": "Dink Smallwood",
        "url": "https://en.wikipedia.org/wiki/Dink_Smallwood",
        "summary": "<p><i><b>Dink Smallwood</b></i> is an action role-playing video game, developed by Robinson Technologies, at the time consisting of Seth Robinson, Justin Martin, and Greg Smith. It was first released in 1998 before being released as freeware on October 17, 1999. Mitch Brink composed several of the game's music tracks, while others are MIDI forms of classical music, such as Debussy's \"Reverie\". The game has a small but constant fan following that continues to develop add-ons for the game more than a decade after its release. The game is also notable for its humorous dialogue and surrealistic themes in various scenes between the gameplay. </p>",
        "infobox": {
            "title": "Dink Smallwood",
            "image": "Dinksmallwoodlogo.png",
            "developer": "Robinson Technologies",
            "publisher": "vgrelease|EUR|Iridon|Iridon Interactive",
            "designer": "Seth Robinson",
            "released": "1998",
            "genre": "Action role-playing game",
            "modes": "Single player",
            "platforms": [
                "Windows",
                "Linux",
                "OS X",
                "PlayStation Portable",
                "IOS (Apple)|iOS",
                "Android (operating system)|Android"
            ]
        }
    },
    {
        "id": 152,
        "name": "Distributed Application Specification Language",
        "url": "https://en.wikipedia.org/wiki/Distributed_Application_Specification_Language",
        "summary": "<p>The <b>DASL Programming Language</b> (Distributed Application Specification Language) is a high-level, strongly typed programming language originally developed at Sun Microsystems Laboratories between 1999 and 2003 as part of the Ace Project.  The goals of the project were to enable rapid development of web-based applications based on Sun's J2EE architecture, and to eliminate the steep learning curve of platform-specific details. </p><p>DASL defines an application as a domain model with one or more logical presentation models, where a logical presentation model consists of a choreography of the domain model objects described in a set of forms with attached actions.  DASL generates the graphical user interface directly from the logical presentation. \n</p><p>DASL is unique among modern application programming languages in its ability to generate a modern graphic user interface for an application without requiring the programmer to define the user interface explicitly, while allowing the programmer to control the look and feel of the generated graphic user interface.\n</p><p>The DASL language is partially declarative and partially procedural. Description of object/data structures and persistence, and the description of the logical presentation, are declarative. Basic object constraints and behavior are declarative, while additional object behaviors are specified procedurally as methods. Queries can be defined either declaratively or by writing methods.\n</p><p>The language and development environment are a practical realization of the model-driven architecture (MDA) approach. The programmer uses DASL to produce the platform-independent model or PIM, and the language code generators automatically produce and deploy the platform-specific model or PSM. New PSMs may be introduced by writing new code generators. \n</p>",
        "infobox": "N/A"
    },
    {
        "id": 153,
        "name": "Dog (programming language)",
        "url": "https://en.wikipedia.org/wiki/Sepandar_Kamvar",
        "summary": "<p><b>Sepandar David Kamvar</b> (born 1977), also known as <b>Sep Kamvar</b>, is a computer scientist, artist, and entrepreneur. He is currently the LG Career Development Professor of Media Arts and Sciences at MIT, and he was director of the Social Computing group at the MIT Media Lab.</p>",
        "infobox": {
            "name": "Sepandar \"Sep\" Kamvar",
            "image": "Sep Kamvar.jpg",
            "birth_date": "Birth year and age|1977",
            "nationality": "American",
            "education": "Princeton University <small>(Bachelor of Arts|AB)</small><br>Stanford University <small>(Doctor of Philosophy|PhD)</small>",
            "occupation": "Professor at MIT"
        }
    },
    {
        "id": 154,
        "name": "Draco (programming language)",
        "url": "https://en.wikipedia.org/wiki/Draco_(programming_language)",
        "summary": "<p><b>Draco</b> was a shareware programming language created by Chris Gray. First developed for CP/M systems, Amiga version followed in 1987.</p><p>Although Draco, a blend of Pascal and C, was well suited for general purpose programming, its uniqueness as a language was its main weak point. Gray used Draco for the Amiga to create a port of Peter Langston's game <i>Empire</i>. </p>",
        "infobox": {
            "name": "Draco",
            "paradigm": [
                "Imperative programming|imperative (Procedural programming|procedural)",
                "structured programming|structured"
            ],
            "typing": [
                "type system#Static typing|static",
                "type system#Strong and weak typing|strong",
                "manifest typing|manifest"
            ],
            "year": [
                "early 1980s",
                "discontinued around 1990"
            ],
            "designer": "Chris Gray (programmer)|Chris Gray",
            "turing-complete": "Yes",
            "influenced_by": [
                "ALGOL 68",
                "Pascal (programming language)|Pascal",
                "C (programming language)|C"
            ],
            "file_ext": ".d .g",
            "operating_system": [
                "CP/M",
                "Amiga"
            ],
            "license": "copyrighted shareware"
        }
    },
    {
        "id": 155,
        "name": "Dylan (programming language)",
        "url": "https://en.wikipedia.org/wiki/Dylan_(programming_language)",
        "summary": "<p><b>Dylan</b> is a multi-paradigm programming language that includes support for functional and object-oriented programming (OOP), and is dynamic and reflective while providing a programming model designed to support generating efficient machine code, including fine-grained control over dynamic and static behaviors. It was created in the early 1990s by a group led by Apple Computer. </p><p>A concise and thorough overview of the language may be found in the Dylan Reference Manual.</p><p>Dylan derives from Scheme and Common Lisp and adds an integrated object system derived from the Common Lisp Object System (CLOS). In Dylan, all values (including numbers, characters, functions, and classes) are first-class objects. Dylan supports multiple inheritance, polymorphism, multiple dispatch, keyword arguments, object introspection, pattern-based syntax extension macros, and many other advanced features. Programs can express fine-grained control over dynamism, admitting programs that occupy a continuum between dynamic and static programming and supporting evolutionary development (allowing for rapid prototyping followed by incremental refinement and optimization).\n</p><p>Dylan's main design goal is to be a dynamic language well-suited for developing commercial software. Dylan attempts to address potential performance issues by introducing \"natural\" limits to the full flexibility of Lisp systems, allowing the compiler to clearly understand compilable units, such as libraries.\n</p><p>Dylan derives much of its semantics from Scheme and other Lisps; some Dylan implementations were initially built within extant Lisp systems. However, Dylan has an ALGOL-like syntax instead of a Lisp-like prefix syntax.\n</p>",
        "infobox": {
            "name": "Dylan",
            "logo": "Dylan logo.png",
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Functional programming|functional",
                "Object-oriented programming|object-oriented"
            ],
            "released": "1992",
            "developer": [
                "Open Source Community Apple Computer",
                "Harlequin (software company)|Harlequin",
                "Carnegie Mellon University"
            ],
            "latest release version": "2019.1",
            "latest release date": "2019|03|31",
            "typing": [
                "Strong",
                "dynamic"
            ],
            "platform": [
                "IA-32",
                "x86-64"
            ],
            "operating system": "Cross-platform",
            "file ext": "dylan",
            "website": "opendylan.org",
            "implementations": [
                "[https://opendylan.org Open Dylan]",
                "Gwydion Dylan"
            ],
            "dialects": [
                "infix-dylan (AKA Dylan)",
                "prefix-dylan (AKA Lisp)"
            ],
            "influenced by": [
                "Common Lisp Object System|CLOS",
                "ALGOL",
                "Scheme (programming language)|Scheme",
                "EuLisp"
            ],
            "influenced": [
                "Lasso (programming language)|Lasso",
                "Python (programming language)|Python",
                "Ruby (programming language)|Ruby"
            ]
        }
    },
    {
        "id": 156,
        "name": "ECMAScript",
        "url": "https://en.wikipedia.org/wiki/ECMAScript",
        "summary": "<p><b>ECMAScript</b> (or <b>ES</b>) is a general-purpose programming language, standardized by Ecma International according to the document ECMA-262. It is a JavaScript standard meant to ensure the interoperability of Web pages across different Web browsers. ECMAScript is commonly used for client-side scripting on the World Wide Web, and it is increasingly being used for writing server applications and services using Node.js.\n</p>\n\n\n",
        "infobox": {
            "name": "ECMAScript",
            "paradigm": [
                "Multi-paradigm: prototype-based programming|prototype-based",
                "functional programming|functional",
                "imperative programming|imperative"
            ],
            "designer": [
                "Brendan Eich",
                "Ecma International"
            ],
            "typing": [
                "weak typing|weak",
                "dynamic typing|dynamic"
            ],
            "implementations": [
                "JavaScript",
                "SpiderMonkey",
                "V8 (JavaScript engine)|V8",
                "ActionScript",
                "JScript",
                "QtScript",
                "InScript (JavaScript engine)|InScript",
                "Google Apps Script"
            ],
            "website": "http://www.ecma-international.org",
            "year": "1997",
            "turing-complete": "Yes",
            "influenced_by": [
                "Self (programming language)|Self",
                "HyperTalk",
                "AWK",
                "C (programming language)|C",
                "CoffeeScript",
                "Perl",
                "Python (programming language)|Python",
                "Java (programming language)|Java",
                "Scheme (programming language)|Scheme"
            ]
        }
    },
    {
        "id": 157,
        "name": "EC (programming language)",
        "url": "https://en.wikipedia.org/wiki/EC_(programming_language)",
        "summary": "<p><span></span> </p>\n<p><b>eC</b> (<b>Ecere C</b>) is an object-oriented programming language, defined as a super-set of the C language.\n</p><p>eC was initially developed as part of the Ecere cross-platform software development kit (SDK) project.\n</p><p>The goals of the language are to provide object-oriented constructs, reflection, properties and dynamic modules on top of the C language while maintaining C compatibility and optimal native performance.</p><p>eC currently relies on GCC or Clang to perform the final steps of compilation, using C as an intermediate language. There are, however, plans to integrate directly with LLVM to skip the intermediate C files.</p><p>eC is available as part of the <code>ecere-sdk</code> package in Debian/Ubuntu and other derived Linux distributions. A Windows installer also bundling MinGW-w64 is available from the main website. The free and open-source SDK including the eC compiler can also be built for a number of other platforms, including OS X, FreeBSD and Android.</p><p>It is also possible to deploy eC applications to the web by compiling them to JavaScript through Emscripten, or to WebAssembly through Binaryen.\n</p>",
        "infobox": {
            "name": "eC",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: procedural programming|procedural",
                "object-oriented programming|object-oriented",
                "generic programming|generic"
            ],
            "year": "df|=|yes|2004",
            "designer": "Jérôme Jacovella-St-Louis",
            "programming_language": "eC",
            "latest release version": "Ecere SDK 0.44.15",
            "latest release date": "2016|08|04",
            "typing": [
                "Static type|Static",
                "nominative type system|nominative",
                "type inference|partially inferred"
            ],
            "implementations": "Ecere SDK",
            "influenced by": [
                "C (programming language)|C",
                "C++",
                "Python (programming language)|Python"
            ],
            "operating_system": "Cross-platform",
            "license": "BSD-3",
            "website": "http://ec-lang.org/",
            "file_ext": [
                ".ec",
                ".eh"
            ]
        }
    },
    {
        "id": 158,
        "name": "EGL (programming language)",
        "url": "https://en.wikipedia.org/wiki/EGL_(programming_language)",
        "summary": "<p><b>EGL</b> (Enterprise Generation Language), originally developed by IBM and now available as the EDT (EGL Development Tools) Open Source project under the Eclipse Public License (EPL), is a programming technology designed to meet the challenges of modern, multi-platform application development by providing a common language and programming model across languages, frameworks, and runtime platforms. The language borrows concepts familiar to anyone using statically typed languages like Java, COBOL, C, etc. However, it borrows the concept of stereotype from Unified Modeling Language (UML) that is not typically found in statically typed programming languages. </p><p>In a nutshell, EGL is a higher-level, universal application development language.\n</p><p>EGL is similar in syntax to other common languages so it can be learned by application developers with similar previous programming background. EGL application development abstractions shield programmers from the technical interfaces of systems and middleware allowing them to focus on building business functionality.\nEGL applications and services are written, tested and debugged at the EGL source level, and once they are satisfactorily functionally tested they can be compiled into COBOL, Java, or JavaScript code to support deployment of business applications that can run in any of the following environments:\n</p>\n<ul><li>Platforms with a Java virtual machine, such as Microsoft Windows, Linux, and UNIX, for example in the context of a Java EE servlet container (IBM WebSphere Application Server, Apache Tomcat, GlassFish)</li>\n<li>IBM System z: CICS Transaction Server, IMS, z/OS Batch, UNIX System Services, WebSphere Application Server, z/VSE, Linux</li>\n<li>IBM System i: IBM i5/OS, IBM WebSphere Application Server, Apache Tomcat, Integrated Web Application Server for i</li>\n<li>Web browsers supporting JavaScript, such as Internet Explorer, Firefox, and Safari, for Ajax rich web applications</li></ul>",
        "infobox": "N/A"
    },
    {
        "id": 159,
        "name": "ELAN (programming language)",
        "url": "https://en.wikipedia.org/wiki/ELAN_(programming_language)",
        "summary": "<p><b>ELAN</b> is an educational programming language for learning and teaching systematic programming. </p><p>It was developed in 1974 by C.H.A. Koster and a group at the Technical University of Berlin as an alternative to BASIC in teaching, and approved for use in secondary schools in Germany by the \"Arbeitskreis Schulsprache\". It is in use in a number of schools in Germany, Belgium, the Netherlands, and Hungary for informatics teaching in secondary education, and used at the Radboud University Nijmegen in the Netherlands for teaching systematic programming to students from various disciplines and in teacher courses.\n</p><p>The language design focuses strongly on structured programming, and has a special construction for stepwise refinement, allowing students to focus on top-down design, and bottom-up coding.\n</p>",
        "infobox": {
            "name": "Elan",
            "paradigm": "?",
            "year": "1974",
            "designer": "Cornelis H. A. Koster|C.H.A. Koster (et al.)",
            "developer": "Technical University of Berlin",
            "typing": "?",
            "influenced_by": "ALGOL 68",
            "influenced": "?",
            "operating_system": "EUMEL",
            "website": "https://www.cs.ru.nl/elan/"
        }
    },
    {
        "id": 160,
        "name": "EXEC 2",
        "url": "https://en.wikipedia.org/wiki/EXEC_2",
        "summary": "<p><b>EXEC 2</b> is an interpreted, command procedure control, computer scripting language used by the EXEC 2 Processor supplied with the IBM Virtual Machine/System Product (VM/SP) operating system.</p><p>EXEC 2 is similar to CMS EXEC with the following enhancements:</p> <ul><li>There is no 8-byte restriction on token length.</li>\n<li>Statements can be up to 255 characters long.</li>\n<li>EXEC 2 can issue commands to subcommand environments as well as CMS and CP.</li>\n<li>EXEC 2 has additional built-in functions.</li>\n<li>EXEC 2 commands may include subroutines and functions.</li>\n<li>EXEC 2 has extra debugging facilities.</li>\n<li>CMS programs can manipulate EXEC 2 variables.</li></ul>",
        "infobox": "N/A"
    },
    {
        "id": 161,
        "name": "E (programming language)",
        "url": "https://en.wikipedia.org/wiki/E_(programming_language)",
        "summary": "<p><b>E</b> is an object-oriented programming language for secure distributed computing, created by Mark S. Miller, Dan Bornstein, and others at Electric Communities in 1997.  E is mainly descended from the concurrent language Joule and from Original-E, a set of extensions to Java for secure distributed programming.  E combines message-based computation with Java-like syntax.  A concurrency model based on event loops and promises ensures that deadlock can never occur.</p>",
        "infobox": {
            "name": "E",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm: object-oriented programming|object-oriented",
                "message passing"
            ],
            "designer": "Mark S. Miller",
            "typing": [
                "strong typing|Strong",
                "dynamic typing|dynamic"
            ],
            "implementations": [
                "E-on-Java",
                "E-on-CL"
            ],
            "influenced": "Pony (programming language)|Pony",
            "operating system": "Cross-platform",
            "license": "Portions in different Free software licence|free licenses",
            "website": "http://erights.org/",
            "year": "1997",
            "influenced_by": [
                "Joule (programming language)|Joule",
                "[http://erights.org/history/original-e/index.html Original-E]",
                "Java (programming language)|Java"
            ]
        }
    },
    {
        "id": 162,
        "name": "Ease (programming language)",
        "url": "https://en.wikipedia.org/wiki/Ease_(programming_language)",
        "summary": "<p><b>Ease</b> is a general purpose parallel programming language. It is designed by Steven Ericsson-Zenith, a researcher at Yale University, the Institute for Advanced Science &amp; Engineering in Silicon Valley, California, the Ecole Nationale Supérieure des Mines de Paris, and the Pierre and Marie Curie University, the science department of the Sorbonne.</p><p>The book <i>Process Interaction Models</i> is the Ease language specification. Ease combines the process constructs of communicating sequential processes (CSP) with logically shared data structures called <i>contexts</i>. Contexts are parallel data types that are constructed by processes and provide a way for processes to interact. </p><p>The language includes two process constructors.\n</p><p>A <i>cooperation</i> includes an explicit barrier synchronization and is written:\n</p>\n<dl><dd><dl><dd><span><span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle \\parallel P()\\parallel Q();}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <mo stretchy=\"false\">∥</mo>\n        <mi>P</mi>\n        <mo stretchy=\"false\">(</mo>\n        <mo stretchy=\"false\">)</mo>\n        <mo>∥</mo>\n        <mi>Q</mi>\n        <mo stretchy=\"false\">(</mo>\n        <mo stretchy=\"false\">)</mo>\n        <mo>;</mo>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle \\parallel P()\\parallel Q();}</annotation>\n  </semantics></math></span></span></dd></dl></dd></dl><p>If one process finishes before the other, then it will wait until the other processes are finished.\n</p><p>A <i>subordination</i> creates a process that shares the <i>contexts</i> that are in scope when created and finishes when complete (it does not wait for other processes) and is written:\n</p>\n<dl><dd><dl><dd><span><span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle {\\big /}\\!\\!/P();}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <mrow class=\"MJX-TeXAtom-ORD\">\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mo fence=\"true\" stretchy=\"true\" symmetric=\"true\" maxsize=\"1.2em\" minsize=\"1.2em\">/</mo>\n          </mrow>\n        </mrow>\n        <mspace width=\"negativethinmathspace\"></mspace>\n        <mspace width=\"negativethinmathspace\"></mspace>\n        <mrow class=\"MJX-TeXAtom-ORD\">\n          <mo>/</mo>\n        </mrow>\n        <mi>P</mi>\n        <mo stretchy=\"false\">(</mo>\n        <mo stretchy=\"false\">)</mo>\n        <mo>;</mo>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle {\\big /}\\!\\!/P();}</annotation>\n  </semantics></math></span></span></dd></dl></dd></dl><p>Subordinate processes stop if they attempt to interact with a <i>context</i> that  has completed because the parent process has stopped. This enables speculative processes to be created that will finish if their result is not needed.\n</p><p>Powerful <i>replication</i> syntax allows multiple processes to be created. For example,\n</p>\n<dl><dd><dl><dd><span><span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle \\parallel {i}\\;\\mathrm {for} \\;{n}:P(i);}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <mo stretchy=\"false\">∥</mo>\n        <mrow class=\"MJX-TeXAtom-ORD\">\n          <mi>i</mi>\n        </mrow>\n        <mspace width=\"thickmathspace\"></mspace>\n        <mrow class=\"MJX-TeXAtom-ORD\">\n          <mi mathvariant=\"normal\">f</mi>\n          <mi mathvariant=\"normal\">o</mi>\n          <mi mathvariant=\"normal\">r</mi>\n        </mrow>\n        <mspace width=\"thickmathspace\"></mspace>\n        <mrow class=\"MJX-TeXAtom-ORD\">\n          <mi>n</mi>\n        </mrow>\n        <mo>:</mo>\n        <mi>P</mi>\n        <mo stretchy=\"false\">(</mo>\n        <mi>i</mi>\n        <mo stretchy=\"false\">)</mo>\n        <mo>;</mo>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle \\parallel {i}\\;\\mathrm {for} \\;{n}:P(i);}</annotation>\n  </semantics></math></span></span></dd></dl></dd></dl><p>creates <i>n</i> synchronized processes each with a local constant <i>i</i>.\n</p><p>Processes cannot share <i>local</i> variables and cooperate in the construction of shared <i>contexts.</i> Certain context types, called <i>resources</i>, ensure call-reply semantics.\n</p><p>There are four functions upon contexts:\n</p>\n<ul><li><span><i>read</i>(context, variable)</span> – copies a value from the shared <i>context</i> to the <i>variable</i>.</li>\n<li><link rel=\"mw-deduplicated-inline-style\" href=\"mw-data:TemplateStyles:r886049734\"><span><i>write</i>(context, expression)</span> – copies the value of <i>expression</i> to the shared <i>context</i>.</li>\n<li><link rel=\"mw-deduplicated-inline-style\" href=\"mw-data:TemplateStyles:r886049734\"><span><i>put</i>(context, name)</span> – moves the value bound to <i>name</i> to the shared <i>context</i>. The value of <i>name</i> is subsequently <i>undefined</i>.</li>\n<li><link rel=\"mw-deduplicated-inline-style\" href=\"mw-data:TemplateStyles:r886049734\"><span><i>get</i>(context, name)</span> – moves a value from <i>context</i> and binds it to <i>name</i>. The value is removed from the context.</li></ul><p>Context types are <i>Singletons</i>, <i>Bags</i> or <i>Streams</i> and can be subscripted arrays.\n</p><p>Ease has a <i>semiotic definition</i>. This means that it accounts for the effect the language has on the programmer and how they develop algorithms. The language was designed to <i>ease</i> the developing of parallel programs.\n</p>",
        "infobox": {
            "name": "Ease",
            "paradigms": [
                "Concurrent computing|Concurrent",
                "communicating sequential processes"
            ],
            "designer": "Steven Ericsson-Zenith",
            "released": "1991",
            "typing": "Strong and weak typing|Strong",
            "platform": "Parallel computing|Parallel",
            "influenced by": "occam (programming language)|occam"
        }
    },
    {
        "id": 163,
        "name": "Easy Programming Language",
        "url": "https://en.wikipedia.org/wiki/Easy_Programming_Language",
        "summary": "<p><b>Easy Programming Language</b> (<b>EPL</b>, Chinese: <span lang=\"zh\">易语言</span>) is a visual compiled multilingual proprietary programming language. EPL is somewhat popular in China because it features a full Chinese environment. (The language has traditional Chinese, simplified Chinese, English and Japanese variants.) </p><p>In addition, it is cross-platform, as it currently supports both Microsoft Windows and Linux. It is object-oriented and structured.</p>",
        "infobox": {
            "name": "Easy Programming Language",
            "paradigm": [
                "Multi-paradigm: compiled language|compiled",
                "imperative programming|imperative",
                "procedural programming|procedural",
                "object-oriented programming|object-oriented)",
                "functional programming|functional"
            ],
            "year": "2004",
            "designer": "The Easy Programming Language Company",
            "latest_release_version": "5.81",
            "latest_release_date": "2018|10|9",
            "latest preview version": "4.01",
            "implementations": "[http://epl.eyuyan.com/pdown.htm E Programming Language]",
            "dialects": "[http://epl.eyuyan.com/efprc.htm EF]",
            "operating_system": "Cross-platform",
            "license": "Proprietary software",
            "website": "http://epl.eyuyan.com/",
            "file ext": ".e"
        }
    },
    {
        "id": 164,
        "name": "Easytrieve",
        "url": "https://en.wikipedia.org/wiki/CA_Technologies",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>CA Technologies</b>, formerly known as <b>CA, Inc.</b> and <b>Computer Associates International, Inc.</b>, is an American multinational corporation headquartered in New York City. Since November 5, 2018, the company has been a subsidiary of Broadcom Inc.</p><p>Prior to the Broadcom acquisition, CA was ranked as one of the largest independent software corporations in the world. The company creates systems software and applications software that run in mainframe, distributed computing, virtual machine, cloud computing environments, mobile devices and the Internet of Things (IoT).\n</p><p>The company had been a provider of anti-virus and Internet security commercial software programs for personal computers. Today, it is primarily known for its business-to-business (B2B) software with a product portfolio focused on agile software development, DevOps and computer security software spanning across a wide range of environments such as mainframe, distributed computing, cloud computing and mobile devices. CA Technologies states that its computer software products are used by \"a majority of the Fortune Global 500 companies, government organizations, educational institutions, and thousands of other companies in diverse industries worldwide.\"</p><p>CA Technologies maintains offices in more than 40 countries and employs approximately 11,300 people. CA holds more than 1,500 patents worldwide, and has more than 900 patent applications pending. It was headquartered on Long Island for most of its history, at first Jericho, NY and Garden City in Nassau County, then Suffolk County for 22 years in Islandia before moving to Manhattan in June 2014. It was once the second-largest software company in the United States.\n</p><p>The company avoided indictment for involvement in the 35 day month accounting scandal by reaching a deferred-prosecution agreement with the government in 2004 in which it agreed to pay $225 million in shareholder restitution.</p><p>The company markets nearly 200 software products. Some of the best known are ACF2, TopSecret (security), Datacom (database), Easytrieve (report generator), IDMS (database management), InterTest (debugging), Librarian, Panvalet (library management), and TLMS (tape library management).</p>\n\n\n",
        "infobox": {
            "name": "CA Technologies",
            "logo": "Image:CA Technologies logo.svg|150px",
            "image": "CA House in Canberra.jpg",
            "image_caption": "CA Technologies office in Canberra",
            "type": "Subsidiary",
            "parent": "Broadcom Inc.",
            "foundation": [
                "start date and age|1976 (as Computer Associates International",
                "Inc.)"
            ],
            "founders": "Charles B. Wang<br />Russell Artzt",
            "location": [
                "New York City|New York",
                "New York (state)|NY 10022<br/>U.S."
            ],
            "key_people": "Arthur F. Weinbach <small>(Chairman)</small><p>Michael P. Gregoire <small>(CEO)</small>",
            "industry": "Enterprise software",
            "products": "Computer software",
            "revenue": "increase US$ 4.235 billion <small>(2018)</small>",
            "operating_income": "increase US$ 1.2 billion <small>(2018)</small>",
            "net_income": "decrease US$ 476 million <small>(GAAP)</small> <small>(2018)</small><br /> increase US$ 1.091 billion <small>(non-GAAP) (2018)</small>",
            "assets": "nowrap|increase| US$ 13.060 billion <small>(2018)</small> increase US$ 13.060 billion <small>(2018)</small>",
            "equity": "increase US$ 5.895 billion <small>(2018)</small>",
            "num_employees": "10 ,850</small>",
            "num_employees_year": "2018",
            "homepage": "www.ca.com"
        }
    },
    {
        "id": 165,
        "name": "Edinburgh IMP",
        "url": "https://en.wikipedia.org/wiki/Edinburgh_IMP",
        "summary": "<p><b>Edinburgh IMP</b> is a development of Atlas Autocode, initially developed around 1966-1969 at the University of Edinburgh, Scotland. It is a general-purpose programming language which was used heavily for systems programming. </p><p>Expressively, IMP is highly similar to ALGOL and includes all the ALGOL-style block structure, reserved words (keywords), and data types such as arrays, and records. It adds to ALGOL-style languages a string type (an array of characters, although these have a predeclared size) and built-in operators for string manipulation and character handling.\n</p><p>IMP provides significant control over the storage mapping of data, plus commands for addressing within parts of words. Most IMP compilers offer compiler-generated runtime checks and a stack trace (backtrace) facility by default, even in production code. IMP allows inline assembler machine language instructions in source code.\n</p><p>Early IMP compilers were developed for the English Electric KDF9, ICL System 4, UNIVAC 1108, IBM System/360, DEC PDP-9, DEC PDP-15 and CTL Modular One computers. IMP was used to implement the Edinburgh Multiple Access System (EMAS) operating system, and a compiler was written for the ICL 2900 series to allow porting of EMAS to that platform. In later years, a version of IMP named IMP77 was developed by Peter Robertson within the Computer Science department at Edinburgh which was a portable compiler that brought IMP to even more platforms. In 2002, the IMP77 language was resurrected by the Edinburgh Computer History Project for Intel x86 hardware running DOS, Windows, and Linux, and is once again in use by Edinburgh graduates and ex-pats.\n</p><p>The diverged IMP and IMP77 were later consolidated into one language with the introduction of the IMP80 standard, supported by implementations from the Edinburgh Regional Computer Centre. IMP80 has also been ported to several platforms including Intel and was actively in use into the 1990s.\n</p><p>Edinburgh IMP is unrelated to the later IMP syntax-extensible programming language developed by Edgar T. Irons, for the CDC 6600, which was the main language used by the National Security Agency (NSA) for many years.\n</p>",
        "infobox": {
            "name": "Edinburgh IMP",
            "paradigms": [
                "Procedural programming|Procedural",
                "Imperative programming|imperative",
                "Structured programming|structured"
            ],
            "family": "ALGOL",
            "designers": [
                "Bratley",
                "Whitfield",
                "M. M. Barritt",
                "David Rees",
                "Peter D. Schofield",
                "Roderick McLeod",
                "Hamish Dewar",
                "Peter D. Stephens",
                "Peter Robertson"
            ],
            "developer": "University of Edinburgh",
            "released": "1966",
            "typing": [
                "Static type|Static",
                "Strong and weak typing|strong"
            ],
            "scope": "Scope (computer science)|Lexical",
            "programming language": [
                "Atlas Autocode",
                "IMP"
            ],
            "platform": [
                "English Electric KDF9,<br/>ICL System 4",
                "UNIVAC 1108",
                "IBM System/360",
                "DEC PDP-9",
                "DEC PDP-15",
                "CTL Modular One",
                "x86"
            ],
            "operating system": [
                "BOS/360",
                "DOS",
                "Windows",
                "Linux"
            ],
            "implementations": "Edinburgh IMP",
            "dialects": [
                "IMP77",
                "IMP80"
            ],
            "influenced by": [
                "ALGOL 60",
                "Atlas Autocode"
            ]
        }
    },
    {
        "id": 166,
        "name": "Eiffel (programming language)",
        "url": "https://en.wikipedia.org/wiki/Eiffel_(programming_language)",
        "summary": "<p><b>Eiffel</b> is an object-oriented programming language designed by Bertrand Meyer (an object-orientation proponent and author of <i>Object-Oriented Software Construction</i>) and Eiffel Software. Meyer conceived the language in 1985 with the goal of increasing the reliability of commercial software development; the first version becoming available in 1986. In 2005, Eiffel became an ISO-standardized language. </p><p>The design of the language is closely connected with the Eiffel programming method. Both are based on a set of principles, including design by contract, command–query separation, the uniform-access principle, the single-choice principle, the open–closed principle, and option–operand separation.\n</p><p>Many concepts initially introduced by Eiffel later found their way into Java, C#, and other languages. New language design ideas, particularly through the Ecma/ISO standardization process, continue to be incorporated into the Eiffel language.\n</p>",
        "infobox": {
            "name": "Eiffel",
            "logo": "File:Eiffel logo.svg|frameless|Eiffel logo",
            "paradigm": [
                "Object-oriented programming|Object-oriented",
                "Class-based programming|Class-based",
                "Generic programming|Generic",
                "Concurrent object-oriented programming|Concurrent"
            ],
            "year": "1986",
            "designer": "Bertrand Meyer",
            "developer": "Eiffel Software",
            "latest release version": "EiffelStudio|EiffelStudio 19.12",
            "latest release date": "start date and age|2020|02|06|df|=|y",
            "typing": "static typing|static",
            "implementations": [
                "EiffelStudio",
                "LibertyEiffel",
                "SmartEiffel",
                "Visual Eiffel",
                "Gobo Eiffel",
                "\"The Eiffel Compiler\" tecomp"
            ],
            "influenced_by": [
                "Ada (programming language)|Ada",
                "Simula",
                "Z notation|Z"
            ],
            "influenced": [
                "Ada (programming language)|Ada 2012",
                "Albatross (programming language)|Albatross",
                "C Sharp (programming language)|C#",
                "D (programming language)|D",
                "Java (programming language)|Java",
                "Racket (programming language)|Racket",
                "Ruby (programming language)|Ruby",
                "Sather",
                "Scala (programming language)|Scala"
            ],
            "programming language": "Eiffel",
            "platform": "Cross-platform",
            "operating_system": [
                "FreeBSD",
                "Linux",
                "Mac OS X",
                "OpenBSD",
                "Solaris (operating system)|Solaris",
                "Windows"
            ],
            "license": "dual and enterprise",
            "file_ext": "<code>.e</code>",
            "website": "https://www.eiffel.org/"
        }
    },
    {
        "id": 167,
        "name": "Elixir (programming language)",
        "url": "https://en.wikipedia.org/wiki/Elixir_(programming_language)",
        "summary": "<p><b>Elixir</b> is a functional, concurrent, general-purpose programming language that runs on the Erlang virtual machine (BEAM). Elixir builds on top of Erlang and shares the same abstractions for building distributed, fault-tolerant applications. Elixir also provides productive tooling and an extensible design. The latter is supported by compile-time metaprogramming with macros and polymorphism via protocols.</p><p>Elixir is used by companies such as PagerDuty, Discord, E-MetroTel, Pinterest, Moz, Bleacher Report, The Outline, Inverse, Divvy, FarmBot and for building embedded systems. The community organizes yearly events in the United States, Europe and Japan as well as minor local events and conferences.</p>",
        "infobox": {
            "name": "Elixir",
            "logo": "File:Elixir_programming_language_logo.png|frameless|100px|elixir programming language",
            "caption": "Elixir",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: functional programming|functional",
                " concurrent programming|concurrent",
                "distributed programming|distributed",
                "process-oriented programming|process-oriented"
            ],
            "typing": [
                "type system|dynamic",
                "strong typing|strong",
                "duck typing|duck"
            ],
            "influenced": "LFE (programming language)|LFE",
            "platform": "Erlang (programming language)|Erlang",
            "license": "Apache License 2.0",
            "website": "https://elixir-lang.org",
            "year": "start date and age|2011",
            "influenced_by": [
                "Clojure",
                "Erlang (programming language)|Erlang",
                "Ruby (programming language)|Ruby"
            ],
            "creator": "José Valim",
            "latest_release_version": "1.10.4",
            "latest_release_date": "df|=|yes|2020|7|4",
            "file_ext": [
                ".ex",
                ".exs"
            ],
            "Supported Erlang/OTP version": "20 - 21"
        }
    },
    {
        "id": 168,
        "name": "Elm (programming language)",
        "url": "https://en.wikipedia.org/wiki/Elm_(programming_language)",
        "summary": "<p><b>Elm</b> is a domain-specific programming language for declaratively creating web browser-based graphical user interfaces. Elm is purely functional, and is developed with emphasis on usability, performance, and robustness. It advertises \"no runtime exceptions in practice\", made possible by the Elm compiler's static type checking. </p>",
        "infobox": {
            "name": "Elm",
            "logo": "File:Elm logo.svg|120px|Logo of Elm|The Elm tangram",
            "paradigm": "Functional programming|Functional",
            "released": "2012|3|30",
            "latest release version": "0.19.1",
            "latest release date": "2019|10|21",
            "influenced_by": [
                "Haskell (programming language)|Haskell",
                "Standard ML",
                "OCaml",
                "F Sharp (programming language)|F#"
            ],
            "influenced": [
                "Redux (JavaScript library)|Redux",
                "Vue.js#Official Libraries|Vuex"
            ],
            "typing": [
                "static typing|Static",
                "strong typing|Strong",
                "type inference|Inferred"
            ],
            "designer": "Evan Czaplicki",
            "website": "Official URL",
            "license": "Permissive license|Permissive (BSD license|Revised BSD)",
            "file_ext": ".elm"
        }
    },
    {
        "id": 169,
        "name": "Eltron Programming Language",
        "url": "https://en.wikipedia.org/wiki/Eltron_Programming_Language",
        "summary": "<p><b>Eltron Programming Language</b> (<b>EPL</b>) is a printer control language used to produce printed labels for various Eltron model printers.  </p><p>It was superseded by Zebra Programming Language (ZPL) after Zebra Technologies acquired Eltron.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 170,
        "name": "Emacs Lisp",
        "url": "https://en.wikipedia.org/wiki/Emacs_Lisp",
        "summary": "<p><b>Emacs Lisp</b> is a dialect of the Lisp programming language used as a scripting language by Emacs (a text editor family most commonly associated with GNU Emacs and XEmacs). It is used for implementing most of the editing functionality built into Emacs, the remainder being written in C, as is the Lisp interpreter. Emacs Lisp is also termed <b>Elisp</b>, although there is also an older, unrelated Lisp dialect with that name.</p><p>Users of Emacs commonly write Emacs Lisp code to customize and extend Emacs.  Other options include the <i>Customize</i> feature that's been in GNU Emacs since version 20.  Itself written in Emacs Lisp, Customize provides a set of preferences pages allowing the user to set options and preview their effect in the running Emacs session. When the user saves their changes, Customize simply writes the necessary Emacs Lisp code to the user's config file, which can be set to a special file that only Customize uses, to avoid the possibility of altering the user's own file. </p><p>Emacs Lisp can also function as a scripting language, much like the Unix Bourne shell or Perl, by calling Emacs in <i>batch mode</i>.  In this way it may be called from the command line or via an executable file, and its editing functions, such as buffers and movement commands are available to the program just as in the normal mode. No user interface is presented when Emacs is started in batch mode; it simply executes the passed-in script and exits, displaying any output from the script.\n</p>",
        "infobox": {
            "name": "Emacs Lisp",
            "logo": "EmacsIcon.svg",
            "logo caption": "Emacs logo",
            "family": "Lisp (programming language)|Lisp",
            "paradigm": [
                "Functional programming|Functional",
                "Metaprogramming|meta",
                "Reflective programming|reflective"
            ],
            "released": "1985",
            "designers": [
                "Richard Stallman,<br />Guy L. Steele",
                "Jr."
            ],
            "developer": "GNU Project",
            "latest release version": "26.2",
            "latest release date": "2019|04|12",
            "typing": [
                "Type system|Dynamic",
                "strong typing|strong"
            ],
            "scope": [
                "Dynamic",
                "optionally lexical"
            ],
            "influenced by": [
                "Common Lisp",
                "Maclisp"
            ],
            "platform": "Emacs",
            "operating system": "Cross-platform",
            "license": "GNU General Public License#Version 3|GPLv3",
            "file ext": [
                ".el",
                ".elc"
            ]
        }
    },
    {
        "id": 171,
        "name": "Emerald (programming language)",
        "url": "https://en.wikipedia.org/wiki/Emerald_(programming_language)",
        "summary": "<p><b>Emerald</b> is a distributed, object-oriented programming language developed in the 1980s by Andrew P. Black, Norman C. Hutchinson, Eric B. Jul, and Henry M. Levy, in the Department of Computer Science at the University of Washington.</p><p>A simple Emerald program can create an object and move it around the system: </p>\n<pre><b>const</b> Kilroy ←  <b>object</b> Kilroy\n  <b>process</b>\n  <b>const</b> origin ←  <b>locate self</b>\n  <b>const</b> up ← origin.getActiveNodes\n  <b>for</b> e <b>in</b> up\n   <b>const</b> there ← e.getTheNode\n   <b>move self to</b> there\n  <b>end for</b>\n  <b>move self to</b> origin\n  <b>end</b> process\n<b>end</b> Kilroy\n</pre>\n<p>Emerald was designed to support high performance distribution, location, and high performance of objects, to simplify distributed programming, to exploit information hiding, and to be a small language.\n</p>",
        "infobox": {
            "name": "Emerald",
            "paradigm": "Object-oriented programming|object-oriented",
            "year": "1980s",
            "designer": [
                "Andrew P. Black",
                "Norman C. Hutchinson",
                "Eric B. Jul",
                "Hank Levy (computer scientist)|Henry M. Levy"
            ],
            "typing": [
                "strong typing|strong",
                "static typing|static"
            ],
            "influenced by": [
                "Pascal (programming language)|Pascal",
                "Simula",
                "Smalltalk"
            ],
            "influenced": [
                "Java (programming language)|Java",
                "Singularity (operating system)|Singularity"
            ],
            "website": "www.emeraldprogramminglanguage.org"
        }
    },
    {
        "id": 172,
        "name": "Epigram (programming language)",
        "url": "https://en.wikipedia.org/wiki/Epigram_(programming_language)",
        "summary": "<p><b>Epigram</b> is a functional programming language with dependent types. <i>Epigram</i> also refers to the IDE usually packaged with the language. Epigram's type system is strong enough to express program specifications. The goal is to support a smooth transition from ordinary programming to integrated programs and proofs whose correctness can be checked and certified by the compiler. Epigram exploits the propositions as types principle, and is based on intuitionistic type theory. </p><p>The Epigram prototype was implemented by Conor McBride based on joint work with James McKinna. Its development is continued by the Epigram group in Nottingham, Durham, St Andrews and Royal Holloway in the UK. The current experimental implementation of the Epigram system is freely available together with a user manual, a tutorial and some background material. The system has been used under Linux, Windows and Mac OS X.\n</p><p>It is currently unmaintained, and version 2, which was intended to implement Observational Type Theory, was never officially released but exists in GitHub. The design of Epigram and Epigram 2 have inspired the development Agda, Idris, and Coq.</p>",
        "infobox": {
            "name": "Epigram",
            "paradigm": "Functional programming|Functional",
            "year": "2004",
            "designer": "Conor McBride<br>James McKinna",
            "developer": "''Unmaintained''",
            "latest_release_version": "1",
            "typing": [
                "strong typing|strong",
                "static typing|static",
                "dependent typing|dependent"
            ],
            "influenced_by": "ALF (theorem prover)|ALF",
            "influenced": [
                "Agda (programming language)|Agda",
                "Idris (programming language)|Idris"
            ],
            "operating_system": [
                "Cross-platform: Linux",
                "Microsoft Windows|Windows",
                "Mac OS X"
            ],
            "license": "MIT",
            "website": "e-pig.org"
        }
    },
    {
        "id": 173,
        "name": "Erlang (programming language)",
        "url": "https://en.wikipedia.org/wiki/Erlang_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Erlang</b> (<span></span> <i title=\"English pronunciation respelling\"><span>UR</span>-lang</i>) is a general-purpose, concurrent, functional programming language, and a garbage-collected runtime system. The term Erlang is used interchangeably with Erlang/OTP, or Open Telecom Platform (OTP), which consists of the Erlang runtime system, several ready-to-use components (OTP) mainly written in Erlang, and a set of design principles for Erlang programs.</p><p>The Erlang runtime system is designed for systems with these traits:\n</p>\n<ul><li>Distributed</li>\n<li>Fault-tolerant</li>\n<li>Soft real-time</li>\n<li>Highly available, non-stop applications</li>\n<li>Hot swapping, where code can be changed without stopping a system.</li></ul><p>The Erlang programming language has immutable data, pattern matching, and functional programming. The sequential subset of the Erlang language supports eager evaluation, single assignment, and dynamic typing.\n</p><p>It was originally proprietary software within Ericsson, developed by Joe Armstrong, Robert Virding, and Mike Williams in 1986, but was released as free and open-source software in 1998. Erlang/OTP is supported and maintained by the Open Telecom Platform (OTP) product unit at Ericsson.\n</p>",
        "infobox": {
            "name": "Erlang",
            "logo": "Erlang logo.svg",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Concurrent programming|concurrent",
                "Functional programming|functional"
            ],
            "designer": "unbulleted list|Joe Armstrong (programmer)|Joe Armstrong|Robert Virding|Mike Williams",
            "developer": "Ericsson",
            "released": "1986",
            "latest release version": "23",
            "latest release date": "2020|05|13",
            "typing": [
                "type system|Dynamic",
                "strong typing|strong"
            ],
            "implementations": "Erlang",
            "influenced_by": [
                "Lisp (programming language)|Lisp",
                "PLEX (programming language)|PLEX",
                "Prolog",
                "Smalltalk"
            ],
            "influenced": [
                "Akka (toolkit)|Akka",
                "Clojure Citation needed |date|=|January 2018 ",
                "Dart (programming language)|Dart",
                "Elixir (programming language)|Elixir",
                "F Sharp (programming language)|F#",
                "Opa (programming language)|Opa",
                "Oz (programming language)|Oz",
                "Reia (programming language)|Reia",
                "Rust (programming language)|Rust",
                "Scala (programming language)|Scala"
            ],
            "file ext": [
                ".erl",
                ".hrl"
            ],
            "license": "Apache License 2.0",
            "website": "www.erlang.org",
            "wikibooks": "Erlang Programming"
        }
    },
    {
        "id": 174,
        "name": "Es (Unix shell)",
        "url": "https://en.wikipedia.org/wiki/Rc",
        "summary": "<p><span></span> </p>\n\n<p><b>rc</b> (for \"run commands\") is the command line interpreter for Version 10 Unix and Plan 9 from Bell Labs operating systems. It resembles the Bourne shell, but its syntax is somewhat simpler. It was created by Tom Duff, who is better known for an unusual C programming language construct (\"Duff's device\").</p><p>A port of the original rc to Unix is part of Plan 9 from User Space.  A rewrite of rc for Unix-like operating systems by Byron Rakitzis is also available but includes some incompatible changes.\n</p><p>Rc uses C-like control structures instead of the original Bourne shell's ALGOL-like structures, except that it uses an <code>if not</code> construct instead of <code>else</code>, and has a Bourne-like <code>for</code> loop to iterate over lists. In rc, all variables are lists of strings, which eliminates the need for constructs like \"<code>$@</code>\". Variables are not re-split when expanded. The language is described in Duff's paper.</p>\n\n\n",
        "infobox": {
            "name": "rc",
            "paradigm": [
                "Imperative programming|imperative",
                "Pipeline programming|pipeline"
            ],
            "year": "1989",
            "designer": "Tom Duff",
            "developer": "Bell Labs",
            "source_model": "Open source",
            "typing": "weak typing|weak",
            "dialects": "Byron's rc",
            "influenced_by": "Bourne shell",
            "influenced": [
                "es (Unix shell)|es",
                "The Inferno (operating system)|Inferno shell."
            ],
            "operating_system": [
                "Cross-platform (Version 10 Unix",
                "Plan 9 from Bell Labs|Plan 9",
                "Plan 9 from User Space)"
            ]
        }
    },
    {
        "id": 175,
        "name": "Escher (programming language)",
        "url": "https://en.wikipedia.org/wiki/Escher_(programming_language)",
        "summary": "<p><b>Escher</b> (named for M. C. Escher, \"a master of endless loops\") is a declarative programming language that supports both functional programming and logic programming models, developed by J.W. Lloyd in the mid-1990s. It was designed mostly as a research and teaching vehicle. The basic view of programming exhibited by Escher and related languages is that a program is a representation of a theory in some logic framework, and the program's execution (computation) is a deduction from the theory. The logic framework for Escher is Alonzo Church's simple theory of types. </p><p>Escher, notably, supports I/O through a monadic type representing the 'outside world', in the style of Haskell.\nOne of the goals of Escher's designers was to support meta-programming, and so the language has comprehensive support for generating and transforming programs.\n</p>",
        "infobox": {
            "name": "Escher",
            "paradigm": [
                "declarative programming|declarative: Functional programming|functional",
                "logic programming|logic"
            ],
            "year": "mid-1990s",
            "designer": "J.W. Lloyd",
            "typing": [
                "static typing|static",
                "manifest typing|manifest"
            ],
            "implementations": "[http://mentalmodels4life.net/software/ Kee Siong Ng's implementation]",
            "influenced_by": "simple theory of types"
        }
    },
    {
        "id": 176,
        "name": "Esoteric programming language",
        "url": "https://en.wikipedia.org/wiki/Esoteric_programming_language",
        "summary": "<p>An <b>esoteric programming language</b> (sometimes shortened to <b>esolang</b>) is a programming language designed to test the boundaries of computer programming language design, as a proof of concept, as software art, as a hacking interface to another language (particularly functional programming or procedural programming languages), or as a joke.  The use of <i>esoteric</i> distinguishes these languages from programming languages that working developers use to write software. Usually, an esolang's creators do not intend the language to be used for mainstream programming, although some esoteric features, such as visuospatial syntax,  have inspired practical applications in the arts.  Such languages are often popular among hackers and hobbyists. </p><p>Usability is rarely a goal for esoteric programming language designers—often the design leads to quite the opposite.  Their usual aim is to remove or replace conventional language features while still maintaining a language that is Turing-complete, or even one for which the computational class is unknown.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 177,
        "name": "Esterel",
        "url": "https://en.wikipedia.org/wiki/Esterel",
        "summary": "<p><b>Esterel</b> is a synchronous programming language  for the development of complex reactive systems. The imperative programming style of <b>Esterel</b> allows the simple expression of parallelism and preemption. As a consequence, it is well suited for control-dominated model designs. </p><p>The development of the language started in the early 1980s, and was mainly carried out by a team of Ecole des Mines de Paris and INRIA led by Gérard Berry in France. Current compilers take Esterel programs and generate C code or hardware (RTL) implementations (VHDL or Verilog).\n</p><p>The language is still under development, with several compilers out. The commercial version of <b>Esterel</b> is the development environment Esterel Studio. The company that commercialize it (Synfora) initiated a normalization process with the IEEE in April 2007 however the working group (P1778) dissolved March 2011. The Esterel v7 Reference Manual Version v7 30 – initial IEEE standardization proposal is publicly available.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 178,
        "name": "Ethereum",
        "url": "https://en.wikipedia.org/wiki/Ethereum",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Ethereum</b> is the second largest cryptocurrency platform by market capitalization, behind Bitcoin. It is a decentralized open source blockchain featuring smart contract functionality. <b>Ether</b> is the cryptocurrency generated by Ethereum miners as a reward for computations performed to secure the blockchain. Ethereum serves as the platform for over 260,000 different cryptocurrencies, including 47 of the top 100 cryptocurrencies by market capitalization.</p><p>Ethereum provides a decentralized virtual machine, the Ethereum Virtual Machine (EVM), which can execute scripts using an international network of public nodes. The virtual machine's instruction set, in contrast to others like Bitcoin Script, is Turing-complete. \"Gas\", an internal transaction pricing mechanism, is used to mitigate spam and allocate resources on the network.</p><p>Ethereum was proposed in late 2013 by Vitalik Buterin, a cryptocurrency researcher and programmer. Development was funded by an online crowdsale that took place between July and August 2014. The system then went live on 30 July 2015, with 72 million coins minted. This accounts for about 65 percent of the total circulating supply in April 2020.</p><p>In 2016, as a result of an exploitation of a flaw in The DAO project's smart contract software, and subsequent theft of $50 million worth of ether, Ethereum was split into two separate blockchains. The new separate version became Ethereum (ETH) with the theft reversed, and the original chain continued as Ethereum Classic (ETC).</p><p>Ethereum is currently developing and planning to implement a series of upgrades called Ethereum 2.0. Current specifications for Ethereum 2.0 include a transition to proof of stake and an increase in transaction throughput using sharding technology.</p>\n\n\n",
        "infobox": {
            "name": "Ethereum",
            "logo": "File:Ethereum-icon-purple.svg",
            "logo_caption": "Ethereum Logo",
            "author": [
                "Vitalik Buterin",
                "Gavin Wood"
            ],
            "developer": "Ethereum Foundation",
            "released": "2015|07|30",
            "latest release version": "Muir Glacier",
            "latest release date": "df|=|yes|2020|01|01",
            "frequently updated": "Yes",
            "status": "Active",
            "software": "EVM 1 Bytecode",
            "programming language": [
                "Go (programming language)|Go",
                "Rust (programming language)|Rust",
                " C Sharp (programming language)|C#",
                " C++",
                "Java (programming language)|Java",
                "Python (programming language)|Python"
            ],
            "operating system": "Cross-platform software|Cross-platform",
            "platform": [
                "x86-64",
                "ARM"
            ],
            "size": "300 GB (2020-03)",
            "genre": "Distributed Computing",
            "license": "open-source license|Open-Source Licenses",
            "website": "ethereum.org",
            "total users": "91,994,515 (2020-03)",
            "active hosts": "7,546 (2020-03)"
        }
    },
    {
        "id": 179,
        "name": "Etoys (programming language)",
        "url": "https://en.wikipedia.org/wiki/Etoys_(programming_language)",
        "summary": "<p><b>Etoys</b> is a child-friendly computer environment and object-oriented prototype-based programming language for use in education. </p><p>Etoys is a media-rich authoring environment with a scripted object model for many different objects that runs on different platforms and is free and open source.\n</p>",
        "infobox": {
            "name": "Etoys",
            "paradigm": [
                "Object-oriented programming|object-oriented Prototype-based programming|prototype-based",
                "educational programming language|educational"
            ],
            "year": "1996",
            "designer": "Alan Kay",
            "developer": [
                "Scott Wallace",
                "Ted Kaehler",
                "John Maloney",
                "Andreas Raab",
                "Dan Ingalls"
            ],
            "typing": "Type system|dynamic",
            "implementations": "Squeak (Morphic (software)|Morphic)\nSqueak (Tweak (programming environment)|Tweak)",
            "influenced_by": [
                "Logo (programming language)|Logo",
                "Smalltalk",
                "HyperCard",
                "StarLogo",
                "AgentSheets"
            ],
            "influenced": [
                "Tweak",
                "Croquet Project|Croquet",
                "Scratch (programming language)|Scratch"
            ],
            "license": "MIT license|MIT and Apache license|Apache 2.0 licenses"
        }
    },
    {
        "id": 180,
        "name": "Euclid (programming language)",
        "url": "https://en.wikipedia.org/wiki/Euclid_(programming_language)",
        "summary": "<p><b>Euclid</b> is an imperative programming language for writing verifiable programs. It was designed by Butler Lampson and associates at the Xerox PARC lab in the mid-1970s. The implementation was led by Ric Holt at the University of Toronto and James Cordy was the principal programmer for the first implementation of the compiler. It was originally designed for the Motorola 6809 microprocessor. It was considered innovative for the time; the compiler development team had a $2 million budget over 2 years and was commissioned by the Defense Advanced Research Projects Agency of the U.S. Department of Defense and the Canadian Department of National Defence. It was used for a few years at I. P. Sharp Associates, MITRE Corporation, SRI International and various other international institutes for research in systems programming and secure software systems. </p><p>Euclid is descended from the Pascal programming language. Functions in Euclid are closed scopes, may not have side effects, and must explicitly declare imports. Euclid also disallows gotos, floating point numbers, global assignments, nested functions and aliases, and none of the actual parameters to a function can refer to the same thing. Euclid implements modules as types. Descendants of Euclid include the Mesa programming language, the Concurrent Euclid programming language and the Turing programming language.\n</p>",
        "infobox": {
            "name": "Euclid",
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: structured programming|structured",
                "Imperative programming|imperative",
                "Functional programming|functional"
            ],
            "year": "1970s",
            "designer": [
                "Butler Lampson",
                "Xerox PARC"
            ],
            "developer": "Ric Holt and James Cordy",
            "typing": [
                "strong typing|strong",
                "static typing|static"
            ],
            "influenced_by": "Pascal (programming language)|Pascal",
            "influenced": [
                "Mesa (programming language)|Mesa",
                "Concurrent Euclid (programming language)|Concurrent Euclid",
                "Turing (programming language)|Turing"
            ]
        }
    },
    {
        "id": 181,
        "name": "Euler (programming language)",
        "url": "https://en.wikipedia.org/wiki/Euler_(programming_language)",
        "summary": "<p><b>Euler</b> is a programming language created by Niklaus Wirth and Helmut Weber, conceived as an extension and generalization of ALGOL 60. The designers' goal was to create a language: </p>\n<ul><li>which was simpler, and yet more flexible, than ALGOL 60</li>\n<li>that was a useful programming language processed with reasonable efficiency</li>\n<li>that can be defined with rigorous formality</li></ul><p>Available sources indicate that Euler was operational by 1965.\n</p>",
        "infobox": {
            "name": "Euler",
            "paradigm": [
                "procedural programming|procedural",
                "Imperative programming|imperative",
                "structured programming|structured"
            ],
            "designer": "Niklaus Wirth and<br/>Helmut Weber",
            "typing": "dynamic typing|dynamic",
            "influenced_by": "ALGOL 60"
        }
    },
    {
        "id": 182,
        "name": "Euphoria (programming language)",
        "url": "https://en.wikipedia.org/wiki/Euphoria_(programming_language)",
        "summary": "<p><b>Euphoria</b> is a programming language originally created by Robert Craig of Rapid Deployment Software in Toronto, Ontario, Canada. Initially developed (though not publicly released) on the Atari ST, the first commercial release was for the 16-bit DOS platform and was proprietary. In 2006, with the release of version 3, Euphoria became open-source software. The openEuphoria Group continues to administer and develop the project.  In December 2010, the openEuphoria Group released version 4 of openEuphoria along with a new identity and mascot for the project. OpenEuphoria is currently available for Windows, Linux, macOS and three flavors of *BSD. </p><p>Euphoria is a general-purpose high-level imperative-procedural interpreted language. A translator generates C source code and the GNU compiler collection (GCC) and Open Watcom compilers are supported. Alternatively, Euphoria programs may be bound with the interpreter to create stand-alone executables. A number of graphical user interface (GUI) libraries are supported including Win32lib and wrappers for wxWidgets, GTK+ and IUP. Euphoria has a simple built-in database and wrappers for a variety of other databases.</p>",
        "infobox": {
            "name": "Euphoria",
            "logo": "File:OpenEuphoria logo.png|openEuphoria logo",
            "caption": "openEuphoria logo",
            "paradigm": [
                "Imperative programming|Imperative",
                "procedural"
            ],
            "released": "1993",
            "designer": [
                "Jeremy Cowgar",
                "Robert Craig (original)",
                "Matt Lewis",
                "Derek Parnell"
            ],
            "developer": "[http://openeuphoria.org/ openEuphoria Group]",
            "latest release version": "4.0.5",
            "latest release date": "2012|10|19",
            "typing": [
                "static",
                "dynamic"
            ],
            "operating system": [
                "Cross-platform: Microsoft Windows|Win32",
                "Linux",
                "macOS",
                "FreeBSD",
                "NetBSD",
                "OpenBSD"
            ],
            "genre": "Interpreted language or compiled language",
            "license": "BSD licenses|BSD",
            "file_ext": [
                ".e",
                ".ex",
                ".exw",
                ".edb"
            ],
            "influenced": "[http://phix.x10.mx Phix]",
            "website": "openeuphoria.org"
        }
    },
    {
        "id": 183,
        "name": "EusLisp Robot Programming Language",
        "url": "https://en.wikipedia.org/wiki/EusLisp_Robot_Programming_Language",
        "summary": "<p><b>EusLisp</b> is a Lisp-based programming system. Built on the basis of object orientation, it is designed specifically for developing robotics software. The first version of it ran in 1986 on Unix-System5/Ustation-E20.</p>",
        "infobox": "N/A"
    },
    {
        "id": 184,
        "name": "Executable UML",
        "url": "https://en.wikipedia.org/wiki/Executable_UML",
        "summary": "<p><b>Executable UML</b> (<b>xtUML</b> or <b>xUML</b>) is both a software development method and a highly abstract software language. It was described for the first time in 2002 in the book \"Executable UML: A Foundation for Model-Driven Architecture\". The language \"combines a subset of the UML (Unified Modeling Language) graphical notation with executable semantics and timing rules.\" The Executable UML method is the successor to the Shlaer–Mellor method.</p><p>Executable UML models \"can be run, tested, debugged, and measured for performance.\", and can be compiled into a less abstract programming language to target a specific implementation.  Executable UML supports model-driven architecture (MDA) through specification of platform-independent models, and the compilation of the platform-independent models into platform-specific models.</p>",
        "infobox": "N/A"
    },
    {
        "id": 185,
        "name": "Executive Systems Problem Oriented Language",
        "url": "https://en.wikipedia.org/wiki/Executive_Systems_Problem_Oriented_Language",
        "summary": "<p>The <b>Executive Systems Problem Oriented Language</b> (<b>ESPOL</b>) is a programming language, a superset of ALGOL 60, that provides abilities of what would later be termed a <i>system programming language</i> or <i>machine oriented high order language</i> (mohol), such as interrupting a processor on a multiprocessing system (the Burroughs large systems were multiprocessor systems). ESPOL was used to write the <i>Master Control Program</i> (MCP) on Burroughs computer systems from the B5000 to the B6700. The single-pass compiler for ESPOL could compile over 250 lines per second. </p><p>ESPOL was superseded by NEWP.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 186,
        "name": "Ezhil (programming language)",
        "url": "https://en.wikipedia.org/wiki/Ezhil_(programming_language)",
        "summary": "<p><b>Ezhil</b>, in Tamil language script (Tamil: <span lang=\"ta\">எழில்</span>, <small>romanized: </small><i lang=\"ta-Latn\" title=\"Tamil-language romanization\">Eḻil</i>, <small>lit. </small>'beauty', <small>Tamil pronunciation: </small><span title=\"Representation in the International Phonetic Alphabet (IPA)\">[eɻil̪]</span>), is a compact, open source, interpreted, programming language, originally designed to enable native-Tamil speaking students, K-12 age-group to learn computer programming, and enable learning numeracy and computing, outside of linguistic expertise in predominately English language-based computer systems. </p><p>In the Ezhil programming language, Tamil keywords and language-grammar are chosen to easily enable the native Tamil speaker write programs in the Ezhil system. Ezhil allows easy representation of computer program closer to the Tamil language logical constructs equivalent to the conditional, branch and loop statements in modern English based programming languages. Ezhil is the first freely available programming language in the Tamil language and one of many known non-English-based programming languages. The language was officially announced in July 2009, while it has been developed since late 2007.\n</p>",
        "infobox": {
            "name": "Ezhil",
            "logo": "File:Ezhil - A Tamil Programming Language Logo.png",
            "caption": "a Tamil programming language developed since 2007",
            "paradigm": [
                "interpreted language|interpreted",
                "imperative programming|imperative",
                "structured programming|structured"
            ],
            "year": "2007",
            "designer": "Muthu Annamalai",
            "developer": "Freelance|Independent/Freelance",
            "latest_release_version": "version 0.1",
            "latest_release_date": "start date and age|df|=|yes|2013|06|13",
            "typing": [
                "strong typing|strong",
                "dynamic typing|dynamic"
            ],
            "implementations": "Ezhil-Lang",
            "influenced_by": [
                "Logo (programming language)|Logo",
                "BASIC",
                "Python (programming language)|Python"
            ],
            "operating_system": [
                "Linux",
                "Microsoft Windows|Windows"
            ],
            "license": "GNU General Public License|GPLv3",
            "website": "ezhillang.org",
            "file_ext": ".n"
        }
    },
    {
        "id": 187,
        "name": "F* (programming language)",
        "url": "https://en.wikipedia.org/wiki/F*_(programming_language)",
        "summary": "<p><b>F*</b> (pronounced <i>F star</i>) is a functional programming language inspired by ML and aimed at program verification. Its type system includes dependent types, monadic effects, and refinement types. This allows expressing precise specifications for programs, including functional correctness and security properties. The F* type-checker aims to prove that programs meet their specifications using a combination of SMT solving and manual proofs. Programs written in F* can be translated to OCaml, F#, and C for execution. Previous versions of F* could also be translated to JavaScript.\n</p><p>The latest version of F* is written entirely in a common subset of F* and F#, and bootstraps in both OCaml and F#. It is open source (under the Apache License 2.0) and is under active development on GitHub.</p>",
        "infobox": {
            "name": "F*",
            "logo": "File:Fstar-official-logo-2015.png",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm: functional programming|functional",
                "imperative programming|imperative"
            ],
            "latest release version": "[https://github.com/FStarLang/FStar repository]",
            "typing": [
                "Dependent types|Dependent",
                "type inference|inferred",
                "static typing|static",
                "strong typing|strong"
            ],
            "influenced by": [
                "Coq",
                "Dafny (programming language)|Dafny",
                "F Sharp (programming language)|F#",
                "Lean (proof assistant)|Lean",
                "OCaml",
                "Standard ML"
            ],
            "operating system": [
                "Linux",
                "macOS",
                "Windows"
            ],
            "license": "Apache License 2.0",
            "website": "url|https://www.fstar-lang.org/",
            "designers": "Microsoft Research and Inria",
            "file_ext": ".fst"
        }
    },
    {
        "id": 188,
        "name": "F-Script (programming language)",
        "url": "https://en.wikipedia.org/wiki/F-Script_(programming_language)",
        "summary": "<p><b>F-Script</b> is an object-oriented scripting programming language for Apple's macOS operating system developed by Philippe Mougin.  F-Script is an interactive language based on Smalltalk, using macOS's native Cocoa API. </p>",
        "infobox": {
            "name": "F-Script",
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Object-oriented programming|object-oriented",
                "Array programming|array"
            ],
            "designer": "Philippe Mougin",
            "developer": [
                "Jonathan Mitchell",
                "Ilya Kulakov",
                "others"
            ],
            "released": "2009|06|28",
            "latest release version": "2.2.1",
            "latest release date": "2014|02|05",
            "typing": "Dynamic typing|dynamic",
            "platform": "x86",
            "operating system": "macOS",
            "license": "Open-source model|Open-source",
            "implementations": "F-Script",
            "influenced by": [
                "Smalltalk",
                "APL (programming language)|APL"
            ],
            "website": "https://github.com/pmougin/F-Script"
        }
    },
    {
        "id": 189,
        "name": "FAUST (programming language)",
        "url": "https://en.wikipedia.org/wiki/FAUST_(programming_language)",
        "summary": "<p><b>FAUST</b> (Functional AUdio STream) is a domain-specific purely functional programming language for implementing signal processing algorithms in the form of libraries, audio plug-ins, or standalone applications. A FAUST program denotes a signal processor: a mathematical function that is applied to some input signal and then fed out. </p>",
        "infobox": {
            "name": "FAUST",
            "developer": [
                "GRAME",
                "Centre National de Création Musicale"
            ],
            "author": [
                "Yann Orlarey",
                "Dominique Fober",
                "Stéphane Letz"
            ],
            "released": "release date|2002",
            "latest release version": "2.20.2",
            "latest release date": "release date|2020|01|14",
            "operating system": [
                "Linux",
                "OS X",
                "Microsoft Windows|Windows",
                "Unix"
            ],
            "genre": "Functional programming language for audio signal processing",
            "programming language": "C++",
            "license": "GNU General Public License|GPL",
            "website": "faust.grame.fr"
        }
    },
    {
        "id": 190,
        "name": "FFP (programming language)",
        "url": "https://en.wikipedia.org/wiki/FP_(programming_language)",
        "summary": "<p><b>FP</b> (short for <i>functional programming</i>) is a programming language created by John Backus to support the function-level programming paradigm. This allows eliminating named variables. The language was introduced in Backus's 1977 Turing Award paper, \"Can Programming Be Liberated from the von Neumann Style?\", subtitled \"a functional style and its algebra of programs.\" The paper sparked interest in functional programming research, eventually leading to modern functional languages, and not the function-level paradigm Backus had hoped. </p><p>In his Turing award paper, Backus described how the FP style is different from languages based on the lamba calculus:\n</p>\n<blockquote class=\"templatequote\"><p>An FP system is based on the use of a fixed set of combining forms called functional forms. These, plus simple definitions, are the only means of building new functions from existing ones; they use no variables or substitutions rules, and they become the operations of an associated algebra of programs. All the functions of an FP system are of one type: they map objects onto objects and always take a single argument.</p></blockquote>\n<p>FP itself never found much use outside of academia. In the 1980s Backus created a successor language, FL, which remained a research project.\n</p>",
        "infobox": {
            "name": "FP",
            "paradigm": "Function-level programming|Function-level",
            "year": "1977",
            "designer": "John Backus",
            "dialects": "FP84",
            "influenced_by": "APL (programming language)|APL",
            "influenced": [
                "FL (programming language)|FL",
                "Haskell (programming language)|Haskell"
            ]
        }
    },
    {
        "id": 191,
        "name": "FLOW-MATIC",
        "url": "https://en.wikipedia.org/wiki/FLOW-MATIC",
        "summary": "<p><b>FLOW-MATIC</b>, originally known as <b>B-0</b> (<b>Business Language version 0</b>), was the first English-like data processing language. It was developed for the UNIVAC I at Remington Rand under Grace Hopper from 1955 to 1959, and helped shape the development of COBOL. </p>",
        "infobox": {
            "name": "FLOW-MATIC",
            "paradigm": "imperative programming|imperative",
            "year": "start-date|1955",
            "designer": [
                "Remington Rand",
                "Grace Hopper"
            ],
            "influenced_by": "ARITH-MATIC",
            "influenced": [
                "MATH-MATIC",
                "AIMACO",
                "COBOL"
            ],
            "platform": "UNIVAC I"
        }
    },
    {
        "id": 192,
        "name": "FL (programming language)",
        "url": "https://en.wikipedia.org/wiki/FL_(programming_language)",
        "summary": "<p><b>FL</b> (short for \"Function Level\") is a functional programming language created at the IBM Almaden Research Center by John Backus, John Williams, and Edward Wimmers in the 1980s and documented in a report from 1989. FL was designed as a successor of Backus' earlier FP language, providing specific support for what Backus termed function-level programming. </p><p>FL is a dynamically typed strict functional programming language with throw and catch exception semantics much like in ML. Each function has an implicit history argument which is used for doing things like strictly functional input/output (I/O), but is also used for linking to C code. For doing optimization, there exists a type-system which is an extension of Hindley–Milner type inference.\n</p>",
        "infobox": {
            "name": "FL",
            "paradigm": [
                "Function-level programming|Function-level",
                "Functional programming|functional"
            ],
            "year": "1989",
            "designer": "John Backus<br>John Williams (Computer Scientist)|John Williams<br>Edward Wimmers",
            "typing": "Dynamic typing|Dynamic",
            "influenced_by": "FP (programming language)|FP"
        }
    },
    {
        "id": 193,
        "name": "FOCAL (programming language)",
        "url": "https://en.wikipedia.org/wiki/FOCAL_(programming_language)",
        "summary": "<p><b>FOCAL</b> is an interactive interpreted programming language based on JOSS and primarily used on Digital Equipment Corporation (DEC) PDP-series machines. The name is an acronym, altenately for <b>F</b>ormulating <b>O</b>n-Line <b>C</b>alculations in <b>A</b>lgebraic <b>L</b>anguage, or <b>FO</b>rmula <b>CAL</b>culator.</p><p>FOCAL is very similar to JOSS in terms of the commands it supports and the general syntax of the language. It differs in that many of JOSS' advanced features like ranges and user-defined functions were removed to simplify the parser. Some of the keywords were renamed so that they all start with a unique first letter. This allows users to type in programs using single-character statements, further reducing memory needs. This was an important consideration on the PDP-8, which was often limited to a few kilobytes (KB). </p><p>Like JOSS, and later BASICs, FOCAL on the PDP-8 was a complete environment that included a line editor, the interpreter, and input/output routines. The package as a whole was called <b>FOCAL-8</b>, which also ran on the PDP-5 and PDP-12. When ported to the PDP-11, the resulting <b>FOCAL-11</b> relied on the underlying operating system, RT-11, to provide file support and editing. The language definition was updated twice, to <b>FOCAL-69</b> and a very slightly modified <b>FOCAL-71</b>. A port to the Intel 8080 was also available.\n</p><p>FOCAL is historically notable as the language for the original versions of the early video games <i>Hamurabi</i> and <i>Lunar Lander</i>. Both were later ported to BASIC where they became much more famous. FOCAL was not popular outside the PDP platform and largely disappeared during the move to the VAX-11. It had a strong revival in the Soviet Union where PDP-11 clones were used as educational and home computers.\n</p>",
        "infobox": {
            "name": "FOCAL",
            "released": "1968",
            "developer": [
                "Richard Merrill",
                "Digital Equipment Corporation|DEC"
            ],
            "influenced by": "JOSS",
            "influenced": "BASIC-PLUS"
        }
    },
    {
        "id": 194,
        "name": "FOCUS",
        "url": "https://en.wikipedia.org/wiki/FOCUS",
        "summary": "<p><b>FOCUS</b> is a fourth-generation programming language (4GL) computer programming language and development environment that is used to build database queries. Produced by Information Builders Inc., it was originally developed for data handling and analysis on the IBM mainframe. Subsequently versions for minicomputers and such as the VAX and other platforms were implemented. FOCUS was later extended to personal computers and (in 1997) to the World Wide Web: the WebFOCUS product. </p>",
        "infobox": "N/A"
    },
    {
        "id": 195,
        "name": "FOIL (programming language)",
        "url": "https://en.wikipedia.org/wiki/FOIL_(programming_language)",
        "summary": "<p><b>FOIL</b> was the name for two different programming languages. </p>",
        "infobox": "N/A"
    },
    {
        "id": 196,
        "name": "FORMAC (programming language)",
        "url": "https://en.wikipedia.org/wiki/FORMAC",
        "summary": "<p><b>FORMAC</b>, the <b>FOR</b>mula <b>MA</b>nipulation <b>C</b>ompiler, was the first computer algebra system to have significant use. It was developed by Jean E. Sammet and her team, as an extension of FORTRAN IV. The compiler was implemented as a preprocessor taking the FORMAC program and converting it to a FORTRAN IV program which was in turn compiled without further user intervention.  </p><p>Initial development started in 1962 and was complete by April 1964. In November it was released to IBM customers.\n</p><p>FORMAC supported computation, manipulation, and use of symbolic expressions. In addition it supported rational arithmetic.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 197,
        "name": "FP (programming language)",
        "url": "https://en.wikipedia.org/wiki/FP_(programming_language)",
        "summary": "<p><b>FP</b> (short for <i>functional programming</i>) is a programming language created by John Backus to support the function-level programming paradigm. This allows eliminating named variables. The language was introduced in Backus's 1977 Turing Award paper, \"Can Programming Be Liberated from the von Neumann Style?\", subtitled \"a functional style and its algebra of programs.\" The paper sparked interest in functional programming research, eventually leading to modern functional languages, and not the function-level paradigm Backus had hoped. </p><p>In his Turing award paper, Backus described how the FP style is different from languages based on the lamba calculus:\n</p>\n<blockquote class=\"templatequote\"><p>An FP system is based on the use of a fixed set of combining forms called functional forms. These, plus simple definitions, are the only means of building new functions from existing ones; they use no variables or substitutions rules, and they become the operations of an associated algebra of programs. All the functions of an FP system are of one type: they map objects onto objects and always take a single argument.</p></blockquote>\n<p>FP itself never found much use outside of academia. In the 1980s Backus created a successor language, FL, which remained a research project.\n</p>",
        "infobox": {
            "name": "FP",
            "paradigm": "Function-level programming|Function-level",
            "year": "1977",
            "designer": "John Backus",
            "dialects": "FP84",
            "influenced_by": "APL (programming language)|APL",
            "influenced": [
                "FL (programming language)|FL",
                "Haskell (programming language)|Haskell"
            ]
        }
    },
    {
        "id": 198,
        "name": "F (programming language)",
        "url": "https://en.wikipedia.org/wiki/F_(programming_language)",
        "summary": "<p><b>F</b> is a modular, compiled, numeric programming language, designed for scientific programming and scientific computation. F was developed as a modern Fortran, thus making it a subset of Fortran 95. It combines both numerical and data abstraction features from these languages. F is also backwards compatible with Fortran 77, allowing calls to Fortran 77 programs. F was first included in the g95 compiler. </p>\n\n\n",
        "infobox": {
            "name": "F language",
            "developer": "The Fortran Company",
            "paradigm": [
                "procedural programming|procedural",
                "modular programming|modular"
            ],
            "typing": [
                "Type system|static",
                "Manifest typing|manifest"
            ],
            "influenced_by": "Fortran 95"
        }
    },
    {
        "id": 199,
        "name": "F Sharp (programming language)",
        "url": "https://en.wikipedia.org/wiki/F_Sharp_(programming_language)",
        "summary": "<p><b>F#</b> (pronounced <b>F sharp</b>) is a general purpose, strongly typed, multi-paradigm programming language that encompasses functional, imperative, and object-oriented programming methods. F# is most often used as a cross-platform Common Language Infrastructure (CLI) language, but it can also generate JavaScript and graphics processing unit (GPU) code.</p><p>F# is developed by the F# Software Foundation, Microsoft and open contributors. An open source, cross-platform compiler for F# is available from the F# Software Foundation. F# is also a fully supported language in Visual Studio and Xamarin Studio. Other tools supporting F# development include Mono, MonoDevelop, SharpDevelop, MBrace, WebSharper and JetBrains Rider. Plug-ins supporting F# exist for many widely used editors, most notably the <i>Ionide</i> extension for Atom and Visual Studio Code, and integrations for other editors such as Vim, and Emacs. </p><p>F# is a member of the ML language family and originated as a .NET Framework implementation of a core of the programming language OCaml. It has also been influenced by C#, \nPython, Haskell, Scala, and Erlang.\n</p>",
        "infobox": {
            "name": "F#",
            "logo": "Fsharp logo.png",
            "logo caption": "F# logomark",
            "paradigm": [
                "Programming paradigm#Multi-paradigm|Multi-paradigm: functional programming|functional",
                "imperative programming|imperative",
                "object-oriented programming|object-oriented",
                "metaprogramming",
                "Reflection (computer programming)|reflective",
                "concurrent programming|concurrent"
            ],
            "family": "ML (programming language)|ML",
            "released": [
                "2005 ",
                "version 1.0"
            ],
            "designer": [
                "Don Syme",
                "Microsoft Research"
            ],
            "developer": [
                "Microsoft",
                "F Sharp Software Foundation|The F# Software Foundation"
            ],
            "latest release version": "4.7",
            "latest release date": "2019|09|23",
            "latest preview version": "5.0 preview",
            "latest preview date": "2019|04|02",
            "typing": [
                "Static typing|Static",
                "Strong and weak typing|strong",
                "Type inference|inferred"
            ],
            "influenced by": [
                "C Sharp (programming language)|C#",
                "Erlang (programming language)|Erlang",
                "Haskell (programming language)|Haskell",
                "ML (programming language)|ML",
                "OCaml",
                "Python (programming language)|Python",
                "Scala (programming language)|Scala"
            ],
            "influenced": [
                "C Sharp (programming language)|C#",
                "Elm (programming language)|Elm",
                "F* (programming language)|F*",
                "LiveScript"
            ],
            "operating system": [
                "Cross-platform: .NET Framework",
                "Mono (software)|Mono"
            ],
            "license": "MIT License",
            "website": "fsharp.org",
            "wikibooks": "F Sharp Programming",
            "file ext": [
                ".fs",
                ".fsi",
                ".fsx",
                ".fsscript"
            ]
        }
    },
    {
        "id": 200,
        "name": "Factor (programming language)",
        "url": "https://en.wikipedia.org/wiki/Factor_(programming_language)",
        "summary": "<p><b>Factor</b> is a stack-oriented programming language created by Slava Pestov. Factor is dynamically typed and has automatic memory management, as well as powerful metaprogramming features. The language has a single implementation featuring a self-hosted optimizing compiler and an interactive development environment. The Factor distribution includes a large standard library. </p>",
        "infobox": {
            "name": "Factor",
            "logo": "File:NewFactorLogo.png|200px",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: functional programming|functional",
                "concatenative programming language|concatenative",
                "stack-oriented programming language|stack-oriented"
            ],
            "year": "2003",
            "developer": "Slava Pestov",
            "latest_release_version": "0.98",
            "latest_release_date": "release date|mf|=|yes|2018|7|31",
            "typing": [
                "strong typing|strong",
                "dynamic typing|dynamic"
            ],
            "influenced_by": [
                "Joy (programming language)|Joy",
                "Forth (programming language)|Forth",
                "Lisp (programming language)|Lisp",
                "Self (programming language)|Self"
            ],
            "operating_system": [
                "Microsoft Windows|Windows",
                "macOS",
                "Linux"
            ],
            "license": "BSD license",
            "website": "[http://factorcode.org/ factorcode.org]"
        }
    },
    {
        "id": 201,
        "name": "Fantom (programming language)",
        "url": "https://en.wikipedia.org/wiki/Fantom_(programming_language)",
        "summary": "<p><b>Fantom</b> is a general purpose object-oriented programming language created by Brian and Andy Frank that runs on the Java Runtime Environment (JRE), JavaScript, and the .NET Common Language Runtime (CLR)  (.NET support is considered \"prototype\" status).  Its primary design goal is to provide a standard library API that abstracts away the question of whether the code will ultimately run on the JRE or CLR. Like C# and Java, Fantom uses a curly brace syntax. The language supports functional programming through closures and concurrency through the Actor model. Fantom takes a \"middle of the road\" approach to its type system, blending together aspects of both static and dynamic typing. </p>",
        "infobox": {
            "name": "Fantom",
            "logo": "File:Fantom-logo.png",
            "paradigm": "Multi-paradigm programming language|multi-paradigm",
            "year": "2005",
            "developer": [
                "Brian Frank",
                "Andy Frank"
            ],
            "latest_release_version": "1.0.74",
            "latest_release_date": "2020|03|02",
            "typing": [
                "static typing|static",
                "dynamic typing|dynamic"
            ],
            "influenced_by": [
                "C Sharp (programming language)|C#",
                "Java (programming language)|Java",
                "Scala (programming language)|Scala",
                "Ruby (programming language)|Ruby",
                "Erlang (programming language)|Erlang"
            ],
            "license": "Academic Free License version 3.0",
            "file ext": [
                ".fan",
                ".fwt",
                ".pod"
            ],
            "website": "www.fantom.org"
        }
    },
    {
        "id": 202,
        "name": "Fjölnir (programming language)",
        "url": "https://en.wikipedia.org/wiki/Fj%C3%B6lnir_(programming_language)",
        "summary": "<p><b>Fjölnir</b> (also <b>Fjolnir</b> or <b>Fjoelnir</b>) is a programming language developed by professor Snorri Agnarsson of computer science at Háskóli Íslands (University of Iceland) that was mostly used in the 1980s. The source files usually have the extension <code>fjo</code> or <code>sma</code>. </p>",
        "infobox": {
            "name": "Fjölnir",
            "paradigm": [
                "procedural",
                "Object-oriented programming|object-oriented"
            ],
            "typing": [
                "strong",
                "dynamic"
            ],
            "scope": "lexical",
            "year": "1980s",
            "designer": "Snorri Agnarsson",
            "operating_system": "MS-DOS",
            "file_ext": [
                ".fjo",
                ".fjv",
                ".sma",
                ".ein"
            ]
        }
    },
    {
        "id": 203,
        "name": "Flavors (programming language)",
        "url": "https://en.wikipedia.org/wiki/Flavors_(programming_language)",
        "summary": "<p><b>Flavors</b>, an early object-oriented extension to Lisp developed by Howard Cannon at the MIT Artificial Intelligence Laboratory for the Lisp machine and its programming language Lisp Machine Lisp, was the first programming language to include mixins. Symbolics used it for its Lisp machines, and eventually developed it into <b>New Flavors</b>; both the original and new Flavors were message passing OO models. It was hugely influential in the development of the Common Lisp Object System (CLOS).</p><p>Implementations of Flavors are also available for Common Lisp.</p><p>New Flavors replaced message sending with calling generic functions. </p><p>Flavors offers <code class=\"mw-highlight mw-highlight-lang-text\" id=\"\" style=\"\" dir=\"ltr\">:before</code> and <code class=\"mw-highlight mw-highlight-lang-text\" id=\"\" style=\"\" dir=\"ltr\">:after</code> daemons with the default method combination (called <code class=\"mw-highlight mw-highlight-lang-text\" id=\"\" style=\"\" dir=\"ltr\">:daemon</code>).\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 204,
        "name": "Flex (language)",
        "url": "https://en.wikipedia.org/wiki/Flex_(programming_language)",
        "summary": "<p>In computing, the <b>FLEX language</b> was developed by Alan Kay in the late 1960s while exploring ideas that would later evolve into the Smalltalk programming language.</p>",
        "infobox": "N/A"
    },
    {
        "id": 205,
        "name": "Formula language",
        "url": "https://en.wikipedia.org/wiki/Formula_language",
        "summary": "<p>The <b>Formula language</b> is a scripting language used by Lotus Notes. It is often referred to as <b>@Formula</b> language (pronounced <i>at-formula</i>) because many language elements start with the @-character. Here is an example of a selection formula:\n</p>\n<pre>SELECT @NoteId = \"NT0050D26\"\n</pre>\n<p>It was created by Ray Ozzie during the early development of Lotus Notes. He borrowed the compiler and decompiler from the Lotus 1-2-3 spreadsheet, but unlike the spreadsheet language Formula Language was designed primarily for string and list processing, not numerical processing.  It was originally a Functional programming language with unique text list-handling features inspired by Ray Ozzie's prior use of Icon and Lisp.\n</p><p>The Formula language engine was rewritten by Damien Katz for Notes and Domino 6. New features were added to the language, such as looping and dynamic execution, and performance was improved.</p><p>The Formula language has two parts:\n</p>\n<ul><li><i>@Functions</i> for calculations and simple logic</li>\n<li><i>@Commands</i> for performing actions in the user interface</li></ul><p><i>@Functions</i> can be used in several places throughout Lotus Notes. The most important uses are:\n</p>\n<ul><li>to select documents to show to the user in a view (a kind of index) or to select documents for further processing. In this case, the formula will evaluate to a 'true' (selected) or 'false' value (not selected) for each document.</li>\n<li>to provide default values for fields, to transform the data entered by the user (like stripping off redundant spaces) and to validate this data.</li>\n<li>to get a list of values from a Notes database or even from a relational database (using ODBC). This may be used to provide a user with a list of values to choose from.</li>\n<li>to process a set of documents. The formula is placed in an agent, a program or macro that can be started by a user or by the Notes server according to a schedule. When the agent is triggered, the formula executes for each selected document (this a very limited form of a loop). This is an efficient way of changing lots of documents, if the logic is not too complicated. In case of complicated changes, LotusScript is used.</li></ul><p><i>@Commands</i> are like menu commands: they perform actions in the Lotus Notes client. Examples of actions are:\n</p>\n<ul><li>opening a Notes database</li>\n<li>creating an e-mail</li>\n<li>putting the cursor in a specific data-entry field</li>\n<li>closing a window</li>\n<li>starting an agent</li></ul><p>@Commands are primarily used in formulas that are triggered by user action, such as in button formulas. It is possible to combine them with @Functions, for example by making execution of an @command conditional on a field value.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 206,
        "name": "Forth (programming language)",
        "url": "https://en.wikipedia.org/wiki/Forth_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Forth</b> is an imperative stack-based computer programming language and environment originally designed by Chuck Moore. Language features include structured programming, reflection (the ability to examine and modify program structure during execution), concatenative programming (functions are composed with juxtaposition) and extensibility (the programmer can create new commands). Although not an acronym, the language's name is sometimes spelled with all capital letters as FORTH, following the customary usage during its earlier years.\n</p><p>A procedural programming language without type checking, Forth features both interactive execution of commands (making it suitable as a shell for systems that lack a more formal operating system) and the ability to compile sequences of commands for later execution. For much of Forth's existence, the standard technique was to compile to threaded code, but there are modern implementations that generate optimized machine code like other language compilers.\n</p><p>Forth is used in the Open Firmware boot loader, in space applications such as the Philae spacecraft, and in other embedded systems which involve interaction with hardware. The bestselling 1986 computer game <i>Starflight</i>, from Electronic Arts, was written with a custom Forth.</p><p>The free software Gforth implementation is actively maintained, as are several commercially supported systems. \n</p>",
        "infobox": {
            "name": "Forth",
            "paradigm": [
                "Procedural programming|Procedural",
                "Stack-oriented programming|stack-oriented",
                "Reflection (computer science)|reflective",
                "Concatenative programming language|concatenative"
            ],
            "year": "start date and age|1970",
            "designer": "Charles H. Moore",
            "typing": "Data type|typeless",
            "implementations": [
                "SwiftForth (Forth",
                "Inc.)<br>Gforth (Free software)<br>VFX Forth (MicroProcessor Engineering)"
            ],
            "influenced_by": [
                "Burroughs large systems",
                "Lisp (programming language)|Lisp",
                "APL (programming language)|APL"
            ],
            "influenced": [
                "Factor (programming language)|Factor",
                "Joy (programming language)|Joy",
                "RPL (programming language)|RPL",
                "REBOL"
            ]
        }
    },
    {
        "id": 207,
        "name": "Fortran",
        "url": "https://en.wikipedia.org/wiki/Fortran",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Fortran</b> (<span></span>; formerly <b>FORTRAN</b>, derived from <i>Formula Translation</i>) is a general-purpose, compiled imperative programming language that is especially suited to numeric computation and scientific computing.\n</p><p>Originally developed by IBM in the 1950s for scientific and engineering applications, FORTRAN came to dominate this area of programming early on and has been in continuous use for over six decades in computationally intensive areas such as numerical weather prediction, finite element analysis, computational fluid dynamics, geophysics, computational physics, crystallography and computational chemistry. It is a popular language for high-performance computing and is used for programs that benchmark and rank the world's fastest supercomputers.</p><p>Fortran encompasses a lineage of versions, each of which evolved to add extensions to the language while usually retaining compatibility with prior versions.  Successive versions have added support for structured programming\nand processing of character-based data (FORTRAN 77), array programming, modular programming and generic programming (Fortran 90), high performance Fortran (Fortran 95), object-oriented programming (Fortran 2003), concurrent programming (Fortran 2008), and native parallel computing capabilities (Coarray Fortran 2008/2018).\n</p><p>Fortran's design was the basis for many other programming languages. Amongst the better-known is BASIC, which is based on FORTRAN II with a number of syntax cleanups, notably better logical structures, and other changes to work more easily in an interactive environment.</p>\n\n\n",
        "infobox": {
            "name": "Fortran",
            "logo": "File:Fortran acs cover.jpeg|150px",
            "logo caption": [
                "''The Fortran Automatic Coding System for the IBM 704'' (15 October 1956)",
                "the first programmer's reference manual for Fortran"
            ],
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Structured programming|structured",
                "Imperative programming|imperative (Procedural programming|procedural",
                "Object-oriented programming|object-oriented)",
                "Generic programming|generic",
                "Array programming|array"
            ],
            "year": "1957",
            "designer": "John Backus",
            "developer": "John Backus and IBM",
            "latest release version": "Fortran 2018 (ISO/IEC 1539-1:2018)",
            "latest release date": "2018|11|28",
            "typing": [
                "Strong and weak typing|strong",
                "Type system|static",
                "Manifest typing|manifest"
            ],
            "implementations": [
                "Absoft Fortran Compilers|Absoft",
                "Cray",
                "GNU Fortran|GFortran",
                "G95",
                "IBM XL Fortran",
                "Intel Fortran Compiler|Intel",
                "Hitachi",
                "Lahey/Fujitsu",
                "Numerical Algorithms Group",
                "Watcom C compiler|Open Watcom",
                "PathScale",
                "PGI compiler|PGI",
                "Silverfrost FTN95|Silverfrost",
                "Oracle Solaris Studio",
                "Visual Fortran",
                "others"
            ],
            "influenced_by": "Speedcoding",
            "influenced": [
                "ALGOL 58",
                "BASIC",
                "C (programming language)|C",
                "Chapel (programming language)|Chapel",
                "CMS-2 (programming language)|CMS-2",
                "Fortress (programming language)|Fortress",
                "PL/I",
                "PACT I",
                "MUMPS",
                "IDL (programming language)|IDL",
                "Ratfor"
            ],
            "file_ext": [
                "code|.f ",
                "code|.for ",
                "code|.f90"
            ]
        }
    },
    {
        "id": 208,
        "name": "Fortress (programming language)",
        "url": "https://en.wikipedia.org/wiki/Fortress_(programming_language)",
        "summary": "<p><b>Fortress</b> is a discontinued experimental programming language for high-performance computing, created by Sun Microsystems with funding from DARPA's High Productivity Computing Systems project. One of the language designers was Guy L. Steele Jr., whose previous work includes Scheme, Common Lisp, and Java. </p>",
        "infobox": {
            "name": "Fortress",
            "year": "2006",
            "developer": "Sun Labs",
            "discontinued": "yes",
            "latest_release_version": "1.0_5033",
            "latest_release_date": "2011|09|07",
            "typing": "Static typing|Static",
            "influenced_by": [
                "Fortran",
                "Scala (programming language)|Scala",
                "Haskell (programming language)|Haskell"
            ],
            "operating_system": "Cross-platform",
            "platform": "Java SE 1.6+",
            "license": "BSD licenses|BSD",
            "website": "https://github.com/stokito/fortress-lang"
        }
    },
    {
        "id": 209,
        "name": "Franz Lisp",
        "url": "https://en.wikipedia.org/wiki/Franz_Lisp",
        "summary": "<p>In computer programming, <b>Franz Lisp</b> is a discontinued Lisp programming language system written at the University of California, Berkeley (UC Berkeley, UCB) by Professor Richard Fateman and several students, based largely on Maclisp and distributed with the Berkeley Software Distribution (BSD) for the Digital Equipment Corporation (DEC) VAX minicomputer. Piggybacking on the popularity of the BSD package, Franz Lisp was probably the most widely distributed and used Lisp system of the 1970s and 1980s.</p><p>The name is a pun on composer Franz Liszt. </p><p>It was written specifically to be a host for running the Macsyma computer algebra system on VAX. The project began at the end of 1978, soon after UC Berkeley took delivery of their first VAX 11/780 (named Ernie CoVax, after Ernie Kovacs, the first of many systems with pun names at UCB). Franz Lisp was available free of charge to educational sites, and was also distributed on Eunice, a Berkeley Unix emulator that ran on VAX VMS.\n</p>",
        "infobox": {
            "name": "Franz Lisp",
            "screenshot": "4.3 BSD UWisc VAX Emulation Lisp Manual.png",
            "screenshot caption": [
                "4.3BSD|4.3 BSD from the University of Wisconsin",
                "displaying a Franz Lisp man page"
            ],
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Functional programming|functional",
                "Procedural programming|procedural",
                "Reflection (computer programming)|reflective",
                "Metaprogramming|meta"
            ],
            "family": "Lisp (programming language)|Lisp",
            "designers": [
                "Richard Fateman",
                "John Foderaro",
                "Kevin Layer",
                "Keith Sklower"
            ],
            "developer": [
                "University of California",
                "Berkeley"
            ],
            "released": "1980",
            "latest release version": "Final",
            "latest release date": "1988",
            "typing": [
                "Dynamic typing|Dynamic",
                "Strong and weak typing|strong"
            ],
            "scope": [
                "Scope (programming)|Static",
                "lexical"
            ],
            "programming language": [
                "C (programming language)|C",
                "Franz Lisp"
            ],
            "discontinued": "Yes",
            "platform": [
                "VAX",
                "Motorola 68000|68000"
            ],
            "operating system": [
                "OpenVMS|VMS",
                "Unix",
                "Unix-like",
                "Eunice (software)|Eunice",
                "SunOS"
            ],
            "license": [
                "Proprietary software|Proprietary",
                "freeware"
            ],
            "influenced by": [
                "Lisp (programming language)|Lisp",
                "Maclisp",
                "Common Lisp"
            ],
            "influenced": "Allegro Common Lisp"
        }
    },
    {
        "id": 210,
        "name": "Friendly interactive shell",
        "url": "https://en.wikipedia.org/wiki/Friendly_interactive_shell",
        "summary": "<p><span></span> </p>\n<p>The <b>friendly interactive shell</b> (<b>fish</b>) is a Unix shell that attempts to be more interactive and user-friendly than those with a longer history (i.e. most other Unix shells) or those formulated as function-compatible replacements for the aforementioned (e.g. zsh, the Falstad shell). The design goal of fish is to give the user a rich set of powerful features in a way that is easy to discover, remember, and use. fish is considered an \"exotic shell\", in that its syntax derives from neither the Bourne shell (ksh, Bash, zsh) nor the C shell (csh, tcsh). Also unlike previous shells, which disable certain features by default to save system resources, fish enables all features by default.\n</p>",
        "infobox": {
            "name": "fish",
            "logo": "Fish shell logo ascii.png",
            "screenshot": "Friendlyinteractiveshell.png",
            "screenshot size": "280px",
            "caption": "The friendly interactive shell",
            "author": "Axel Liljencrantz",
            "developer": [
                "ridiculousfish",
                "siteshwar",
                "JanKanis"
            ],
            "released": "release date and age|df|=|yes|2005|02|13",
            "latest release version": "3.1.2",
            "latest release date": "2020|04|29",
            "operating system": "Unix-like",
            "genre": "Unix shell",
            "license": "GPL v2",
            "website": "http://fishshell.com"
        }
    },
    {
        "id": 211,
        "name": "Futhark (programming language)",
        "url": "https://en.wikipedia.org/wiki/Futhark_(programming_language)",
        "summary": "<p><b>Futhark</b> is a functional data parallel array programming language originally developed at DIKU as part of the HIPERFIT project.  It focuses on enabling data parallel programs written in a functional style to be executed with high performance on massively parallel hardware, in particular on GPUs.  Futhark is strongly inspired by NESL, but imposes constraints on how parallelism can be expressed in order to enable more aggressive compiler optimisations.  In particular, irregular nested data parallelism is not supported.</p>",
        "infobox": {
            "name": "Futhark",
            "paradigm": [
                "array programming|Array",
                "Functional programming|functional"
            ],
            "year": "2014",
            "designer": [
                "Troels Henriksen",
                "Cosmin Oancea",
                "Martin Elsman"
            ],
            "typing": [
                "static typing|static",
                "strong typing|strong"
            ],
            "influenced_by": [
                "APL programming language|APL",
                "Haskell (programming language)|Haskell",
                "NESL",
                "Standard ML"
            ],
            "operating_system": "Cross-platform",
            "license": "ISC",
            "website": "https://futhark-lang.org"
        }
    },
    {
        "id": 212,
        "name": "G-code",
        "url": "https://en.wikipedia.org/wiki/G-code",
        "summary": "<p><b>G-code</b> (also <i>RS-274</i>), which has many variants, is the common name for the most widely used computer numerical control (CNC) programming language. It is used mainly in computer-aided manufacturing to control automated machine tools. </p><p>G-code is a language in which people tell computerized machine tools how to make something. The \"how\" is defined by G-code instructions provided to a machine controller (industrial computer) that tells the motors where to move, how fast to move, and what path to follow. The two most common situations are that, within a machine tool such as a lathe or mill, a cutting tool is moved according to these instructions through a toolpath cutting away material to leave only the finished workpiece and/or, an unfinished workpiece is precisely positioned in any of up to 9 axes around the 3 dimensions relative to a toolpath and, either or both can move relative to each other. The same concept also extends to noncutting tools such as forming or burnishing tools, photoplotting, additive methods such as 3D printing, and measuring instruments.\n</p>",
        "infobox": {
            "name": "machine codes",
            "file ext": [
                ".gcode",
                ".mpt",
                ".mpf",
                ".nc and several others"
            ],
            "paradigm": [
                "Procedural programming|Procedural",
                "Imperative programming|Imperative"
            ],
            "released": "1950s (first edition)",
            "designer": "Massachusetts Institute of Technology",
            "implementations": [
                "many",
                "mainly Siemens Sinumerik",
                "FANUC",
                "Haas Automation|Haas",
                "Heidenhain",
                "Yamazaki Mazak Corporation|Mazak. Generally there is one international standard—International Organization for Standardization|ISO 6983."
            ]
        }
    },
    {
        "id": 213,
        "name": "GAP computer algebra system",
        "url": "https://en.wikipedia.org/wiki/GAP_(computer_algebra_system)",
        "summary": "<p><b>GAP</b> (Groups, Algorithms and Programming) is a computer algebra system for computational discrete algebra with particular emphasis on computational group theory. </p>",
        "infobox": {
            "name": "GAP",
            "developer": "plainlist|\n* University of St Andrews\n* RWTH Aachen University|RWTH Aachen\n* Braunschweig University of Technology|TU Braunschweig\n* Colorado State University\n* University of Kaiserslautern|TU Kaiserslautern",
            "latest_release_version": "4.11.0",
            "latest_release_date": "start date and age|2020|03|06",
            "programming language": "C (programming language)|C",
            "operating_system": "Cross-platform",
            "genre": "Computer algebra system",
            "license": "GNU General Public License",
            "website": "https://www.gap-system.org/"
        }
    },
    {
        "id": 214,
        "name": "GDScript",
        "url": "https://en.wikipedia.org/wiki/Godot_(game_engine)",
        "summary": "<p><b>Godot</b> is a 2D and 3D, cross-platform, free and open-source game engine released under the MIT license. It was initially developed for several companies in Latin America prior to its public release. The development environment runs on multiple operating systems including Linux, macOS, and Windows. Godot can create games targeting PC, mobile, and web platforms. </p>",
        "infobox": {
            "name": "Godot Engine",
            "logo": "Godot logo.svg",
            "logo size": "200px",
            "screenshot": "Godot 3.1 screenshot.png",
            "caption": "A screenshot of the editor in Godot 3.1",
            "author": [
                "Juan Linietsky",
                "Ariel Manzur"
            ],
            "released": "2014|01|14",
            "latest_release_version": "3.2.2",
            "latest_release_date": "2020|6|26",
            "latest preview version": "3.2.3 beta 1",
            "latest preview date": "2020|7|15",
            "programming_language": [
                "C (programming language)|C",
                "C++"
            ],
            "operating system": [
                "Microsoft Windows|Windows",
                "macOS",
                "Linux",
                "FreeBSD",
                "OpenBSD",
                "Haiku (operating system)|Haiku"
            ],
            "platform": [
                "Linux",
                "macOS",
                "Microsoft Windows|Windows",
                "Berkeley Software Distribution|BSD",
                "Haiku (operating system)|Haiku",
                "iOS",
                "Android (operating system)|Android",
                "HTML5",
                "WebAssembly",
                "Xbox One",
                "Universal Windows Platform"
            ],
            "language": "Multilingual",
            "genre": "Game engine",
            "license": "MIT License",
            "alexa": [
                "24,041 small|nowrap|(Global",
                "|as of|2020|05|12|alt|=|May 2020|) nowrap|(Global",
                "|as of|2020|05|12|alt|=|May 2020|) as of|2020|05|12|alt|=|May 2020 )"
            ],
            "website": "official URL"
        }
    },
    {
        "id": 215,
        "name": "GEORGE (programming language)",
        "url": "https://en.wikipedia.org/wiki/GEORGE_(programming_language)",
        "summary": "<p><b>GEORGE</b> is a programming language invented by Charles Leonard Hamblin in 1957.</p><p>It was designed around a push-down pop-up stack for arithmetic operations, and employed reverse Polish notation. </p><p>The language included loops, subroutines, conditionals, vectors, and matrices.\n</p><p>Algebraic expressions were written in reverse Polish notation; thus, <span><span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle a+b}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <mi>a</mi>\n        <mo>+</mo>\n        <mi>b</mi>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle a+b}</annotation>\n  </semantics></math></span></span> was written <code>a b +</code>, and similarly for the other arithmetic operations of subtraction, multiplication, and division.\n</p><p>The algebraic expression <span><span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle ax^{2}+bx+c}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <mi>a</mi>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>2</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mi>b</mi>\n        <mi>x</mi>\n        <mo>+</mo>\n        <mi>c</mi>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle ax^{2}+bx+c}</annotation>\n  </semantics></math></span></span> was written <code>a x dup × × b x × + c +</code>, where '<code>dup</code>' meant 'duplicate the value'.\n</p><p>Following the reverse Polish form, an assignment statement to evaluate the formula <span><span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle y=ax^{2}+bx+c}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <mi>y</mi>\n        <mo>=</mo>\n        <mi>a</mi>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>2</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mi>b</mi>\n        <mi>x</mi>\n        <mo>+</mo>\n        <mi>c</mi>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle y=ax^{2}+bx+c}</annotation>\n  </semantics></math></span></span> was written as <code>a x dup × × b x × + c + (y)</code>.\n</p><p>The computer evaluated the expression as follows: the values of <code>a</code>, then <code>x</code>, were pushed onto the top of the accumulator stack; '<code>dup</code>' caused a copy of the top-most value (<code>x</code>) to be pushed onto the top of the accumulator stack; Multiply (<code>×</code>) caused the top two values, namely, <code>x</code> and <code>x</code>, to be removed (popped) and multiplied, returning the product to the top of the accumulator stack.  The second multiply (<code>×</code>) then caused the top two values on the stack (namely, <code>a</code> and <code>x2</code>) to be popped and multiplied, and the product (<code>a×x2</code>) to be pushed onto the top of the accumulator stack.  And so on the remaining components of the expression.  The final operation, namely (<code>y</code>), returned the value of the expression to storage without changing the status of the accumulator stack.\n</p><p>Assuming that the value on the top of the accumulator stack was not required immediately, it would be removed (cleared) by using the operator (<code>;</code>).\n</p><p>The following program reads in eight values and forms their sum:\n</p>\n<pre>0,\n1, 8 rep (j)\n   R +\n]\n(P)\n</pre>\n<dl><dd>The first line initialises the sum by pushing the value zero onto the top of the accumulator stack.</dd>\n<dd>The second line introduces a loop, is spoken as \"for 1 to 8 repeat for j\", and is terminated by the square bracket.</dd>\n<dd>In the third line, R causes one number to be read in and pushed onto the top of the accumulator stack, and the plus sign (+) causes that value to be added to the (partial) sum, leaving only the partial sum on the top of the accumulator stack.</dd>\n<dd>After the loop terminates, the (P) causes the final sum to be punched on a card.</dd></dl><p>Manipulation of vectors and matrices requires subscript notation.  In GEORGE, the subscript(s) preceded the vector or matrix name.  Thus A(j) was written <code>j | A</code>.\nThe following program reads in vector <i>a</i> of 10 values, then forms the squares of those values, and finally prints those values.\n</p>\n<pre>1, 10 R1 (a)\n1, 10 rep (j)\n   j | a dup * j | (a) ;\n]\n1, 10 P1 (a)\n</pre>\n<dl><dd>In the program, the first line is a vector read that reads in the ten values into a(1) through a(10).</dd>\n<dd>The second line introduces a loop to run through the ten values of j.</dd>\n<dd>The third line fetches a(j), duplicates it, multiplies those two values giving the square, and then stores it in  a(j).  Note the semicolon (;), which clears (or cancels) the top entry in the accumulator stack.  Were this not done, the accumulator would gradually fill up with the squares of the values.</dd>\n<dd>The final line is a vector punch (i.e., print) to write out the ten squares.</dd></dl><p>The above GEORGE coding table assisted in transcribing a program onto punch cards.\n</p><p>Conditional operations were written as jumps, as follows:\nif a &gt; 0 go to 5 (which transfers to label 5 if a is greater than zero)\nwould be written\n</p>\n<pre>0 a &gt; 5 ↑ </pre>\n<p>Label 5 was indicated by including *5 elsewhere in the program.\nUnconditional transfers were written 5↑\n</p><p>Subroutine calls were made with the down arrow, .g., to call subroutine labelled 17, write 17↓, where the label 17 was encoded using column 3 of the above table.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 216,
        "name": "GLSL",
        "url": "https://en.wikipedia.org/wiki/OpenGL_Shading_Language",
        "summary": "<p><b>OpenGL Shading Language</b> (<b>GLSL</b>) is a high-level shading language with a syntax based on the C programming language. It was created by the OpenGL ARB (OpenGL Architecture Review Board) to give developers more direct control of the graphics pipeline without having to use ARB assembly language or hardware-specific languages. </p>",
        "infobox": "N/A"
    },
    {
        "id": 217,
        "name": "GNU E",
        "url": "https://en.wikipedia.org/wiki/GNU_E",
        "summary": "<p><b>GNU E</b> is an extension of C++ designed for writing software systems to support  persistent applications. It was designed as part of the\nExodus project.\n</p>",
        "infobox": {
            "name": "GNU E",
            "paradigm": "object-oriented programming|object-oriented",
            "year": "1991",
            "latest release version": "2.3.3",
            "latest release date": [
                "May 28",
                "1993"
            ],
            "typing": "strong typing|strong",
            "influenced_by": "C++",
            "operating system": "Cross-platform",
            "license": "GNU General Public License Version 2",
            "website": "ftp://ftp.cs.wisc.edu/exodus/E/"
        }
    },
    {
        "id": 218,
        "name": "GNU Guile",
        "url": "https://en.wikipedia.org/wiki/GNU_Guile",
        "summary": "<p><b>GNU Ubiquitous Intelligent Language for Extensions</b> (<b>GNU Guile</b>) is the preferred extension language system for the GNU Project and features an implementation of the programming language Scheme. Its first version was released in 1993.  In addition to large parts of Scheme standards, Guile Scheme includes modularized extensions for many different programming tasks.</p><p>For extending programs, Guile offers <i>libguile</i> which allows the language to be embedded in other programs, and integrated closely through the C language application programming interface (API); similarly, new data types and subroutines defined through the C API can be made available as extensions to Guile.</p><p>Guile is used in programs such as GnuCash, LilyPond, GNU Guix, GNU Debugger, GNU TeXmacs and Google's schism.</p>",
        "infobox": {
            "name": "GNU Guile",
            "logo": "GNU-Guile-logo.svg",
            "family": "Lisp (programming language)|Lisp",
            "designer": [
                "Aubrey Jaffer",
                "Tom Lord",
                "Miles Bader"
            ],
            "developer": "GNU Project",
            "released": "1993",
            "latest release version": "3.0.3",
            "latest release date": "2020|06|21",
            "platform": [
                "IA-32",
                "x86-64"
            ],
            "operating system": [
                "Linux",
                "BSD",
                "Windows (through MinGW or Cygwin)"
            ],
            "license": "GNU Lesser General Public License|GPL",
            "file ext": ".scm .go (Guile object)",
            "website": "//gnu.org/software/guile",
            "influenced by": [
                "Lisp (programming language)|Lisp",
                "Scheme (programming language)|Scheme",
                "SCM (Scheme implementation)|SCM"
            ]
        }
    },
    {
        "id": 219,
        "name": "GNU Octave",
        "url": "https://en.wikipedia.org/wiki/GNU_Octave",
        "summary": "<p><b>GNU Octave</b> is software featuring a high-level programming language, primarily intended for numerical computations. Octave helps in solving linear and nonlinear problems numerically, and for performing other numerical experiments using a language that is mostly compatible with MATLAB. It may also be used as a batch-oriented language. Since it is part of the GNU Project, it is free software under the terms of the GNU General Public License.\n</p><p>Other free alternatives to MATLAB include Scilab and FreeMat. Octave is more compatible with MATLAB than Scilab is and FreeMat has not been updated since June 2013.</p>",
        "infobox": {
            "name": "GNU Octave",
            "logo": "File:Gnu-octave-logo.svg|100px",
            "screenshot": "GNUOctave430.png",
            "caption": "GNU Octave 4.3.0+ running on Linux",
            "developer": "John W. Eaton and many others",
            "released": "1988",
            "latest release version": "5.2.0",
            "latest release date": "2020|02|03",
            "programming language": [
                "C (programming language)|C",
                "C++",
                "Fortran"
            ],
            "operating system": [
                "Windows",
                "macOS",
                "Linux",
                "Berkeley Software Distribution|BSD"
            ],
            "language count": "19",
            "language footnote": "Citation needed|date|=|January 2016",
            "genre": "List of numerical analysis software|Scientific computing",
            "license": "GNU General Public License|GNU GPLv3",
            "website": "https://gnu.org/software/octave/"
        }
    },
    {
        "id": 220,
        "name": "GPSS",
        "url": "https://en.wikipedia.org/wiki/GPSS",
        "summary": "<p><b>General Purpose Simulation System</b> (<b>GPSS</b>) is a discrete time simulation general-purpose programming language, where a simulation clock advances in discrete steps. A system is modelled as transactions enter the system and are passed from one service (represented by blocks) to another. It is used primarily as a process flow oriented simulation language; this is particularly well-suited for problems such as a factory. </p>",
        "infobox": "N/A"
    },
    {
        "id": 221,
        "name": "GRASS (programming language)",
        "url": "https://en.wikipedia.org/wiki/GRASS_(programming_language)",
        "summary": "<p><b>GRASS</b> (<i>GRAphics Symbiosis System</i>) is a programming language created to script 2D vector graphics animations. GRASS was similar to BASIC in syntax, but added numerous instructions for specifying 2D object animation, including scaling, translation and rotation over time. These functions were directly supported by the Vector General 3D graphics terminal GRASS was written for. It quickly became a hit with the artistic community who were experimenting with the new medium of computer graphics, and is most famous for its use by Larry Cuba to create the original \"attacking the Death Star will not be easy\" animation in <i>Star Wars</i> (1977). </p><p>As part of a later partnership with Midway Games, the language was ported to the Midway's Z-80-based Z Box. This machine used raster graphics and a form of sprites, which required extensive changes to support, along with animating color changes. This version was known as <b>ZGrass</b>.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 222,
        "name": "GameMonkey Script",
        "url": "https://en.wikipedia.org/wiki/GameMonkey_Script",
        "summary": "<p><b>GameMonkey Script</b> is a small, cross-platform scripting language designed for embedding into games. GameMonkey bears many similarities to Lua, except the syntax is more similar to that of C. </p>",
        "infobox": "N/A"
    },
    {
        "id": 223,
        "name": "Game Maker Language",
        "url": "https://en.wikipedia.org/wiki/GameMaker",
        "summary": "<p class=\"mw-empty-elt\"> \n</p>\n<p><b>GameMaker</b> (originally <b>Animo</b> and later <b>Game Maker</b> until 2011) is a series of cross-platform game engines created by Mark Overmars in 1999 and developed by YoYo Games since 2007. The latest iteration is GameMaker Studio 2, first released in 2017.\n</p><p>GameMaker accommodates the creation of cross-platform and multi-genre video games using a custom drag-and-drop visual programming language or a scripting language known as Game Maker Language, which can be used to develop more advanced games that could not be created just by using the drag and drop features. GameMaker was originally designed to allow novice computer programmers to be able to make computer games without much programming knowledge by use of these actions. Recent versions of software also focus on appealing to advanced developers.</p>",
        "infobox": {
            "title": "GameMaker",
            "logo": "GameMaker Studio 2.svg",
            "author": "Mark Overmars",
            "developer": "YoYo Games",
            "released": "release date and age|df|=|yes|1999|11|15",
            "latest release version": "v2.2.5",
            "latest release date": "Nowrap|release date and age|df|=|yes|2019|12|18 release date and age|df|=|yes|2019|12|18",
            "programming language": "hlist|C++ (Runtime system|runtime)|C Sharp (programming language)|C# (Integrated development environment|IDE)",
            "operating system": "hlist|Microsoft Windows|macOS",
            "platform": "hlist|Microsoft Windows|macOS|Ubuntu (operating system)|Ubuntu|HTML5|Android (operating system)|Android|iOS|Amazon Fire TV|Android TV|Universal Windows Platform|PlayStation 4|Xbox One",
            "language": "hlist|English language|English|French language|French|Spanish language|Spanish|German language|German",
            "license": "Proprietary software|Proprietary",
            "website": "https://www.yoyogames.com/gamemaker|yoyogames.com/gamemaker",
            "games list": "List of GameMaker games"
        }
    },
    {
        "id": 224,
        "name": "Game Oriented Assembly Lisp",
        "url": "https://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp",
        "summary": "<p><b>Game Oriented Assembly Lisp</b> (<b>GOAL</b>) is a programming language, a dialect of the language Lisp, made for video games developed by Andy Gavin and the <i>Jak and Daxter</i> team at the company Naughty Dog. </p><p>It was written using Allegro Common Lisp and used in the development of the entire <i>Jak and Daxter</i> series of games.\n</p>",
        "infobox": {
            "paradigms": "Multi-paradigm programming language|Multi-paradigm",
            "family": "Lisp (programming language)|Lisp",
            "designer": "Andy Gavin",
            "developer": "Naughty Dog",
            "released": "2001|12|03",
            "latest release version": "3",
            "latest release date": "2012|02|07",
            "typing": [
                "Dynamic typing|Dynamic",
                "Latent typing|latent",
                "Strong typing|strong"
            ],
            "scope": "Scope (computer science)#Lexical scoping and dynamic scoping|Lexical",
            "programming language": "Allegro Common Lisp",
            "platform": [
                "PlayStation 2",
                "PlayStation Portable",
                "PlayStation 3"
            ],
            "license": "Proprietary software|Proprietary",
            "influenced by": [
                "Lisp (programming language)|Lisp",
                "Scheme (programming language)|Scheme,<br />Game Oriented Object Lisp (GOOL)"
            ]
        }
    },
    {
        "id": 225,
        "name": "General Algebraic Modeling System",
        "url": "https://en.wikipedia.org/wiki/General_Algebraic_Modeling_System",
        "summary": "<p>The <b>General Algebraic Modeling System</b> (<b>GAMS</b>) is a high-level modeling system for mathematical optimization. GAMS is designed for modeling and solving linear, nonlinear, and mixed-integer optimization problems. The system is tailored for complex, large-scale modeling applications and allows the user to build large maintainable models that can be adapted to new situations. The system is available for use on various computer platforms. Models are portable from one platform to another. </p><p>GAMS was the first algebraic modeling language (AML) and is formally similar to commonly used fourth-generation programming languages. GAMS contains an integrated development environment (IDE) and is connected to a group of third-party optimization solvers. Among these solvers are BARON, COIN-OR solvers, CONOPT, CPLEX, DICOPT, Gurobi, MOSEK, SNOPT, SULUM, and  XPRESS.\n</p><p>GAMS allows the users to implement a sort of hybrid algorithm combining different solvers. Models are described in concise, human-readable algebraic statements. GAMS is among the most popular input formats for the NEOS Server. Although initially designed for applications related to economics and management science, it has a community of users from various backgrounds of engineering and science.\n</p>",
        "infobox": {
            "name": "GAMS",
            "developer": "GAMS Development Corporation",
            "latest_release_version": "31.1.1",
            "latest release date": "start date and age|df|=|yes|paren|=|yes|2020|05|16",
            "platform": "Cross-platform",
            "status": "Active",
            "license": "Proprietary software|Proprietary",
            "genre": "Algebraic modeling language|Algebraic Modeling Language (AML)",
            "website": "url|https://www.gams.com"
        }
    },
    {
        "id": 226,
        "name": "Generational list of programming languages",
        "url": "https://en.wikipedia.org/wiki/Generational_list_of_programming_languages",
        "summary": "<p>This is a \"genealogy\" of programming languages. Languages are categorized under the ancestor language with the strongest influence. Those ancestor languages are listed in alphabetical order. Any such categorization has a large arbitrary element, since programming languages often incorporate major ideas from multiple sources. </p>",
        "infobox": "N/A"
    },
    {
        "id": 227,
        "name": "Genie (programming language)",
        "url": "https://en.wikipedia.org/wiki/Genie_(programming_language)",
        "summary": "<p><b>Genie</b> is a modern, general-purpose high-level programming language in development since 2008. It was designed as an alternative, simpler and cleaner dialect for the Vala compiler, while preserving the same functionality of the Vala language. Genie uses the same compiler and libraries as Vala; the two can indeed be used alongside each other. The differences are only syntactic. </p><p>Genie's syntax is derived from numerous modern languages like Python, Boo, D and Delphi. In the vein of Pascal and Python, Genie uses indentation rather than curly brackets to delimit blocks.\n</p><p>Like Vala, Genie uses the GObject type system to create classes and interfaces declared in Genie source code, without imposing additional runtime requirements (i.e., unlike Python, Java or C#, it does not require a virtual machine).\n</p><p>Genie allows access to C libraries, especially those based in GObject (like GTK), without using a different application binary interface (ABI). During compilation, the code is first translated to C source and header files, which are then compiled to platform-specific machine code using any available C compiler like GCC, thus allowing cross-platform software development.\n</p><p>Programs developed in Vala and Genie don't depend on the GNOME Desktop Environment, usually requiring only GLib.\n</p>",
        "infobox": {
            "name": "Genie",
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Imperative programming|imperative",
                "Structured programming|structured",
                "Object-oriented programming|object-oriented"
            ],
            "year": "2008",
            "designer": "Jamie McCracken",
            "latest_release_version": "0.38.8",
            "latest_release_date": "release date and age|2018|02|15",
            "typing": [
                "static typing|static",
                "strong typing|strong"
            ],
            "influenced_by": [
                "Python (programming language)|Python",
                "Boo (programming language)|Boo",
                "D (programming language)|D",
                "Object Pascal"
            ],
            "operating_system": "Cross-platform (every platform supported by GLib)",
            "license": "GNU Lesser General Public License|LGPLv2.1+",
            "website": "Official URL",
            "file_ext": ".gs"
        }
    },
    {
        "id": 228,
        "name": "Geometric Description Language",
        "url": "https://en.wikipedia.org/wiki/Geometric_Description_Language",
        "summary": "<p>In computer-aided design, <b>Geometric Description Language</b> (<b>GDL</b>) is the programming language of ArchiCAD library parts. <b>GSM</b> is the file format of these CAD objects. </p>",
        "infobox": "N/A"
    },
    {
        "id": 229,
        "name": "Go! (programming language)",
        "url": "https://en.wikipedia.org/wiki/Go!_(programming_language)",
        "summary": "<p><b>Go!</b> is an agent-based programming language in the tradition of logic-based programming languages like Prolog.  It was introduced in a 2003 paper by Francis McCabe and Keith Clark.</p>",
        "infobox": {
            "name": "Go!",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm: concurrent programming language|concurrent",
                "logic programming|logic",
                "functional programming|functional",
                "imperative programming|imperative (object-based language|object-based)"
            ],
            "year": "2003",
            "designer": [
                "Francis McCabe",
                "Keith Clark (computer scientist)|Keith Clark"
            ],
            "latest_test_version": "9-30-07",
            "latest_test_date": "mf|=|yes|2007|9|30",
            "typing": "strong typing|strong",
            "influenced_by": "Prolog",
            "license": "GPLv2",
            "operating_system": "Unix-like"
        }
    },
    {
        "id": 230,
        "name": "Go (programming language)",
        "url": "https://en.wikipedia.org/wiki/Go_(programming_language)",
        "summary": "<p><b>Go</b> is a statically typed, compiled programming language designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson. Go is syntactically similar to C, but with memory safety, garbage collection, structural typing, and CSP-style concurrency. The language is often referred to as \"Golang\" because of its domain name, <code>golang.org</code>, but the proper name is Go.</p><p>There are two major implementations: </p>\n<ul><li>Google's self-hosting compiler toolchain targeting multiple operating systems, mobile devices, and WebAssembly.</li>\n<li>gccgo, a GCC frontend.</li></ul><p>A third-party transpiler GopherJS compiles Go to JavaScript for front-end web development.\n</p>",
        "infobox": {
            "name": "Go",
            "logo": "Go Logo Blue.svg",
            "logo caption": "''The Go Programming Language''",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: concurrent programming|concurrent",
                "functional programming|functional",
                "imperative programming|imperative",
                "object-oriented programming|object-oriented"
            ],
            "year": "start date and age|2009|11|10",
            "designer": "Robert Griesemer<br />Rob Pike<br />Ken Thompson",
            "developer": "The Go Authors",
            "latest_release_version": "1.14.4",
            "latest_release_date": "release date and age|2020|06|01",
            "typing": [
                "type inference|Inferred",
                "static typing|static",
                "strong typing|strong",
                "structural typing|structural"
            ],
            "implementations": [
                "gc",
                "gccgo"
            ],
            "programming language": [
                "Go",
                "Assembly language (gc); C++ (gccgo)"
            ],
            "influenced_by": [
                "Alef (programming language)|Alef",
                "APL (programming language)|APL",
                "BCPL",
                "C (programming language)|C",
                "Communicating sequential processes|CSP",
                "Limbo (programming language)|Limbo",
                "Modula",
                "Newsqueak",
                "Oberon (programming language)|Oberon",
                "Occam (programming language)|occam",
                "Pascal (programming language)|Pascal",
                "Python (programming language)|Python",
                "Smalltalk"
            ],
            "influenced": "Crystal (programming language)|Crystal",
            "operating_system": [
                "DragonFly BSD",
                "FreeBSD",
                "Linux",
                "macOS",
                "NetBSD",
                "OpenBSD",
                "Plan 9 from Bell Labs|Plan 9",
                "Solaris (operating system)|Solaris",
                "Windows"
            ],
            "license": "BSD licenses|BSD-style + software patents|patent grant",
            "website": "Official URL",
            "file_ext": ".go"
        }
    },
    {
        "id": 231,
        "name": "Golo (programming language)",
        "url": "https://en.wikipedia.org/wiki/Golo_(programming_language)",
        "summary": "<p><b>Golo</b> is computer software, a programming language for the Java virtual machine (JVM). It is simple, with dynamic, weak typing. It was created in 2012 as part of the research activities of the DynaMid group of the Centre of Innovation in Telecommunications and Integration of service (CITI) Laboratory at Institut national des sciences appliquées de Lyon (INSA). It is distributed as free and open-source software under the Eclipse Public License 2.0. </p>",
        "infobox": {
            "name": "Golo",
            "released": "2012",
            "developer": "Institut national des sciences appliquées de Lyon|INSA Lyon",
            "latest release version": "3.3.0",
            "latest release date": "2018|11|30",
            "typing": [
                "Type system#Dynamic type checking and runtime type information|Dynamic",
                "Strong and weak typing|weak"
            ],
            "platform": "Java virtual machine",
            "operating system": "Cross-platform",
            "license": "Eclipse Public License|Eclipse Public 2.0",
            "website": "golo-lang.org"
        }
    },
    {
        "id": 232,
        "name": "Google Apps Script",
        "url": "https://en.wikipedia.org/wiki/Google_Apps_Script",
        "summary": "<p><b>Apps Script</b> is a scripting platform developed by Google for light-weight application development in the G Suite platform. Google Apps Script was initially developed by Mike Harm as a side project whilst working as a developer on Google Sheets. Google Apps Script was first publicly announced in May 2009 when a beta testing program was announced by Jonathan Rochelle, then Product Manager, Google Docs. In August 2009 Google Apps Script was subsequently made available to all Google Apps Premier and Education Edition customers. It is based on JavaScript 1.6, but also includes some portions of 1.7 and 1.8 and a subset of the ECMAScript 5 API. Apps Script projects run server-side on Google's infrastructure. According to Google, Apps Script \"provides easy ways to automate tasks across Google products and third party services.\" Apps Script is also the tool that powers the add-ons for Google Docs, Sheets and Slides.</p>",
        "infobox": {
            "name": "Apps Script",
            "logo": "Google Apps Script.png",
            "developer": "Google",
            "released": "2009|8|19",
            "programming language": "JavaScript",
            "genre": [
                "Web application framework",
                "scripting framework"
            ],
            "website": "https://script.google.com"
        }
    },
    {
        "id": 233,
        "name": "Gosu (programming language)",
        "url": "https://en.wikipedia.org/wiki/Gosu_(programming_language)",
        "summary": "<p><b>Gosu</b> is a statically-typed general-purpose programming language that runs on the Java Virtual Machine. Its influences include Java, C#, and ECMAScript.  Development of Gosu began in 2002 internally for Guidewire Software, and the language saw its first community release in 2010 under the Apache 2 license.</p><p>Gosu can serve as a scripting language, having free-form Program types (.gsp files) for scripting as well as statically verified Template files (.gst files).  Gosu can optionally execute these and all other types directly from source without precompilation, which also distinguishes it from other static languages. </p>",
        "infobox": {
            "name": "Gosu",
            "file ext": [
                ".gs",
                ".gsp",
                ".gst",
                ".gsx"
            ],
            "developer": "Guidewire and open source contributors",
            "latest release version": "1.14.6",
            "latest release date": "start date and age|2017|04|05",
            "typing": "Type system#Static type-checking|static",
            "influenced by": [
                "Java (programming language)|Java",
                "C Sharp (programming language)|C#"
            ],
            "influenced": "Kotlin (programming language)|Kotlin",
            "platform": [
                "Execute on the Java Virtual Machine",
                "statically and dynamically compiles to Java bytecode|bytecode"
            ],
            "operating system": "any supporting JVM",
            "license": "Apache License 2.0",
            "website": "http://gosu-lang.org/"
        }
    },
    {
        "id": 234,
        "name": "Grasshopper 3D",
        "url": "https://en.wikipedia.org/wiki/Grasshopper_3D",
        "summary": "<p><b>Grasshopper</b> is a visual programming language and environment that runs within the Rhinoceros 3D computer-aided design (CAD) application. The program was created by David Rutten at Robert McNeel &amp; Associates. Programs are created by dragging components onto a canvas.  The outputs to these components are then connected to the inputs of subsequent components. </p>",
        "infobox": {
            "name": "Grasshopper",
            "screenshot": "Grasshopper MainWindow.png",
            "caption": "A sample program in the Grasshopper Graphical user interface|GUI",
            "developer": "Robert McNeel and associates",
            "designer": "David Rutten",
            "released": "2007|09",
            "latest_release_version": "1.0",
            "latest_release_date": "2014|04|04",
            "operating_system": [
                "Windows 2000 and later",
                "MacOS"
            ],
            "genre": "Visual programming language|Visual Programming",
            "license": "Proprietary software|Proprietary",
            "website": "grasshopper3d.com",
            "paradigm": "Visual programming language|visual programming",
            "file_ext": ".ghx"
        }
    },
    {
        "id": 235,
        "name": "Groovy (programming language)",
        "url": "https://en.wikipedia.org/wiki/Apache_Groovy",
        "summary": "<p><b>Apache Groovy</b> is a Java-syntax-compatible object-oriented programming language for the Java platform. It is both a static and dynamic language with features similar to those of Python, Ruby, and Smalltalk. It can be used as both a programming language and a scripting language for the Java Platform, is compiled to Java virtual machine (JVM) bytecode, and interoperates seamlessly with other Java code and libraries. Groovy uses a curly-bracket syntax similar to Java's. Groovy supports closures, multiline strings, and expressions embedded in strings. Much of Groovy's power lies in its AST transformations, triggered through annotations. </p><p>Groovy 1.0 was released on January 2, 2007, and Groovy 2.0 in July, 2012. Since version 2, Groovy can be compiled statically, offering type inference and performance near that of Java. Groovy 2.4 was the last major release under Pivotal Software's sponsorship which ended in March 2015. Groovy has since changed its governance structure to a Project Management Committee in the Apache Software Foundation.</p>",
        "infobox": {
            "name": "Groovy",
            "logo": "Groovy-logo.svg",
            "logo caption": "Groovy Logo",
            "paradigm": [
                "Object-oriented programming|Object-oriented",
                "Imperative programming|imperative",
                "Scripting language|scripting"
            ],
            "year": "2003",
            "designer": "James Strachan (programmer)|James Strachan",
            "developer": "Guillaume Laforge (PMC Chair)<br />Jochen Theodorou (Tech Lead)<br />Paul King<br />Cedric Champeau",
            "typing": [
                "Type system#DYNAMIC|Dynamic",
                "Type system#STATIC|static",
                "Strong and weak typing|strong",
                "Duck typing|duck"
            ],
            "website": "official URL",
            "implementations": [
                "Gradle",
                "Grails (framework)|Grails"
            ],
            "influenced by": [
                "Java (programming language)|Java",
                "Python (programming language)|Python",
                "Ruby (programming language)|Ruby",
                "Smalltalk"
            ],
            "influenced": "Kotlin (programming language)|Kotlin",
            "platform": [
                "Java Platform",
                "Standard Edition|Java SE"
            ],
            "license": "Apache License 2.0",
            "file ext": [
                "<code>.groovy",
                ".gvy",
                ".gy",
                ".gsh</code>"
            ]
        }
    },
    {
        "id": 236,
        "name": "Gödel (programming language)",
        "url": "https://en.wikipedia.org/wiki/G%C3%B6del_(programming_language)",
        "summary": "<p><b>Gödel</b> is a declarative, general-purpose programming language that adheres to the logic programming paradigm. It is a strongly typed language, the type system being based on many-sorted logic with parametric polymorphism. It is named after logician Kurt Gödel. </p>",
        "infobox": {
            "name": "Gödel",
            "paradigm": [
                "Declarative programming|declarative",
                "Logic programming|logic"
            ],
            "year": "1992",
            "designer": "John Lloyd & Patricia Hill",
            "developer": "John Lloyd & Patricia Hill",
            "latest_release_version": "1.5",
            "typing": "strong typing|strong",
            "dialects": "[https://web.archive.org/web/20091207092823/http://www.scs.leeds.ac.uk/hill/GOEDEL/expgoedel.html Gödel with Generic (Parametrised) Modules]",
            "operating_system": "Unix-like",
            "license": "Non-commercial research/educational use only"
        }
    },
    {
        "id": 237,
        "name": "HAGGIS",
        "url": "https://en.wikipedia.org/wiki/Haggis_(programming_language)",
        "summary": "<p><b>Haggis</b> is a high-level reference programming language used primarily to examine computing science for Scottish pupils taking SQA courses on the subject. Haggis is used as a tool to bridge the gap between pseudocode and typical computer programming.</p><p>Haggis is not based on any one language but a mixture that is intended to allow a pupil familiar with any of the many languages used in classrooms to easily understand the syntactic construct being used in an example. It has multiple programming paradigms of functional, imperative and object-oriented to suit this purpose.</p><p>There are three separate language definitions, one for each level at which computing is assessed by the SQA; these are proper subsets of each other, so for example any program contained by the National 5 level language is also well-defined at Higher and Advanced Higher levels. Higher includes the definition of procedures and functions and the use of record types and files, while Advanced Higher includes object-orientation. </p><p>Online Haggis interpreters have been developed to provide a way for examiners and teachers to check their programs are correctly defined and behave as expected.</p>",
        "infobox": "N/A"
    },
    {
        "id": 238,
        "name": "HAL/S",
        "url": "https://en.wikipedia.org/wiki/HAL/S",
        "summary": "<p><b>HAL/S</b> (<i><b>H</b>igh-order <b>A</b>ssembly <b>L</b>anguage<b>/S</b>huttle</i>)  is a real-time aerospace programming language compiler and cross-compiler for avionics applications used by NASA and associated agencies (JPL, etc.). It has been used in many U.S. space projects since 1973 and its most significant use was in the Space Shuttle program (approximately 85% of the Shuttle software is coded in HAL/S).  It was designed by Intermetrics in 1972 for NASA and delivered in 1973. HAL/S is written in XPL, a dialect of PL/I. Although HAL/S is designed primarily for programming on-board computers, it is general enough to meet nearly all the needs in the production, verification, and support of aerospace and other real-time applications. According to documentation from 2005, it is been maintained by the HAL/S project of United Space Alliance.</p>",
        "infobox": "N/A"
    },
    {
        "id": 239,
        "name": "Hack (programming language)",
        "url": "https://en.wikipedia.org/wiki/Hack_(programming_language)",
        "summary": "<p><b>Hack</b> is a programming language for the HipHop Virtual Machine (HHVM), created by Facebook as a dialect of PHP. The language implementation is open-source, licensed under the MIT License.</p><p>Hack allows programmers to use both dynamic typing and static typing.  This kind of a type system is called gradual typing, which is also implemented in other programming languages such as ActionScript.  Hack's type system allows types to be specified for function arguments, function return values, and class properties; however, types of local variables are always inferred and cannot be specified.</p>",
        "infobox": {
            "name": "Hack",
            "logo": "File:Hack (programming language) logo.svg|75px",
            "released": "2014",
            "designer": [
                "Julien Verlaguet",
                "Alok Menghrajani",
                "Drew Paroski",
                "and others"
            ],
            "developer": "Facebook",
            "typing": [
                "Static typing|Static",
                "Dynamic typing|dynamic",
                "Weak typing|weak",
                "Gradual_typing|gradual"
            ],
            "license": "MIT License",
            "website": "https://hacklang.org/",
            "logo_size": "200px",
            "logo_alt": [
                "Hack logo",
                "featuring white lowercase \"hack\" letters on a black background",
                "with stylized triangular geometric shapes on the left"
            ],
            "influenced_by": [
                "PHP",
                "OCaml",
                "Java (programming language)|Java",
                "C Sharp (programming language)|C#",
                "Scala (programming language)|Scala",
                "Haskell (programming language)|Haskell"
            ],
            "operating_system": "Cross-platform"
        }
    },
    {
        "id": 240,
        "name": "Halide (programming language)",
        "url": "https://en.wikipedia.org/wiki/Halide_(programming_language)",
        "summary": "<p><b>Halide</b> is a computer programming language designed for writing digital image processing code that takes advantage of memory locality, vectorized computation and multi-core CPUs and GPUs. Halide is implemented as an internal domain-specific language (DSL) in C++. </p>",
        "infobox": {
            "name": "Halide",
            "paradigm": [
                "Functional programming|functional",
                "Parallel programming model|parallel"
            ],
            "year": "2012",
            "designer": "Jonathan Ragan-Kelley and Andrew Adams",
            "developer": [
                "Massachusetts Institute of Technology|MIT",
                "(with help from Stanford University|Stanford and Adobe Systems|Adobe)"
            ],
            "typing": "Static typing|static",
            "programming_language": "C++",
            "operating_system": [
                "Mac OS X (10.6 through 10.8)",
                "mainstream Linux distributions",
                "Windows"
            ],
            "website": "http://halide-lang.org/"
        }
    },
    {
        "id": 241,
        "name": "Hamilton C shell",
        "url": "https://en.wikipedia.org/wiki/Hamilton_C_shell",
        "summary": "<p><b>Hamilton C shell</b> is a clone of the Unix C shell and utilities for Microsoft Windows created by Nicole Hamilton at Hamilton Laboratories as a completely original work, not based on any prior code.  It was first released on OS/2 on December 12, 1988 and on Windows NT in July 1992.  The OS/2 version was discontinued in 2003 but the Windows version continues to be actively supported. </p>",
        "infobox": {
            "name": "Hamilton C shell",
            "screenshot": "Hamilton C shell x64 on Windows 7.png",
            "screenshot size": "300px",
            "caption": "64-bit Hamilton C shell on a Windows 7 desktop.",
            "author": "Nicole Hamilton",
            "released": "1988|12|12",
            "latest release version": "5.2.g",
            "latest release date": "2017|03|05",
            "programming language": "C (programming language)|C",
            "operating system": "Microsoft Windows|Windows",
            "genre": "Unix Shell on Windows",
            "license": "Commercial software|Commercial proprietary software",
            "website": "https://hamiltonlabs.com/Cshell.htm"
        }
    },
    {
        "id": 242,
        "name": "Harbour (software)",
        "url": "https://en.wikipedia.org/wiki/Harbour_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Harbour</b> is a computer programming language, primarily used to create database/business programs. It is a modernized, open sourced and cross-platform version of the older Clipper system, which in turn developed from the dBase database market of the 1980s and 1990s.\n</p><p>Harbour code using the same databases can be compiled under a wide variety of platforms, including Microsoft Windows, Linux, Unix variants, several BSD descendants, Mac OS X, MINIX 3, Windows CE, Pocket PC, Symbian, iOS, Android, QNX, VxWorks, OS/2/eComStation, BeOS/Haiku, \nAIX and MS-DOS.\n</p>",
        "infobox": {
            "name": "Harbour Project",
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Imperative programming|imperative",
                "Functional programming|functional",
                "Object-oriented programming|object-oriented",
                "Reflective programming|reflective"
            ],
            "year": "1999",
            "designer": "Antonio Linares",
            "developer": "Viktor Szakáts and community",
            "latest_release_version": "3.0.0",
            "latest_release_date": "df|=|yes|2011|07|17",
            "latest_preview_version": "[https://sourceforge.net/projects/harbour-project/files/binaries-windows/nightly/ 3.2.0dev]",
            "typing": [
                "Optionally duck typing|duck",
                "dynamic typing|dynamic",
                "type safety|safe",
                "partially strong typing|strong"
            ],
            "dialects": [
                "Clipper",
                "Xbase++",
                "FlagShip",
                "FoxPro",
                "xHarbour"
            ],
            "influenced_by": [
                "dBase",
                "Clipper"
            ],
            "influenced": "xHarbour",
            "operating_system": "Cross-platform",
            "license": "Open-source license|Open-source GPL-compatible",
            "website": "https://harbour.github.io/",
            "file_ext": [
                ".prg",
                ".ch",
                ".hb",
                ".hbp"
            ]
        }
    },
    {
        "id": 243,
        "name": "Hartmann pipeline",
        "url": "https://en.wikipedia.org/wiki/CMS_Pipelines",
        "summary": "<p><b>CMS Pipelines</b> implements the pipeline concept under the VM/CMS operating system. The programs in a pipeline operate on a sequential stream of records. A program writes records that are read by the next program in the pipeline. Any program can be combined with any other because reading and writing is done through a device independent interface. </p>",
        "infobox": {
            "name": "Pipelines",
            "logo": "image:pipjarg1.jpeg",
            "paradigm": "dataflow|Dataflow programming",
            "year": "1986",
            "developer": "IBM",
            "designer": "John P. Hartmann (IBM)",
            "latest_release_version": "1.1.12/0012",
            "latest_release_date": "2020-06-03",
            "platform": "IBM z Systems",
            "operating_system": "z/VM 7.1",
            "influenced_by": "Pipeline (Unix)",
            "website": "http://vm.marist.edu/~pipeline"
        }
    },
    {
        "id": 244,
        "name": "Haskell (programming language)",
        "url": "https://en.wikipedia.org/wiki/Haskell_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Haskell</b> <span></span> is a general-purpose, statically typed, purely functional programming language with type inference and lazy evaluation. Developed to be suitable for teaching, research and industrial application, Haskell has pioneered a number of advanced programming language features such as type classes, which enable type-safe operator overloading.  Haskell's main implementation is the Glasgow Haskell Compiler (GHC). It is named after logician Haskell Curry.</p><p>Haskell's semantics are historically based on those of the Miranda programming language, which served to focus the efforts of the initial Haskell working group. The last formal specification of the language was made in July 2010, while the development of GHC's implementation has continued to extend Haskell via language extensions. The next formal specification is planned for 2020.</p><p>Haskell is used in academia and industry. As of September 2019, Haskell was the 23rd most popular programming language in terms of Google searches for tutorials and made up less than 1% of active users on the GitHub source code repository.</p>",
        "infobox": {
            "name": "Haskell",
            "logo": "Haskell-Logo.svg",
            "logo caption": [
                "The Haskell logo",
                "generated by Haskell code."
            ],
            "paradigm": "Purely functional programming|Purely functional",
            "released": "start date and age|df|=|yes|1990 sfn|Hudak|Hughes|Peyton Jones|Wadler|2007",
            "designer": [
                "Lennart Augustsson",
                "Dave Barton",
                "Brian Boutel",
                "Warren Burton",
                "Joseph Fasel",
                "Kevin Hammond",
                "Ralf Hinze",
                "Paul Hudak",
                "John Hughes (computer scientist)|John Hughes",
                "Thomas Johnsson",
                "Mark Jones",
                "Simon Peyton Jones",
                "John Launchbury",
                "Erik Meijer (computer scientist)|Erik Meijer",
                "John Peterson",
                "Alastair Reid",
                "Colin Runciman",
                "Philip Wadler"
            ],
            "latest release version": "Haskell 2010",
            "latest release date": "start date and age|df|=|yes|2010|07",
            "latest test version": "Haskell 2020 announced",
            "typing": [
                "Type inference|Inferred",
                "static typing|static",
                "strong typing|strong"
            ],
            "implementations": [
                "Glasgow Haskell Compiler|GHC",
                "Hugs",
                "NHC",
                "JHC",
                "Yhc",
                "UHC"
            ],
            "dialects": [
                "Helium (Haskell)|Helium",
                "Gofer (software)|Gofer"
            ],
            "influenced by": [
                "Clean (programming language)|Clean",
                "FP (programming language)|FP",
                "Gofer (programming language)|Gofer",
                "Hope (programming language)|Hope and Hope<sup>+</sup>",
                "Id (programming language)|Id",
                "ISWIM",
                "Kent Recursive Calculator|KRC",
                "Lisp (programming language)|Lisp",
                "Miranda (programming language)|Miranda",
                "ML (programming language)|ML and Standard ML",
                "Orwell (programming language)|Orwell",
                "SASL (programming language)|SASL",
                "Scheme (programming language)|Scheme",
                "SISAL"
            ],
            "influenced": [
                "Agda (programming language)|Agda",
                "Bluespec",
                "Inc.|Bluespec",
                "sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp|=|12–38",
                "43 C++11/Concepts (C++)|Concepts",
                "C Sharp (programming language)|C#/Language Integrated Query|LINQ",
                "sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp|=|12-45–46 CAL",
                "Citation needed|date|=|February 2012 Cayenne (programming language)|Cayenne",
                "sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp|=|12-45–46 Clean (programming language)|Clean",
                "sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp|=|12-45–46 Clojure",
                "CoffeeScript",
                "Curry (programming language)|Curry",
                "sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp|=|12-45–46 Elm (programming language)|Elm",
                "Epigram (programming language)|Epigram",
                "Citation needed|date|=|February 2012 Escher (programming language)|Escher",
                "F Sharp (programming language)|F#",
                "Frege (programming language)|Frege",
                "Hack (programming language)|Hack",
                "Idris (programming language)|Idris",
                "Isabelle theorem prover|Isabelle",
                "sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp|=|12-45–46 Java (programming language)|Java/Generics in Java|Generics",
                "sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp|=|12-45–46 LiveScript",
                "Mercury (programming language)|Mercury",
                "sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp|=|12-45–46 Ωmega",
                "Citation needed|date|=|February 2012 PureScript",
                "Python (programming language)|Python",
                "sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp|=|12-45–46 Raku (programming language)|Raku",
                "Rust (programming language)|Rust",
                "Scala (programming language)|Scala",
                "sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp|=|12-45–46 Swift (programming language)|Swift",
                "Timber (programming language)|Timber",
                "Visual Basic .NET|Visual Basic 9.0 sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp|=|12-45–46"
            ],
            "operating system": "Cross-platform",
            "website": "url|https://www.haskell.org",
            "file ext": [
                ".hs",
                ".lhs"
            ]
        }
    },
    {
        "id": 245,
        "name": "Haxe",
        "url": "https://en.wikipedia.org/wiki/Haxe",
        "summary": "<p><b>Haxe</b> is an open source high-level cross-platform multi-paradigm programming language and compiler that can produce applications and source code, for many different computing platforms, from one code-base. It is free and open-source software, distributed under the GNU General Public License (GPL) version 2, and the standard library under the MIT License. </p><p>Haxe includes a set of common functions that are supported across all platforms, such as numeric data types, text, arrays, binary and some common file formats. Haxe also includes platform-specific application programming interface (API) for Adobe Flash, C++, PHP and other languages. OpenFL and Flambe are popular Haxe frameworks that enable creating multi-platform content from one codebase.</p><p>Haxe originated with the idea of supporting client-side and server-side programming in one language, and simplifying the communication logic between them. Code written in the Haxe language can be source-to-source compiled into ActionScript 3, JavaScript, Java, C++, C#, PHP, Python, Lua and Node.js. Haxe can also directly compile SWF, HashLink and Neko bytecode.\n</p><p>Many popular  IDEs and  source code editors have support available for Haxe development.  No particular development environment or tool set is officially recommended by the Haxe Foundation, although VS Code and IntelliJ IDEA have extensions to support Haxe development. The core functionalities of syntax highlighting, code completion, refactoring, debugging, etc., are available in various degree.\n</p><p>To help leverage existing code, the Haxe community has created source code converters for ActionScript 3 to Haxe and C# to Haxe. The Haxe compiler can also output Haxe into standalone ActionScript 3, C++, C#, Java, PHP, Python and Lua source code, which can then be pulled out of the Haxe ecosystem and developed with traditional workflows.\n</p><p>Major users of Haxe include BBC, Coca-Cola, Disney, Hasbro, Mattel, Nickelodeon, Prezi, TiVo, Toyota, and Zynga.</p>",
        "infobox": {
            "name": "Haxe",
            "logo": "Haxe logo.svg",
            "paradigm": "Programming paradigm#Multi-paradigm|Multi-paradigm",
            "released": "2005",
            "license": [
                "GNU General Public License|GPL 2.0",
                "library: MIT License|MIT"
            ],
            "developer": "Haxe Foundation",
            "latest release version": "4.1.2",
            "latest release date": "2020|06|19",
            "latest preview version": "4.0.0-rc.5",
            "latest preview date": "2019|09|12",
            "typing": [
                "Type system|Static",
                "Dynamic typing|dynamic via annotations",
                "Nominal type system|nominal"
            ],
            "operating system": [
                "Android (operating system)|Android",
                "iOS; Linux",
                "macOS",
                "Microsoft Windows|Windows"
            ],
            "platform": [
                "ARM architecture|ARM; IA-32",
                "x86-64"
            ],
            "file ext": [
                ".hx",
                ".hxml"
            ],
            "website": "haxe.org",
            "influenced by": [
                "ActionScript",
                "OCaml",
                "Java (programming language)|Java"
            ],
            "programming language": "OCaml"
        }
    },
    {
        "id": 246,
        "name": "Hermes (programming language)",
        "url": "https://en.wikipedia.org/wiki/Hermes_(programming_language)",
        "summary": "<p><b>Hermes</b> is a language for distributed programming\nthat was developed at IBM's Thomas J. Watson Research Center from 1986 through 1992,\nwith an open-source compiler and run-time system.\nHermes' primary features included:</p>\n<ul><li>Language support of processes and interprocess communication.</li>\n<li>Compile-time verification that operations use initialized data.</li>\n<li>Representation-independent data aggregates called tables.</li>\n<li>Lack of pointers.</li></ul><p>It used typestate analysis to check variables transitions errors, to rule out some semantically non meaningful transitions from one state to another (i.e. starting from a value, some sequences of operations on a variable are nonsensical), of which reading an uninitialized variable is a special case. In this role of compile-time checking of data initialization is similar to definite assignment analysis performed by Java, Cyclone and C#.\n</p><p>Hermes and its predecessor, NIL (Network Implementation Language), were the earliest programming languages supporting this form of initialization checking.\nTypestate was actually used more extensively, to generate compiler-inserted \"delete\" operations.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 247,
        "name": "High Level Assembly",
        "url": "https://en.wikipedia.org/wiki/High_Level_Assembly",
        "summary": "<p><b>High Level Assembly</b> (<b>HLA</b>) is a high-level assembly language developed by Randall Hyde. It allows the use of higher-level language constructs to aid both beginners and advanced assembly developers. It fully supports advanced data types and object-oriented programming. It uses a syntax loosely based on several high-level programming languages (HLLs), such as Pascal, Ada, Modula-2, and C++, to allow creating readable assembly language programs, and to allow HLL programmers to learn HLA as fast as possible. </p>",
        "infobox": {
            "name": "High Level Assembly (HLA)",
            "developer": "Randall Hyde",
            "latest release version": "2.16",
            "latest release date": "2011|07|06",
            "programming language": "Assembly language",
            "operating system": [
                "Windows",
                "Linux",
                "FreeBSD",
                "macOS"
            ],
            "platform": "IA-32",
            "language": "English",
            "genre": "Assembly language#Assembler|Assembler",
            "license": "Public domain",
            "website": "plantation-productions.com/Webster",
            "repo": "sourceforge.net/projects/hlav1"
        }
    },
    {
        "id": 248,
        "name": "High Level Shader Language",
        "url": "https://en.wikipedia.org/wiki/High-Level_Shading_Language",
        "summary": "<p>The <b>High-Level Shader Language</b> or <b>High-Level Shading Language</b> (<b>HLSL</b>) is a proprietary shading language developed by Microsoft for the Direct3D 9 API to augment the shader assembly language, and went on to become the required shading language for the unified shader model of Direct3D 10 and higher. </p><p>HLSL is analogous to the GLSL shading language used with the OpenGL standard. It is very similar to the Nvidia Cg shading language, as it was developed alongside it. Early versions of the two languages were considered identical, only marketed differently.  HLSL shaders can enable profound speed and detail increases as well as many special effects in both 2D and 3D computer graphics.</p><p>HLSL programs come in six forms: pixel shaders (fragment in GLSL), vertex shaders, geometry shaders, compute shaders, tessellation shaders (Hull and Domain shaders), and raytracing shaders (Ray Generation Shaders, Intersection Shaders, Any Hit/Closest Hit/Miss Shaders). A vertex shader is executed for each vertex that is submitted by the application, and is primarily responsible for transforming the vertex from object space to view space, generating texture coordinates, and calculating lighting coefficients such as the vertex's tangent, binormal and normal vectors. When a group of vertices (normally 3, to form a triangle) come through the vertex shader, their output position is interpolated to form pixels within its area; this process is known as rasterization. \n</p><p>Optionally, an application using a Direct3D 10/11/12 interface and Direct3D 10/11/12 hardware may also specify a geometry shader. This shader takes as its input some vertices of a primitive (triangle/line/point) and uses this data to generate/degenerate (or tessellate) additional primitives or to change the type of primitives, which are each then sent to the rasterizer.\n</p><p>D3D11.3 and D3D12 introduced Shader Model 5.1 and later 6.0.</p>",
        "infobox": "N/A"
    },
    {
        "id": 249,
        "name": "History of programming languages",
        "url": "https://en.wikipedia.org/wiki/History_of_programming_languages",
        "summary": "<p>The <b>history of programming languages</b> spans from documentation of early mechanical computers to modern tools for software development. Early programming languages were highly specialized, relying on mathematical notation and similarly obscure syntax. Throughout the 20th century, research in compiler theory led to the creation of high-level programming languages, which use a more accessible syntax to communicate instructions.  </p><p>The first high-level programming language was Plankalkül, created by Konrad Zuse between 1942 and 1945. The first high-level language to have an associated compiler was created by Corrado Böhm in 1951, for his PhD thesis. The first commercially available language was FORTRAN (FORmula TRANslation), developed in 1956 (first manual appeared in 1956, but first developed in 1954) by a team led by John Backus at IBM.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 250,
        "name": "Hollywood (programming language)",
        "url": "https://en.wikipedia.org/wiki/Hollywood_(programming_language)",
        "summary": "<p><b>Hollywood</b> is a commercially distributed programming language developed by Andreas Falkenhahn (Airsoft Softwair) which mainly focuses on the creation of multimedia-oriented applications. Hollywood is available for AmigaOS, MorphOS, WarpOS, AROS, Windows, macOS, Linux, Android, and iOS. Hollywood has an inbuilt cross compiler that can automatically save executables for all platforms supported by the software. The generated executables are completely stand-alone and do not have any external dependencies, so they can also be started from a USB flash drive. An optional add-on also allows users to compile projects into APK files.</p><p>The Hollywood Designer is an add-on for Hollywood with which it is possible to use Hollywood also as a presentation software and an authoring system. </p>",
        "infobox": {
            "name": "Hollywood",
            "screenshot": "Hollywood-ide3.jpg",
            "caption": "Hollywood IDE running on Windows XP",
            "developer": "Andreas Falkenhahn",
            "latest release version": "8.0",
            "latest release date": "2019|02|08",
            "operating system": [
                "AmigaOS",
                "MorphOS",
                "WarpOS",
                "AROS",
                "Microsoft Windows|Windows. macOS",
                "Linux",
                "Android (operating system)|Android",
                "iOS"
            ],
            "genre": "Programming language",
            "license": "Proprietary software|Proprietary",
            "website": "www.hollywood-mal.com"
        }
    },
    {
        "id": 251,
        "name": "Hop (software)",
        "url": "https://en.wikipedia.org/wiki/Hop_(software)",
        "summary": "<p><b>Hop</b> is a Lisp-like programming language by Manuel Serrano for web 2.0 and also the name of the web broker (server and proxy) that implements this language. It is written in Bigloo Scheme. It is a project funded by INRIA. </p>",
        "infobox": {
            "logo": "File:Hop logo.svg",
            "name": "Hop",
            "paradigm": "multi-paradigm programming language|multi-paradigm",
            "year": "2006",
            "designer": "Manuel Serrano",
            "latest_release_version": "2.4.2",
            "latest_release_date": "Release date and age|2013|09|23",
            "typing": [
                "strong",
                "dynamic"
            ],
            "influenced_by": "Scheme (programming language)|Scheme",
            "license": "GPL 3#Version 3|GPL version 3",
            "website": "Official URL"
        }
    },
    {
        "id": 252,
        "name": "Hope (programming language)",
        "url": "https://en.wikipedia.org/wiki/Hope_(programming_language)",
        "summary": "<p><b>Hope</b> is a small functional programming language developed in the 1970s at the University of Edinburgh. It predates Miranda and Haskell and is contemporaneous with ML, also developed at the University. Hope was derived from NPL, a simple functional language developed by Rod Burstall and John Darlington in their work on program transformation. NPL and Hope are notable for being the first languages with call-by-pattern evaluation and algebraic data types.</p><p>Hope was named for Sir Thomas Hope (c. 1681–1771), a Scottish agricultural reformer, after whom <i>Hope Park Square</i> in Edinburgh, the location of the Department of Artificial Intelligence at the time of the development of Hope, was also named.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 253,
        "name": "Hopscotch (programming language)",
        "url": "https://en.wikipedia.org/wiki/Hopscotch_(programming_language)",
        "summary": "<p><b>Hopscotch</b> is a visual programming language developed by Hopscotch Technologies, designed to allow young or beginner programmers to develop simple projects. Its simple UI allows its users to drag and drop blocks to create scripts that can be played when activated. Although the language is easy to use for simple programming, it lacks the power to be used for more complex programs. The use of the language is through an iPad or iPhone supporting Hopscotch.</p>",
        "infobox": "N/A"
    },
    {
        "id": 254,
        "name": "Hugo (programming language)",
        "url": "https://en.wikipedia.org/wiki/Interactive_fiction",
        "summary": "<p> <b>Interactive fiction</b>, often abbreviated <b>IF</b>, is software simulating environments in which players use text commands to control characters and influence the environment. Works in this form can be understood as literary narratives, either in the form of interactive narratives or interactive narrations. These works can also be understood as a form of video game, either in the form of an adventure game or role-playing game. In common usage, the term refers to <b>text adventures</b>, a type of adventure game where the entire interface can be \"text-only\", however, graphical text adventure games, where the text is accompanied by graphics (still images, animations or video) still fall under the text adventure category if the main way to interact with the game is by typing text. Some users of the term distinguish between interactive fiction, known as \"Puzzle-free\", that focuses on narrative, and \"text adventures\" that focus on puzzles.\n</p><p>Due to their text-only nature, they sidestepped the problem of writing for widely divergent graphics architectures. This feature meant that interactive fiction games were easily ported across all the popular platforms at the time, including CP/M (not known for gaming or strong graphics capabilities). The number of interactive fiction works is increasing steadily as new ones are produced by an online community, using freely available development systems.\n</p><p>The term can also be used to refer to digital versions of literary works that are not read in a linear fashion, known as gamebooks, where the reader is instead given choices at different points in the text; these decisions determine the flow and outcome of the story. The most famous example of this form of printed fiction is the <i>Choose Your Own Adventure</i> book series, and the collaborative \"addventure\" format has also been described as a form of interactive fiction. The term \"interactive fiction\" is sometimes used also to refer to visual novels, a type of interactive narrative software popular in Japan.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 255,
        "name": "Hume (language)",
        "url": "https://en.wikipedia.org/wiki/Hume_(programming_language)",
        "summary": "<p><b>Hume</b> is a functionally based programming language developed at the University of St Andrews and Heriot-Watt University in Scotland since the year 2000. The language name is both an acronym meaning 'Higher-order Unified Meta-Environment' and an honorific to the 18th Century philosopher David Hume. It targets real-time embedded systems, aiming to produce a design that is both highly abstract, yet which will still allow precise extraction of time and space execution costs. This allows programmers to guarantee the bounded time and space demands of executing programs. </p><p>Hume combines functional programming ideas with ideas from finite state automata. Automata are used to structure communicating programs into a series of \"boxes\", where each box maps inputs to outputs in a purely functional way using high-level pattern-matching. It is  structured as a series of levels, each of which exposes different machine properties.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 256,
        "name": "HyperTalk",
        "url": "https://en.wikipedia.org/wiki/HyperTalk",
        "summary": "<p><b>HyperTalk</b> was a high-level, procedural programming language created in 1987 by Dan Winkler and used in conjunction with Apple Computer's HyperCard hypermedia program by Bill Atkinson. Because the main target audience of HyperTalk was beginning programmers, HyperTalk programmers were usually called \"authors\" and the process of writing programs was known as \"scripting\". HyperTalk scripts resembled written English and used a logical structure similar to that of the Pascal programming language. </p><p>HyperTalk supported the basic control structures of procedural languages: repeat for/while/until, if/then/else, as well as function and message \"handler\" calls (a function handler was a subroutine and a message handler a procedure). Data types usually did not need to be specified by the programmer; conversion happened transparently in the background between strings and numbers. There were no classes or data structures in the traditional sense; in their place were special string literals, or \"lists\" of \"items\" delimited by commas (in later versions the \"itemDelimiter\" property allowed choosing an arbitrary character).\n</p><p>In the late 1980s Apple considered using HyperCard's HyperTalk scripting language as the standard language across the company and within its classic Mac OS operating system, as well as for interprocess communication between Apple and non-Apple products. The company did not oppose the development of imitations like SuperCard, but it created the HyperTalk Standards Committee to avoid incompatibility between language variants. The case-insensitive language was initially interpreted, but gained just-in-time compilation with HyperCard 2.0.</p>",
        "infobox": {
            "name": "HyperTalk",
            "paradigm": "Procedural programming|procedural",
            "released": "1987",
            "designer": "Dan Winkler (computer scientist)|Dan Winkler",
            "developer": "Apple Inc.|Apple Computer Inc.",
            "influenced_by": [
                "Natural language programming|Natural language",
                "Pascal (programming language)|Pascal"
            ],
            "influenced": [
                "ActionScript",
                "AppleScript",
                "ECMAScript",
                "JavaScript",
                "Lingo (programming language)|Lingo",
                "LiveCode",
                "SenseTalk",
                "SuperTalk"
            ]
        }
    },
    {
        "id": 257,
        "name": "IBM 1401 Symbolic Programming System",
        "url": "https://en.wikipedia.org/wiki/IBM_1401_Symbolic_Programming_System",
        "summary": "<p>The <b>IBM 1401 Symbolic Programming System</b> (<b>SPS</b>) was an assembler that was developed by Gary Mokotoff, IBM Applied Programming Department, for the IBM 1401 computer, the first of the IBM 1400 series.  One source indicates that \"This programming system was announced by IBM with the machine.\"</p><p>SPS-1 could run on a low-end machine with 1.4K memory, SPS-2 required at least 4K memory. </p>\n<dl><dd>SPS-1 punched one card for each input instruction in its first pass and this deck had to be read during pass 2. At the University of Chicago and many other locations, SPS-1 was replaced by assemblers taking advantage of the commonly available 4K memory configuration to pack the output of pass one into several instructions per card.  Other assemblers were written which placed the pass one output into memory for small programs.</dd></dl><p>As the 1400 series matured additional assemblers, programming languages and report generators became available, replacing SPS in most sites.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 258,
        "name": "IBM 1620",
        "url": "https://en.wikipedia.org/wiki/IBM_1620",
        "summary": "<p>The <b>IBM 1620</b> was announced by IBM on October 21, 1959, and marketed as an inexpensive \"scientific computer\". After a total production of about two thousand machines, it was withdrawn on November 19, 1970. Modified versions of the 1620 were used as the CPU of the IBM 1710 and IBM 1720 Industrial Process Control Systems (making it the first digital computer considered reliable enough for real-time process control of factory equipment).</p><p>Being variable-word-length decimal, as opposed to fixed-word-length pure binary, made it an especially attractive first computer to learn on –  and hundreds of thousands of students had their first experiences with a computer on the IBM 1620. </p><p>Core memory cycle times were 20 microseconds for the (earlier) Model I, 10 microseconds for the Model II (about a thousand times slower than typical computer main memory in 2006). The Model II was introduced in 1962.</p>",
        "infobox": "N/A"
    },
    {
        "id": 259,
        "name": "IBM Basic assembly language",
        "url": "https://en.wikipedia.org/wiki/IBM_Basic_Assembly_Language_and_successors",
        "summary": "<p><b>Basic Assembly Language</b> (<b>BAL</b>) is the commonly used term for a low-level programming language used on IBM System/360 and successor mainframes. Originally, \"Basic Assembly Language\" applied only to an extremely restricted dialect designed to run under control of IBM Basic Programming Support (BPS/360) on systems with only 8 KB of main memory, and only a card reader, a card punch, and a printer for input/output — thus the word \"Basic\". However, the full name and the initialism \"BAL\" almost immediately attached themselves in popular use to all assembly-language dialects on the System/360 and its descendants. BAL for BPS/360 was introduced with the System/360 in 1964. </p><p>Assemblers on other System/360 operating systems through System/370, System/390,  and System z, as well as the UNIVAC Series 90 mainframes made by Sperry Corporation, and the BS2000 Mainframes currently made by Fujitsu, inherited and extended its syntax. The latest derived language is known as the IBM High-Level Assembler (HLASM).  Programmers utilizing this family of assemblers also refer to them as ALC, (for Assembly Language Coding), or simply \"assembler\".\n</p><p>BAL is also the mnemonic of the \"Branch And Link\" instruction.</p>",
        "infobox": "N/A"
    },
    {
        "id": 260,
        "name": "IBM HAScript",
        "url": "https://en.wikipedia.org/wiki/IBM_HAScript",
        "summary": "<p><b>HAScript</b>, or Host Access Script, is an IBM-developed macro language with an XML syntax designed for programmatic interaction with terminal-based applications. HAScript is based on a state machine principle. The first commercial implementation appeared in IBM's Host On-Demand in the late 1990s. </p><p>IBM software products that use HAScript include WebSphere Host On-Demand (HOD), Personal Communications, and WebSphere Host Access Transformation Services (HATS). When accessing the IBM Mainframe the HAScript API allows for Host emulation whereby information from the host screen can be retrieved and reformatted within a webpage, or other software application.  There has been limited adoption of HAScript as it requires an intense amount of system resources, general process overhead and Java virtual machine resources.  To date, the implementation of HAScript by other software companies has been mild as the language used for communication is not universally standardized.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 261,
        "name": "IBM Informix-4GL",
        "url": "https://en.wikipedia.org/wiki/IBM_Informix-4GL",
        "summary": "<p><b>Informix-4GL</b> is a 4GL programming language developed by Informix during the mid-1980s. </p>",
        "infobox": "N/A"
    },
    {
        "id": 262,
        "name": "IBM RPG",
        "url": "https://en.wikipedia.org/wiki/IBM_RPG",
        "summary": "<p><b>RPG</b> is a high-level programming language (HLL) for business applications. RPG is an IBM proprietary programming language and its later versions are available only on IBM i- or OS/400-based systems.</p><p>It has a long history, having been developed by IBM in 1959 as the <b>Report Program Generator</b> — a tool to replicate punched card processing on the IBM 1401 —  then updated to RPG II for the IBM System/3 in the late 1960s, and since evolved into an HLL equivalent to COBOL and PL/I. </p><p>It remains a popular programming language on the IBM i operating system, which runs on IBM Power platform hardware.  The current version, <b>RPG IV</b>, a.k.a. ILE RPG, provides a modern programming environment.\n</p>",
        "infobox": {
            "name": "RPG<br />Report Program Generator",
            "paradigm": "Programming paradigm#Support for multiple paradigms|Multi-paradigm",
            "year": "1959",
            "developer": "IBM",
            "latest_release_version": "RPG IV version 7 release 2",
            "latest_release_date": "2014|05|02",
            "typing": [
                "Strong and weak typing|Strong",
                "Type system#STATIC|static"
            ],
            "dialects": [
                "RPG",
                "RPG&nbsp;II",
                "RPG&nbsp;III",
                "RPG&nbsp;400",
                "RPG&nbsp;IV",
                "RPG/ILE; RPG/Free",
                "Baby/36",
                "Baby/400",
                "Lattice&nbsp;RPG"
            ],
            "influenced_by": [
                "IBM 709/90 9PAC|9PAC",
                "FARGO (programming language)|FARGO"
            ],
            "influenced": "IBM RPG II|RPG&nbsp;II",
            "operating_system": [
                "Control Program Facility|CPF",
                "IBM System/34",
                "36 System Support Program|SSP",
                "IBM i|OS/400",
                "IBM i",
                "OS/VS1",
                "z/OS",
                "VSE (operating system)|DOS/VSE",
                "VSE (operating system)|VSE/SP",
                "VSE (operating system)|VSE/ESA",
                "VSE (operating system)|z/VSE",
                "VS/9",
                "PRIMOS",
                "OpenVMS",
                "Wang Laboratories#The Wang VS computer line|Wang VS",
                "Burroughs MCP",
                "OS/2",
                "Microsoft Windows"
            ]
        }
    },
    {
        "id": 263,
        "name": "IDL (programming language)",
        "url": "https://en.wikipedia.org/wiki/IDL_(programming_language)",
        "summary": "<p><b>IDL</b>, short for <b>Interactive Data Language</b>, is a programming language used for data analysis.  It is popular in particular areas of science, such as astronomy, atmospheric physics and medical imaging. IDL shares a common syntax with PV-Wave and originated from the same codebase, though the languages have subsequently diverged in detail. There are also free or costless implementations, such as GNU Data Language (GDL) and Fawlty Language (FL). </p>",
        "infobox": {
            "name": "IDL (Interactive Data Language)",
            "paradigm": "Array programming|vector-oriented programming",
            "designer": "David Stern",
            "developer": "David Stern & ITT Visual Information Solutions|ITT Visual Information Solutions (ITT VIS)",
            "latest release version": "IDL 8.7.3",
            "latest release date": "February 2020",
            "typing": "dynamic typing|Dynamic",
            "implementations": [
                "IDL",
                "GNU Data Language",
                "Fawlty Language"
            ],
            "year": "1977"
        }
    },
    {
        "id": 264,
        "name": "Icon (programming language)",
        "url": "https://en.wikipedia.org/wiki/Icon_(programming_language)",
        "summary": "<p><b>Icon</b> is a very high-level programming language featuring goal-directed execution and many facilities for managing strings and textual patterns. It is related to SNOBOL and SL5, string processing languages. Icon is not object-oriented, but an object-oriented extension called Idol was developed in 1996 which eventually became Unicon. </p>",
        "infobox": {
            "name": "Icon",
            "logo": "Icon logo.png",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: structured programming|structured",
                "text-oriented"
            ],
            "designer": "Ralph Griswold",
            "typing": "dynamic typing|dynamic",
            "implementations": [
                "Icon",
                "Jcon"
            ],
            "dialects": "Unicon programming language|Unicon",
            "influenced": [
                "Unicon programming language|Unicon",
                "Python (programming language)|Python",
                "[https://github.com/proebsting/goaldi Goaldi]"
            ],
            "website": "www.cs.arizona.edu/icon",
            "year": "1977",
            "latest_release_version": "9.5.1",
            "latest_release_date": "2018|09|27",
            "influenced_by": [
                "SNOBOL",
                "SL5",
                "ALGOL"
            ]
        }
    },
    {
        "id": 265,
        "name": "Idris (programming language)",
        "url": "https://en.wikipedia.org/wiki/Idris_(programming_language)",
        "summary": "<p><b>Idris</b> is a purely-functional programming language with dependent types, optional lazy evaluation, and features such as a totality checker. Idris may be used as a proof assistant, but it is designed to be a general-purpose programming language similar to Haskell. </p><p>The Idris type system is similar to Agda's, and proofs are similar to Coq's, including tactics (theorem proving functions/procedures) via elaborator reflection.  Compared to Agda and Coq, Idris prioritizes management of side effects and support for embedded domain-specific languages. Idris compiles to C (relying on a custom copying garbage collector using Cheney's algorithm) and JavaScript (both browser- and Node.js-based). There are third-party code generators for other platforms, including JVM, CIL, and LLVM.</p><p>Idris is named after a singing dragon from the 1970s UK children's television program <i>Ivor the Engine</i>.</p>",
        "infobox": {
            "name": "Idris",
            "paradigm": "functional programming|Functional",
            "designer": "Edwin Brady",
            "released": "2007",
            "latest_release_version": "1.3.3",
            "latest_release_date": "2020|05|24",
            "influenced_by": [
                "Agda (programming language)|Agda",
                "Clean (programming language)|Clean",
                "Coq",
                "Epigram (programming language)|Epigram",
                "F Sharp (programming language)|F#",
                "Haskell (programming language)|Haskell",
                "ML (programming language)|ML",
                "Rust (programming language)|Rust"
            ],
            "operating_system": "Cross-platform",
            "license": "BSD licenses|BSD",
            "file ext": [
                ".idr",
                ".lidr"
            ],
            "website": "idris-lang.org"
        }
    },
    {
        "id": 266,
        "name": "Inform (programming language)",
        "url": "https://en.wikipedia.org/wiki/Inform",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Inform</b> is a programming language and design system for interactive fiction originally created in 1993 by Graham Nelson.  Inform can generate programs designed for the Z-code or Glulx virtual machines.   Versions 1 through 5 were released between 1993 and 1996.  Around 1996, Nelson rewrote Inform from first principles to create version 6 (or <b>Inform 6</b>).\nOver the following decade, version 6 became reasonably stable and a popular language for writing interactive fiction.  In 2006, Nelson released <b>Inform 7</b> (briefly known as <b>Natural Inform</b>), a completely new language based on principles of natural language and a new set of tools based around a book-publishing metaphor.\n</p>",
        "infobox": {
            "name": "Inform",
            "logo": "File:Inform 7 IDE Icon.png",
            "author": "Graham Nelson",
            "developer": "Graham Nelson",
            "latest release version": "7 6M62",
            "latest release date": "release date|2015|12|24",
            "operating system": [
                "Microsoft Windows",
                "macOS|Mac OS X",
                "Linux",
                "others"
            ],
            "genre": "Interactive fiction development and play",
            "website": "http://inform7.com/"
        }
    },
    {
        "id": 267,
        "name": "IntelliCorp (Software)",
        "url": "https://en.wikipedia.org/wiki/IntelliCorp_(software)",
        "summary": "<p><b>IntelliCorp</b> (IC) sold its assets including LiveCompare, LiveModel and LiveInterface to Tricentis in May 2019. </p>",
        "infobox": {
            "name": "IntelliCorp",
            "logo": "[http://www.intellicorp.com/images/intellicorp.com.logo.png intellicorp.com.logo.png]",
            "founded": [
                "Menlo Park",
                "California|Menlo Park",
                "California (1980)"
            ],
            "location": [
                "San Jose",
                "California",
                "United States|US"
            ],
            "industry": "Software",
            "products": [
                "LiveCompare",
                "LiveModel and LiveInterface; legacy products= PowerModel (Kappa)",
                "LiveModel (Object Management Workbench)",
                "Kappa-PC and KEE"
            ],
            "footnotes": [
                "Founders (Douglas Brutlag",
                "Peter Friedland",
                "Edward Feigenbaum)"
            ]
        }
    },
    {
        "id": 268,
        "name": "Io (programming language)",
        "url": "https://en.wikipedia.org/wiki/Io_(programming_language)",
        "summary": "<p><b>Io</b> is a pure object-oriented programming language inspired by Smalltalk, Self, Lua, Lisp, Act1, and NewtonScript. Io has a prototype-based object model similar to the ones in Self and NewtonScript, eliminating the distinction between instance and class. Like Smalltalk, everything is an object and it uses dynamic typing. Like Lisp, programs are just data trees. Io uses actors for concurrency. </p><p>Remarkable features of Io are its minimal size and openness to using external code resources. Io is executed by a small, portable virtual machine.\n</p>",
        "infobox": {
            "name": "Io",
            "logo": "Image:Io-logo.svg|64px",
            "paradigm": "Object-oriented programming|object-oriented prototype-based programming|prototype-based",
            "year": "2002",
            "latest release version": "20170906",
            "latest release date": "2017|08|11",
            "designer": "Steve Dekorte",
            "developer": [
                "Steve Dekorte",
                "Jonathan Wright",
                "Jeremy Tregunna"
            ],
            "typing": [
                "Type system|dynamic",
                "Strongly-typed programming language|strong"
            ],
            "implementations": "[http://www.iolanguage.com/ Io] [https://web.archive.org/web/20110716175739/http://synrc.com/io/index.htm Io.NET]",
            "influenced_by": [
                "Smalltalk",
                "NewtonScript",
                "Self (programming language)|Self",
                "Lua (programming language)|Lua",
                "Lisp (programming language)|Lisp",
                "Python (programming language)|Python",
                "Actor_model_middle_history#Actor_programming_languages|Act1"
            ],
            "influenced": [
                "Ioke (programming language)|Ioke",
                "Potion"
            ]
        }
    },
    {
        "id": 269,
        "name": "JADE (programming language)",
        "url": "https://en.wikipedia.org/wiki/JADE_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p><b>JADE</b> is a proprietary object-oriented software development and deployment platform product from the New Zealand-based Jade Software Corporation, first released in 1996. It consists of the JADE programming language, Integrated development environment and debugger, integrated application server and object database management system.\n</p><p>Designed as an end-to-end development environment to allow systems to be coded in one language from the database server down to the clients, it also provides APIs for other languages, including .NET Framework, Java, C/C++ and Web services.\n</p><p>Although a free limited licence is available for development, using the JADE platform requires per-process fees to be paid.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 270,
        "name": "JAL (compiler)",
        "url": "https://en.wikipedia.org/wiki/JAL_(compiler)",
        "summary": "<p><b>JAL (Just Another Language)</b> is a Pascal-like programming language and compiler that generates executable code for PIC microcontrollers.  It is a free-format language with a compiler that runs on Linux, MS-Windows and MS-DOS (OSX support). It is configurable and extendable through the use of libraries and can even be combined with PIC assembly language. </p>",
        "infobox": "N/A"
    },
    {
        "id": 271,
        "name": "JASS",
        "url": "https://en.wikipedia.org/wiki/JASS",
        "summary": "<p><b>JASS</b> and <b>JASS2</b> (sometimes said to stand for <b>Just Another Scripting Syntax</b>) is a scripting language provided with an event-driven API created by Blizzard Entertainment. It is used extensively by their games <i>Warcraft III</i> (JASS2) and <i>StarCraft</i> (JASS) for scripting events in the game world. Map creators can use it in the <i>Warcraft III</i> World Editor and the <i>Starcraft</i> Editor to create scripts for triggers and AI (artificial intelligence) in custom maps and campaigns. </p><p>Blizzard Entertainment has replaced JASS with <b>Galaxy</b> in <i>Starcraft II</i>.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 272,
        "name": "JEAN",
        "url": "https://en.wikipedia.org/wiki/JEAN",
        "summary": "<p><b>JEAN</b> was a dialect of the JOSS programming language developed for and used on ICT 1900 series computers in the late 1960s and early 1970s; it was implemented under the MINIMOP operating system. It was used at the University of Southampton.</p><p><b>JEAN</b> was an acronym derived from \"<b>J</b>OSS <b>E</b>xtended and <b>A</b>dapted for <b>N</b>ineteen-hundred\". It was operated from a Teletype terminal.  </p>\n",
        "infobox": "N/A"
    },
    {
        "id": 273,
        "name": "JOSS",
        "url": "https://en.wikipedia.org/wiki/JOSS",
        "summary": "<p><b>JOSS</b>, an acronym for <b>JOHNNIAC Open Shop System</b>, was one of the very first interactive, time-sharing programming languages. It pioneered a number of features that would become common in languages from the 1960s into the 1980s, including line numbers as both editing instructions and targets for branches, statements predicated by boolean decisions, and a built-in editor that can perform instructions in \"direct\" or \"immediate\" mode, a conversational user interface. </p><p>JOSS was initially implemented on the JOHNNIAC machine at Rand Corporation and put online in 1963. It proved very popular, and the users quickly bogged the machine down. By 1964 a replacement was sought with higher performance. JOHNNIAC was retired in 1966 and replaced by a PDP-6, which ultimately grew to support hundreds of computer terminals based on the IBM Selectric. The terminals used green ink for user input and black for the computer's response. Any command that was not understood elicited the response \"Eh?\" or \"SORRY\".\n</p><p>The system was highly influential, spawning a variety of ports and offshoots. Some remained similar to the original, like TELCOMP and STRINGCOMP, CAL, CITRAN, ISIS, PIL/I, JEAN (ICT 1900 series), AID (PDP-10); while others, such as FOCAL and MUMPS, developed in distinctive directions. It also bears a strong resemblance to the BASIC interpreters found on microcomputers in the 1980s, differing primarily in syntax details.\n</p>",
        "infobox": {
            "name": "JOSS",
            "released": "1963",
            "developer": [
                "Cliff Shaw",
                "RAND"
            ],
            "influenced": [
                "TELCOMP",
                "CAL (programming language)|CAL",
                "FOCAL (programming language)|FOCAL and MUMPS"
            ]
        }
    },
    {
        "id": 274,
        "name": "JOVIAL",
        "url": "https://en.wikipedia.org/wiki/JOVIAL",
        "summary": "<p><b>JOVIAL</b> is a high-level programming language similar to ALGOL, specialized for developing embedded systems (specialized computer systems designed to perform one or a few dedicated functions, usually embedded as part of a larger, more complete device, including mechanical parts). It was a major system programming language through the 1960s and 70s. </p>",
        "infobox": {
            "name": "JOVIAL",
            "paradigms": [
                "Procedural programming|Procedural",
                "Imperative programming|imperative",
                "Structured programming|structured"
            ],
            "family": "ALGOL",
            "designer": "System Development Corporation",
            "developer": "Software Engineering Associates",
            "released": "1960",
            "typing": [
                "Type system#Type checking|static",
                "Strong and weak typing|strong",
                "Type system#Safely and unsafely typed systems|safe",
                "Structural type system|structural"
            ],
            "scope": "Scope (computer science)|Lexical",
            "implementations": [
                "Mainframe computer|mainframe",
                "micro",
                "PC",
                "macOS",
                "Microsoft Windows|Windows",
                "Linux",
                "SPARC",
                "PowerPC",
                "1750A",
                "other legacy systems"
            ],
            "dialects": [
                "J3",
                "J3B-2",
                "J73"
            ],
            "influenced by": [
                "ALGOL",
                "Semi-Automatic Ground Environment|SAGE"
            ],
            "influenced": [
                "CMS-2 (programming language)|CMS-2",
                "Coral 66",
                "SYMPL"
            ]
        }
    },
    {
        "id": 275,
        "name": "JScript",
        "url": "https://en.wikipedia.org/wiki/JScript",
        "summary": "<p><b>JScript</b> is Microsoft's dialect of the ECMAScript standard that is used in Microsoft's Internet Explorer. </p><p>JScript is implemented as an Active Scripting engine. This means that it can be \"plugged in\" to OLE Automation applications that support Active Scripting, such as Internet Explorer, Active Server Pages, and Windows Script Host. It also means such applications can use multiple Active Scripting languages, e.g., JScript, VBScript or PerlScript.\n</p><p>JScript was first supported in the Internet Explorer 3.0 browser released in August 1996. Its most recent version is JScript 9.0, included in Internet Explorer 9.\n</p><p>JScript 10.0 is a separate dialect, also known as JScript .NET, which adds several new features from the abandoned fourth edition of the ECMAScript standard. It must be compiled for .NET Framework version 2 or version 4, but static type annotations are optional.\n</p>",
        "infobox": {
            "name": "JScript",
            "logo": "File:Jscript icon.gif|32px",
            "file_ext": [
                ".js",
                ".jse",
                ".wsf",
                ".wsc (.htm",
                ".html",
                "HTML Application|.hta",
                "Active Server Pages|.asp)"
            ],
            "year": "1996",
            "developer": "Microsoft",
            "latest_release_version": "9.0",
            "latest_release_date": "March 2011",
            "typing": [
                "Dynamic typing|Dynamic",
                "weak typing|weak",
                "duck typing|duck"
            ],
            "implementations": [
                "Active Scripting",
                "JScript .NET"
            ],
            "operating system": "Microsoft Windows",
            "website": "url|msdn.microsoft.com/library/hbxc2t98.aspx"
        }
    },
    {
        "id": 276,
        "name": "JScript .NET",
        "url": "https://en.wikipedia.org/wiki/JScript_.NET",
        "summary": "<p><b>JScript .NET</b> is a .NET programming language developed by Microsoft. </p><p>The primary differences between JScript and JScript .NET can be summarized as follows:\n</p><p>Firstly, JScript is a scripting language, and as such programs (or more suggestively, scripts) can be executed without the need to compile the code first. This is not the case with the JScript .NET command-line compiler, since this next-generation version relies on the .NET Common Language Runtime (CLR) for execution, which requires that the code be compiled to Common Intermediate Language (CIL), formerly called Microsoft Intermediate Language (MSIL), code before it can be run. Nevertheless, JScript .NET still provides full support for interpreting code at runtime (e.g., via the <code>Function</code> constructor or the <code>eval</code> function) and indeed the interpreter can be exposed by custom applications hosting the JScript .NET engine via the VSA interfaces.\n</p><p>Secondly, JScript has a strong foundation in Microsoft's ActiveX/COM technologies, and relies primarily on ActiveX components to provide much of its functionality (including database access via ADO, file handling, etc.), whereas JScript .NET uses the .NET Framework to provide equivalent functionality. For backwards-compatibility (or for where no .NET equivalent library exists), JScript .NET still provides full access to ActiveX objects via .NET / COM Interop using both the ActiveXObject constructor and the standard methods of the .NET <b>Type</b> class.\n</p><p>Although the .NET Framework and .NET languages such as C# and Visual Basic .NET have seen widespread adoption, JScript .NET has never received much attention, by the media or by developers. It is not supported in Microsoft's premier development tool, Visual Studio .NET. However, ASP.NET supports JScript .NET.\n</p>",
        "infobox": {
            "name": "JScript .NET",
            "paradigm": "multi-paradigm",
            "developer": "Microsoft|Microsoft Corporation",
            "typing": [
                "duck typing|duck",
                "weak typing|weak",
                "dynamic typing|dynamic"
            ],
            "influenced_by": [
                "JScript",
                "ECMAScript"
            ],
            "platform": ".NET Framework"
        }
    },
    {
        "id": 277,
        "name": "J (programming language)",
        "url": "https://en.wikipedia.org/wiki/J_(programming_language)",
        "summary": "<p>The <b>J</b> programming language, developed in the early 1990s by Kenneth E. Iverson and Roger Hui, is an array programming language based primarily on APL (also by Iverson). </p><p>To avoid repeating the APL special-character problem, J uses only the basic ASCII character set, resorting to the use of the dot and colon as <i>inflections</i> to form short words similar to <i>digraphs</i>. Most such <i>primary</i> (or <i>primitive</i>) J words serve as mathematical symbols, with the dot or colon extending the meaning of the basic characters available.  Also, many characters which in other languages often must be paired (such as <code>[] {} \"\" ``</code> or <code>&lt;&gt;</code>) are treated by J as stand-alone words or, when inflected, as single-character roots of multi-character words.\n</p><p>J is a very terse array programming language, and is most suited to mathematical and statistical programming, especially when performing operations on matrices. It has also been used in extreme programming and network performance analysis.</p><p>Like John Backus's languages FP and FL, J supports function-level programming via its <i>tacit programming</i> features.\n</p><p>Unlike most languages that support object-oriented programming, J's flexible hierarchical namespace scheme (where every name exists in a specific <i>locale</i>) can be effectively used as a framework for both class-based and prototype-based object-oriented programming.\n</p><p>Since March 2011, J is free and open-source software under the GNU General Public License version 3 (GPLv3). One may also purchase source under a negotiated license.</p>\n\n\n",
        "infobox": {
            "name": "J",
            "logo": "File:J (programming language) icon.png|64px",
            "par-adigm": [
                "Array programming|Array",
                "functional programming|functional",
                "function-level programming|function-level",
                "tacit programming|tacit"
            ],
            "released": "1990",
            "designer": [
                "Kenneth E. Iverson",
                "Roger Hui"
            ],
            "developer": "JSoftware",
            "latest release version": "J901",
            "latest release date": "2019|12|15",
            "typing": "dynamic typing|dynamic",
            "implementations": "J",
            "influenced by": "APL (programming language)|APL",
            "influenced": [
                "NumPy",
                "SuperCollider"
            ],
            "operating system": [
                "Cross-platform: Microsoft Windows|Windows",
                "Linux",
                "macOS"
            ],
            "license": "GNU General Public License|GPLv3",
            "website": "www.jsoftware.com"
        }
    },
    {
        "id": 278,
        "name": "J Sharp",
        "url": "https://en.wikipedia.org/wiki/J_Sharp",
        "summary": "<p><b>Visual J#</b> (pronounced \"jay-sharp\") is an implementation of the J# programming language that was a transitional language for programmers of Java and Visual J++ languages, so they could use their existing knowledge and applications with the .NET Framework. It was introduced in 2002 and discontinued in 2007, with support for the final release of the product continuing until October 2017. </p><p>J# worked with Java bytecode as well as source so it could be used to transition applications that used third-party libraries even if their original source code was unavailable. It was developed by the Hyderabad-based Microsoft India Development Center at HITEC City in India.</p>",
        "infobox": {
            "name": "Visual J#",
            "paradigm": [
                "Object-oriented",
                "structured",
                "imperative"
            ],
            "year": "2002",
            "developer": "Microsoft",
            "discontinued": "October 2017",
            "latest_release_version": "v2.0 Second Edition",
            "latest_release_date": "2007|05|18",
            "influenced_by": "Java (programming language)|Java and Visual J++",
            "platform": ".NET Framework"
        }
    },
    {
        "id": 279,
        "name": "Janus (concurrent constraint programming language)",
        "url": "https://en.wikipedia.org/wiki/Janus_(concurrent_constraint_programming_language)",
        "summary": "<p><b>Janus</b> is a computer programming language partially described by K. Kahn and Vijay A. Saraswat in the paper \"Actors as a special case of concurrent constraint (logic) programming\" in 1990. It is a concurrent constraint language without backtracking. </p><p>Janus models concurrency through the use of <i>bag channels</i>.  Code that needs to send a message to a process does so by constraining a bag to be the union of another bag and the singleton bag of the message. The other bag is then available to be constrained for sending subsequent messages.\n</p><p>The process receives the message by matching the bag to a pattern that says it is the union of some singleton and some other bag. The logic of the bag channels produces a property shared by the actor model, namely that the order of arrival of the messages is not guaranteed.  However, unlike actors in the actor model, processes in Janus can pass around their \"mailboxes\" so to speak, in the form of\nbags, and can hold more than one.  This ability to pass mailboxes around and hold more than one is inherited in computer programming language ToonTalk, which is influenced by Janus.\n</p><p>Janus, the programming language, is named after Janus, the two-faced Roman god, because every logical variable in Janus has as its two \"faces\", two aspects that can be passed as arguments.  These are called the <i>asker</i> and the <i>teller</i>.  These represent, respectively, the right to ask the value of the variable (or some characteristic of the value) and the right to tell the value (or to tell some constraint on what the value can be).  The asker and teller aspects can be passed around as arguments independently of each other.  Neither right implies the other right.  The syntax of the language prevents copying a teller or exercising it more than once. Logical contradiction is statically prevented, according to Kahn and Saraswat.\n</p>",
        "infobox": {
            "name": "Janus",
            "year": "1990",
            "designer": "Ken Kahn and Vijay A. Saraswat",
            "paradigm": "Concurrent constraint logic programming|concurrent constraint logic",
            "turing-complete": "Yes",
            "implementations": "(none available)"
        }
    },
    {
        "id": 280,
        "name": "Janus (time-reversible computing programming language)",
        "url": "https://en.wikipedia.org/wiki/Janus_(time-reversible_computing_programming_language)",
        "summary": "<p><b>Janus</b> is a time-reversible programming language written at Caltech in 1982. The operational semantics of the language were formally specified, together with a program inverter and an invertible self-interpreter, in 2007 by Tetsuo Yokoyama and Robert Glück. A Janus inverter and interpreter is made freely available by the TOPPS research group at DIKU. Another Janus interpreter was implemented in Prolog in 2009. The below summarises the language presented in the 2007 paper. </p><p>Janus is an imperative programming language with a global store (there is no stack or heap allocation). Janus is a reversible programming language, i.e. it supports deterministic forward and backward computation by local inversion.\n</p>",
        "infobox": {
            "name": "Janus",
            "year": [
                "1982",
                "2007"
            ],
            "designer": [
                "Christopher Lutz",
                "Howard Derby",
                "Tetsuo Yokoyama",
                "and Robert Glück"
            ],
            "paradigm": [
                "Imperative programming|imperative(Procedural programming|procedural)",
                "Reversible computing|reversible"
            ],
            "turing-complete": "Yes",
            "implementations": "http://topps.diku.dk/pirc/janus-playground/",
            "website": "http://tetsuo.jp/ref/janus.html"
        }
    },
    {
        "id": 281,
        "name": "JavaFX Script",
        "url": "https://en.wikipedia.org/wiki/JavaFX_Script",
        "summary": "<p><b>JavaFX Script</b> was a scripting language designed by Sun Microsystems, forming part of the JavaFX family of technologies on the Java Platform. </p><p>JavaFX targeted the Rich Internet Application domain (competing with Adobe Flex and Microsoft Silverlight), specializing in rapid development of visually rich applications for the desktop and mobile markets. JavaFX Script works with integrated development environments such as NetBeans, Eclipse and IntelliJ IDEA. JavaFX is released under the GNU General Public License, via the Sun sponsored OpenJFX project.\n</p>",
        "infobox": {
            "name": "JavaFX",
            "logo": "File:JavaFX Logo.png|200px",
            "developer": "Sun Microsystems",
            "latest release version": "1.2",
            "latest release date": "release date|2009|06|02",
            "platform": "Java Runtime Environment",
            "operating_system": "Cross-platform",
            "license": "GNU General Public License|GPL",
            "website": "http://javafx.com/"
        }
    },
    {
        "id": 282,
        "name": "JavaScript",
        "url": "https://en.wikipedia.org/wiki/JavaScript",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p><b>JavaScript</b> (<span></span>), often abbreviated as <b>JS</b>, is a programming language that conforms to the ECMAScript specification. JavaScript is high-level, often just-in-time compiled, and multi-paradigm. It has curly-bracket syntax, dynamic typing, prototype-based object-orientation, and first-class functions.\n</p><p>Alongside HTML and CSS, JavaScript is one of the core technologies of the World Wide Web. JavaScript enables interactive web pages and is an essential part of web applications. The vast majority of websites use it for client-side page behavior, and all major web browsers have a dedicated JavaScript engine to execute it.\n</p><p>As a multi-paradigm language, JavaScript supports event-driven, functional, and imperative programming styles. It has application programming interfaces (APIs) for working with text, dates, regular expressions, standard data structures, and the Document Object Model (DOM). However, the language itself does not include any input/output (I/O), such as networking, storage, or graphics facilities, as the host environment (usually a web browser) provides those APIs.\n</p><p>JavaScript engines were originally used only in web browsers, but they are now embedded in some servers, usually via Node.js. They are also embedded in a variety of applications created with frameworks such as Electron and Cordova.\n</p><p>Although there are similarities between JavaScript and Java, including language name, syntax, and respective standard libraries, the two languages are distinct and differ greatly in design.\n</p>",
        "infobox": {
            "name": "JavaScript",
            "paradigm": [
                "event-driven programming|event-driven",
                "functional programming|functional",
                "imperative programming|imperative"
            ],
            "designer": [
                "Brendan Eich initially",
                "plus other key contributors to the ECMAScript specification"
            ],
            "typing": [
                "Dynamic typing|Dynamic",
                "Duck typing|duck"
            ],
            "implementations": [
                "V8 (JavaScript engine)|V8",
                "JavaScriptCore",
                "SpiderMonkey (JavaScript engine)|SpiderMonkey",
                "Chakra (JScript engine)|Chakra"
            ],
            "influenced": [
                "ActionScript",
                "AtScript",
                "CoffeeScript",
                "Dart (programming language)|Dart",
                "JScript .NET",
                "LiveScript",
                "Objective-J",
                "Opa (programming language)|Opa",
                "QML",
                "Raku (programming language)|Raku",
                "TypeScript"
            ],
            "File extensions": "flatlist|\n* <code>.js</code>\n* <code>.mjs</code>|ref| name=\"node.js ECMAScript Modules Specification\"|cite web|url=https://github.com/nodejs/node-eps/blob/master/002-es-modules.md|title=nodejs/node-eps|website=GitHub|</ref>|",
            "wikibooks": "JavaScript",
            "year": "start date and age|1995|12|04",
            "latest_release_version": "ECMAScript 2020",
            "latest_release_date": "start date and age|2020|6",
            "latest_preview_version": "ECMAScript 2021",
            "influenced_by": [
                "AWK ",
                "C (programming language)|C",
                "HyperTalk",
                "Java (programming language)|Java ",
                "Lua (programming language)|Lua",
                "Perl",
                "Python (programming language)|Python",
                "Scheme (programming language)|Scheme",
                "Self (programming language)|Self"
            ]
        }
    },
    {
        "id": 283,
        "name": "Java (programming language)",
        "url": "https://en.wikipedia.org/wiki/Java_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n\n<p><b>Java</b> is a general-purpose programming language that is class-based, object-oriented, and designed to have as few implementation dependencies as possible. It is intended to let application developers <i>write once, run anywhere</i> (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation. Java applications are typically compiled to bytecode that can run on any Java virtual machine (JVM) regardless of the underlying computer architecture. The syntax of Java is similar to C and C++, but it has fewer low-level facilities than either of them. As of 2019, Java was one of the most popular programming languages in use according to GitHub, particularly for client-server web applications, with a reported 9 million developers.</p><p>Java was originally developed by James Gosling at Sun Microsystems (which has since been acquired by Oracle) and released in 1995 as a core component of Sun Microsystems' Java platform. The original and reference implementation Java compilers, virtual machines, and class libraries were originally released by Sun under proprietary licenses. As of May 2007, in compliance with the specifications of the Java Community Process, Sun had relicensed most of its Java technologies under the GNU General Public License. Meanwhile, others have developed alternative implementations of these Sun technologies, such as the GNU Compiler for Java (bytecode compiler), GNU Classpath (standard libraries), and IcedTea-Web (browser plugin for applets).\n</p><p>The latest versions are Java 14, released in March 2020, and Java 11, a currently supported long-term support (LTS) version, released on September 25, 2018; Oracle released for the legacy Java 8 LTS the last free public update in January 2019 for commercial use, while it will otherwise still support Java 8 with public updates for personal use up to at least December 2020. Oracle (and others) highly recommend uninstalling older versions of Java because of serious risks due to unresolved security issues. Since Java 9, 10, 12 and 13 are no longer supported, Oracle advises its users to immediately transition to the latest version (currently Java 14) or an LTS release.\n</p>",
        "infobox": {
            "name": "Java Programming Language",
            "logo": "File:Java programming language logo.svg|259x259px",
            "paradigm": [
                "Programming paradigm#Multi-paradigm|Multi-paradigm: generic programming|generic",
                "object-oriented (class-based programming|class-based)",
                "imperative programming|imperative",
                "reflection (computer programming)|reflective"
            ],
            "latest release version": "Java SE 14",
            "designer": "James Gosling",
            "developer": "Sun Microsystems",
            "typing": [
                "type system|Static",
                "strong",
                "safe",
                "nominal type system|nominative",
                "manifest typing|manifest"
            ],
            "implementation": [
                "Compilers: OpenJDK (javac",
                "sjavac)",
                "GNU Compiler for Java (GCJ)",
                "Eclipse Compiler for Java (ECJ)<br />Virtual machines: OpenJDK JRE",
                "JRockit|Oracle JRockit",
                "Azul Systems|Azul Zing",
                "OpenJ9|IBM J9",
                "Excelsior JET",
                "Gluon VM",
                "Microsoft Java Virtual Machine|Microsoft JVM",
                "Apache Harmony<br />JIT compilers: HotSpot",
                "GraalVM",
                "Azul Systems|Azul Falcon (LLVM)"
            ],
            "influenced_by": [
                "CLU (programming language)|CLU",
                "Simula67",
                "LISP",
                "SmallTalk",
                "Ada (programming language)|Ada 83",
                "C++",
                "C Sharp (programming language)|C#",
                "Eiffel (programming language)|Eiffel",
                "Mesa (programming language)|Mesa",
                "Modula-3",
                "Oberon (programming language)|Oberon",
                "Objective-C",
                "UCSD Pascal",
                "Object Pascal"
            ],
            "influenced": [
                "Ada (programming language)|Ada 2005",
                "BeanShell",
                "C Sharp (programming language)|C#",
                "Chapel (programming language)|Chapel",
                "Clojure",
                "ECMAScript",
                "Fantom (programming language)|Fantom",
                "Gambas",
                "Groovy (programming language)|Groovy",
                "Hack (programming language)|Hack",
                "Haxe (programming language)|Haxe",
                "J Sharp|J#",
                "Kotlin (programming language)|Kotlin",
                "PHP",
                "Python (programming language)|Python",
                "Scala (programming language)|Scala",
                "Seed7",
                "Vala (programming language)|Vala"
            ],
            "file_ext": [
                ".java",
                "Java class file|.class",
                "JAR (file format)|.jar"
            ],
            "wikibooks": "Java Programming"
        }
    },
    {
        "id": 284,
        "name": "Jess (programming language)",
        "url": "https://en.wikipedia.org/wiki/Jess_(programming_language)",
        "summary": "<p><b>Jess</b> is a rule engine for the Java platform that was developed by Ernest Friedman-Hill of Sandia National Labs. It is a superset of the CLIPS programming language. It was first written in late 1995. The language provides rule-based programming for the automation of an expert system, and is frequently termed as an <i>expert system shell</i>. In recent years, intelligent agent systems have also developed, which depend on a similar capability. </p><p>Rather than a procedural paradigm, where a single program has a loop that is activated only one time, the declarative paradigm used by Jess continuously applies a collection of rules to a collection of facts by a process called <i>pattern matching</i>. Rules can modify the collection of facts, or they can execute any Java code.\n</p><p>The Jess rules engine utilizes the Rete algorithm, and can be utilized to create:\n</p>\n<ul><li>Java servlets</li>\n<li>Enterprise JavaBeans</li>\n<li>Applets</li></ul>",
        "infobox": {
            "name": "Jess",
            "website": "[http://www.jessrules.com/ www.jessrules.com]",
            "developer": "Sandia National Laboratories",
            "license": "Closed source software|Closed source / Public Domain",
            "platform": "Java (programming language)|Java",
            "latest release version": "7.1p2",
            "latest release date": "start date and age|2008|11|05"
        }
    },
    {
        "id": 285,
        "name": "Job Control Language",
        "url": "https://en.wikipedia.org/wiki/Job_Control_Language",
        "summary": "<p><b>Job Control Language</b> (<b>JCL</b>) is a name for scripting languages used on IBM mainframe operating systems to instruct the system on how to run a batch job or start a subsystem.</p><p>More specifically, the purpose of JCL is to say which programs to run, using which files or devices  for input or output, and at times to also indicate under what conditions to skip a step. </p><p>There are two distinct IBM Job Control languages: \n</p>\n<ul><li>one for the operating system lineage that begins with DOS/360 and whose latest member is z/VSE; and</li>\n<li>the other for the lineage from OS/360 to z/OS, the latter now including JES extensions, Job <i>Entry</i> Control Language (JECL).</li></ul><p>They share some basic syntax rules and a few basic concepts, but are otherwise very different. The VM operating system does not have JCL as such; the CP and CMS components each have command languages.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 286,
        "name": "Join Java",
        "url": "https://en.wikipedia.org/wiki/Join_Java",
        "summary": "<p><b>Join Java</b> is a programming language based on the join-pattern that extends the standard Java programming language with the join semantics of the join-calculus.  It was written at the University of South Australia within the Reconfigurable Computing Lab by Dr. Von Itzstein. </p>",
        "infobox": {
            "name": "Join Java",
            "paradigm": [
                "Procedural programming|Procedural",
                "Reflective programming|Reflective"
            ],
            "released": "2000",
            "designer": "[http://joinjava.unisa.edu.au/members.htm G. Stewart von Itzstein]",
            "influenced by": "Java (programming language)|Java",
            "website": "[http://joinjava.unisa.edu.au/ joinjava.unisa.edu.au]"
        }
    },
    {
        "id": 287,
        "name": "Joule (programming language)",
        "url": "https://en.wikipedia.org/wiki/Joule_(programming_language)",
        "summary": "<p><b>Joule</b> is a concurrent dataflow programming language, designed for building distributed applications. It is so concurrent that the order of statements within a block is irrelevant to the operation of the block. Statements are executed whenever possible, based on their inputs. Everything in Joule happens by sending messages. There is no control flow. Instead, the programmer describes the flow of data, making it a dataflow programming language.   </p><p>It is considered the precursor to the E programming language.\n</p>",
        "infobox": {
            "name": "Joule",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: object-oriented programming|object-oriented",
                "distributed computing|distributed",
                "Dataflow"
            ],
            "year": "1996",
            "designer": "E. Dean Tribble",
            "typing": "untyped",
            "influenced_by": [
                "Logic Programming#Concurrent_logic_programming|Concurrent Logic Programming",
                "Actor model|Actors"
            ],
            "influenced": "E (programming language)|E"
        }
    },
    {
        "id": 288,
        "name": "Joy (programming language)",
        "url": "https://en.wikipedia.org/wiki/Joy_(programming_language)",
        "summary": "<p>The <b>Joy programming language</b> in computer science is a purely functional programming language that was produced by Manfred von Thun of La Trobe University in Melbourne, Australia. Joy is based on composition of functions rather than lambda calculus. It has turned out to have many similarities to Forth, due not to design but to a sort of parallel evolution and convergence. It was also inspired by the function-level programming style of John Backus's FP.</p>",
        "infobox": {
            "name": "Joy",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: functional programming|functional",
                "concatenative programming language|concatenative",
                "Stack-oriented programming language|stack-oriented"
            ],
            "year": "2001",
            "designer": "Manfred von Thun",
            "developer": "Manfred von Thun<br>John Cowan",
            "latest release version": [
                "March 17",
                "2003"
            ],
            "latest release date": [
                "March 17",
                "2003"
            ],
            "typing": [
                "strong typing|strong",
                "dynamic typing|dynamic"
            ],
            "implementations": [
                "Joy0",
                "Joy1",
                "\"Current Joy\"",
                "\"John Cowan's Joy\"",
                "\"JoyJ (Joy in jvmm)\""
            ],
            "influenced_by": [
                "Scheme (programming language)|Scheme",
                "FP (programming language)|FP",
                "Forth (programming language)|Forth"
            ],
            "influenced": [
                "Factor (programming language)|Factor",
                "Cat (programming language)|Cat",
                "V",
                "Trith (programming language)|Trith"
            ]
        }
    },
    {
        "id": 289,
        "name": "Julia (programming language)",
        "url": "https://en.wikipedia.org/wiki/Julia_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Julia</b> is a high-level, high-performance, dynamic programming language. While it is a general purpose language and can be used to write any application, many of its features are well-suited for numerical analysis and computational science.</p><p>Distinctive aspects of Julia's design include a type system with parametric polymorphism in a dynamic programming language; with multiple dispatch as its core programming paradigm. Julia supports concurrent, (composable) parallel and distributed computing (with or without using MPI and/or the built-in corresponding to \"OpenMP-style\" threads), and direct calling of C and Fortran libraries without glue code. Julia uses a just-in-time (JIT) compiler that is referred to as \"just-ahead-of-time\" (JAOT) in the Julia community, as Julia compiles (always, on default settings) to machine code before running it.</p><p>Julia is garbage-collected, uses eager evaluation, and includes efficient libraries for floating-point calculations, linear algebra, random number generation, and regular expression matching. Many libraries are available, including some (e.g., for fast Fourier transforms) that were previously bundled with Julia and are now separate.</p><p>Several development tools support coding in Julia, such as integrated development environments (e.g. Juno, and Microsoft's Visual Studio Code, with extensions adding Julia support, both providing debugging support); with integrated tools, e.g. a linter, profiler (and flame graph support available for the built-in one), debugger, and the Rebugger.jl package \"supports repeated-execution debugging\" and more.</p>",
        "infobox": {
            "name": "Julia",
            "logo": "Julia Programming Language Logo.svg",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm: multiple dispatch (core)",
                "procedural programming|procedural",
                "functional programming|functional",
                "metaprogramming|meta",
                "multistaged programming|multistaged"
            ],
            "released": "2012",
            "designer": [
                "Jeff Bezanson",
                "Alan Edelman",
                "Stefan Karpinski",
                "Viral B. Shah"
            ],
            "developer": [
                "Jeff Bezanson",
                "Stefan Karpinski",
                "Viral B. Shah",
                "and other contributors"
            ],
            "latest release version": "1.4.2",
            "latest release date": "2020|05|23",
            "latest preview version": "1.5.0-rc1",
            "latest preview date": [
                "2020|06|26 / 1.6.0-DEV with daily updates (and 1.0.6",
                "and 1.5.0-rc2 being ''worked'' on)"
            ],
            "typing": [
                "dynamic programming language|Dynamic",
                "nominal type system|nominative",
                "parametric polymorphism|parametric",
                "optional typing|optional"
            ],
            "influenced by": "Flatlist * C (programming language)|C * Lisp (programming language)|Lisp * Lua (programming language)|Lua * Mathematica (strictly its Wolfram Language )\n* MATLAB * Perl * Python (programming language)|Python * R (programming language)|R * Ruby (programming language)|Ruby * Scheme (programming language)|Scheme endflatlist",
            "programming language": [
                "Julia",
                "C (programming language)|C",
                "C++",
                "Scheme (programming language)|Scheme",
                "LLVM"
            ],
            "platform": [
                "Tier&nbsp;1: x86-64",
                "IA-32",
                "CUDA<br />Tier&nbsp;2: ARM architecture|ARM (both 32- and 64-bit)<br /> Tier&nbsp;3: PowerPC<br />Also has web browser support (for JavaScript and WebAssembly) and works in Android (operating system)|Android."
            ],
            "operating system": [
                "Linux",
                "macOS",
                "Microsoft Windows|Windows and FreeBSD"
            ],
            "license": [
                "MIT License|MIT (core)",
                "General Public Licence|GPL v2; a makefile option omits GPL libraries"
            ],
            "file ext": ".jl",
            "website": "Official website|https://JuliaLang.org|name|=|JuliaLang.org"
        }
    },
    {
        "id": 290,
        "name": "Jython",
        "url": "https://en.wikipedia.org/wiki/Jython",
        "summary": "<p><b>Jython</b> is an implementation of the Python programming language designed to run on the Java platform. The implementation was formerly known as <b>JPython</b> until 1999.</p>",
        "infobox": {
            "name": "Jython",
            "logo": "Jython.png",
            "logo size": "100px",
            "logo alt": "Jython Logo",
            "released": "2001|01|17",
            "latest release version": "2.7.2",
            "latest release date": "2020|03|21",
            "operating system": "Cross-platform",
            "platform": "Java Virtual Machine",
            "programming language": "Python (programming language)|Python and Java (programming language)|Java",
            "genre": "Python Programming Language interpreter (computing)|Interpreter",
            "license": "Python Software Foundation License (for older releases see Jython#License terms|License terms)",
            "website": "Official URL"
        }
    },
    {
        "id": 291,
        "name": "KRL (programming language)",
        "url": "https://en.wikipedia.org/wiki/KRL_(programming_language)",
        "summary": "<p><b>KRL</b> is a knowledge representation language, developed by Daniel G. Bobrow and Terry Winograd while at Xerox PARC and Stanford University, respectively. It is a frame-based language.  </p>\n<blockquote>\n<p>KRL was an attempt to produce a language which was nice to read and write for the engineers who had to write programs in it, processed like human memory, so you could have realistic AI programs, had an underlying semantics which was firmly grounded like logic languages, all in one, all in one language. And I think it - again, in hindsight - it just bogged down under the weight of trying to satisfy all those things at once. \n</p>\n</blockquote>",
        "infobox": {
            "name": "KRL",
            "paradigm": "knowledge representation",
            "year": "1976",
            "developer": "Daniel G. Bobrow and Terry Winograd",
            "influenced": [
                "KM",
                "FRL (MIT)"
            ]
        }
    },
    {
        "id": 292,
        "name": "KRYPTON",
        "url": "https://en.wikipedia.org/wiki/Krypton_(programming_language)",
        "summary": "<p><b>Krypton</b> (styled <b>KRYPTON</b>) is a frame-based computer programming language. </p>",
        "infobox": "N/A"
    },
    {
        "id": 293,
        "name": "KUKA Robot Language",
        "url": "https://en.wikipedia.org/wiki/KUKA_Robot_Language",
        "summary": "<p>The <b>KUKA Robot Language</b>, also known as <b>KRL</b>, is a proprietary programming language similar to Pascal and used to control KUKA robots.</p>",
        "infobox": {
            "name": "KUKA Robot Language",
            "designer": "KUKA",
            "developer": "KUKA",
            "influenced_by": "Pascal (programming language)|Pascal"
        }
    },
    {
        "id": 294,
        "name": "K (programming language)",
        "url": "https://en.wikipedia.org/wiki/K_(programming_language)",
        "summary": "<p><b>K</b> is a proprietary array processing programming language developed by Arthur Whitney and commercialized by Kx Systems. The language serves as the foundation for kdb+, an in-memory, column-based database, and other related financial products. The language, originally developed in 1993, is a variant of APL and contains elements of Scheme. Advocates of the language emphasize its speed, facility in handling arrays, and expressive syntax.</p> \n\n",
        "infobox": {
            "name": "K",
            "paradigm": [
                "Array programming|array",
                "Functional programming|functional"
            ],
            "year": "1993",
            "designer": "Arthur Whitney (computer scientist)|Arthur Whitney ",
            "developer": "Kx Systems",
            "typing": [
                "Type system|dynamic",
                "Strong and weak typing|strong"
            ],
            "website": "kx.com",
            "influenced by": [
                "A+ (programming language)|A+",
                "APL (programming language)|APL",
                "Scheme (programming language)|Scheme"
            ],
            "influenced": "Q (programming language from Kx Systems)|Q"
        }
    },
    {
        "id": 295,
        "name": "Kaleidoscope (programming language)",
        "url": "https://en.wikipedia.org/wiki/Kaleidoscope_(programming_language)",
        "summary": "<p>The <b>Kaleidoscope programming language</b> is a constraint programming language embedding constraints into an imperative object-oriented language.  It adds keywords <i>always</i>, <i>once</i>, and <i>assert</i>..<i>during</i> (formerly <i>while</i>..<i>assert</i>) to make statements about relational invariants. Objects have constraint constructors, which are not methods, to enforce the meanings of user-defined datatypes. </p><p>There are three versions of Kaleidoscope which show an evolution from declarative to an increasingly imperative style. Differences between them are as follows.</p>",
        "infobox": "N/A"
    },
    {
        "id": 296,
        "name": "Karel (programming language)",
        "url": "https://en.wikipedia.org/wiki/Karel_(programming_language)",
        "summary": "<p><b>Karel</b> is an educational programming language for beginners, created by Richard E. Pattis in his book <i>Karel The Robot: A Gentle Introduction to the Art of Programming</i>. Pattis used the language in his courses at Stanford University, California. The language is named after Karel Čapek, a Czech writer who introduced the word <i>robot</i>.</p>",
        "infobox": {
            "name": "Karel the Robot",
            "screenshot": "File:NikiExample.jpg|220px",
            "paradigm": "procedural programming|procedural",
            "year": "1981",
            "designer": "Richard E. Pattis",
            "dialects": "Karel (programming language)#Variants and descendants|Some localized language variants",
            "influenced_by": "Pascal (programming language)|Pascal",
            "influenced": [
                "Karel++",
                "AgentSheets",
                "Guido van Robot"
            ]
        }
    },
    {
        "id": 297,
        "name": "Kent Recursive Calculator",
        "url": "https://en.wikipedia.org/wiki/Kent_Recursive_Calculator",
        "summary": "<p><b>KRC</b> (<b>Kent Recursive Calculator</b>) is a lazy functional language developed by David Turner from November 1979 to October 1981 based on SASL, with pattern matching, guards and ZF expressions (now more usually called list comprehensions). Two implementations of KRC were written: David Turner's original one in BCPL running on EMAS, and Simon J. Croft's later one in C under Unix, and KRC was the main language used for teaching functional programming at the University of Kent at Canterbury (UK) from 1982 to 1985.\n</p><p>The direct successor to KRC is Miranda, which includes a polymorphic type discipline based on that of Milner's ML.\n</p>",
        "infobox": {
            "name": "KRC",
            "paradigm": "Functional programming|functional",
            "year": "1981",
            "designer": "David Turner (computer scientist)|David Turner",
            "influenced_by": "SASL (programming language)|SASL",
            "influenced": "Miranda programming language|Miranda"
        }
    },
    {
        "id": 298,
        "name": "KiXtart",
        "url": "https://en.wikipedia.org/wiki/KiXtart",
        "summary": "<p><b>KiXtart</b> is a closed source free-format scripting language for Windows. It is described as a logon script processor and enhanced batch scripting language by the official website. Its name is a portmanteau of \"kick start\". </p>",
        "infobox": {
            "name": "KiXtart",
            "developer": "Ruud van Velsen",
            "released": "1991",
            "latest_release_version": "4.67",
            "latest_release_date": "Release date and age|2016|10|10",
            "operating_system": "Microsoft Windows",
            "genre": "Scripting language Automation",
            "license": "Closed source Careware",
            "website": "[http://www.kixtart.org/ KiXtart.org]"
        }
    },
    {
        "id": 299,
        "name": "Kivy (framework)",
        "url": "https://en.wikipedia.org/wiki/Kivy_(framework)",
        "summary": "<p><b>Kivy</b> is a free and open source Python library for developing mobile apps and other multitouch application software with a natural user interface (NUI). It is distributed under the terms of the MIT License, and can run on Android, iOS, GNU/Linux, OS X, and Windows. </p><p>Kivy is the main framework developed by the Kivy organization, alongside Python for Android, Kivy iOS, and several other libraries meant to be used on all platforms. In 2012, Kivy got a $5000 grant from the Python Software Foundation for porting it to Python 3.3. Kivy also supports the Raspberry Pi which was funded through Bountysource.</p><p>The framework contains all the elements for building an application such as:\n</p>\n<ul><li>extensive input support for mouse, keyboard, TUIO, and OS-specific multitouch events,</li>\n<li>a graphic library using only OpenGL ES 2, and based on Vertex Buffer Object and shaders,</li>\n<li>a wide range of widgets that support multitouch,</li>\n<li>an intermediate language (Kv) used to easily design custom widgets.</li></ul><p>Kivy is the evolution of the PyMT project, and is recommended for new projects.</p>",
        "infobox": {
            "name": "Kivy",
            "screenshot": "Kivy showcase screenshot.jpg",
            "screenshot size": "200px",
            "screenshot alt": "The Kivy Showcase example",
            "caption": "The Kivy Showcase example",
            "developer": "Kivy organization",
            "released": "2011|02|01",
            "status": "Active",
            "programming language": [
                "Python (programming language)|Python",
                "Cython"
            ],
            "operating system": "Cross-platform",
            "genre": "Application framework",
            "license": "MIT License|MIT (Free software)",
            "website": "//kivy.org",
            "latest_release_version": "1.11.1",
            "latest_release_date": "df|=|yes|2019|06|21"
        }
    },
    {
        "id": 300,
        "name": "Klerer-May System",
        "url": "https://en.wikipedia.org/wiki/Klerer%E2%80%93May_System",
        "summary": "<p>The <b>Klerer–May System</b> is a programming language developed in the mid-1960s, oriented to numerical scientific programming, whose most notable feature is its two-dimensional syntax based on traditional mathematical notation. </p>\n\n<p>For input and output, the Klerer–May system used a Friden Flexowriter modified to allow half-line motions for subscripts and superscripts. The character set included digits, upper-case letters, subsets of 14 lower-case Latin letters and 18 Greek letters, arithmetic operators (<code>+</code> <code>−</code> <code>×</code> <code>/</code> <code>|</code>) and punctuation (<code>.</code> <code>,</code> <code>(</code> <code>)</code>), and eight special line-drawing characters (resembling  <code>╲</code> <code>╱</code> <code>⎜</code> <code>_</code> <code>⎨</code> <code>⎬</code> <code>˘</code> <code>⁔</code>) used to construct multi-line brackets and symbols for summation, products, roots, and for multi-line division or fractions.\nThe system was intended to be forgiving of input mistakes, and easy to learn; its reference manual was only two pages.</p><p>The system was developed by Melvin Klerer and Jack May at Columbia University's Hudson Laboratories in Dobbs Ferry, New York, for the Office of Naval Research, and ran on GE-200 series computers.</p>",
        "infobox": "N/A"
    },
    {
        "id": 301,
        "name": "Knowledge Interchange Format",
        "url": "https://en.wikipedia.org/wiki/Knowledge_Interchange_Format",
        "summary": "<p><b>Knowledge Interchange Format</b> (<b>KIF</b>) is a computer language designed to enable systems to share and re-use information from knowledge-based systems. KIF is similar to frame languages such as KL-One and LOOM but unlike such language its primary role is not intended as a framework for the expression or use of knowledge but rather for the interchange of knowledge between systems. The designers of KIF likened it to PostScript. PostScript was not designed primarily as a language to store and manipulate documents but rather as an interchange format for systems and devices to share documents. In the same way KIF is meant to facilitate sharing of knowledge across different systems that use different languages, formalisms, platforms, etc. </p><p>KIF has a declarative semantics. It is meant to describe facts about the world rather than processes or procedures. Knowledge can be described as objects, functions, relations, and rules. It is a formal language, i.e., it can express arbitrary statements in first order logic and can support reasoners that can prove the consistency of a set of KIF statements. KIF also supports non-monotonic reasoning. KIF was  created by Michael Genesereth, Richard Fikes and others participating in the DARPA knowledge sharing Effort.</p><p>Although the original KIF group intended to submit to a formal standards body, that did not occur.  A later version called Common Logic has since been developed for submission to ISO and has been approved and published. A variant called SUO-KIF is the language in which the Suggested Upper Merged Ontology is written.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 302,
        "name": "Kodu Game Lab",
        "url": "https://en.wikipedia.org/wiki/Kodu_Game_Lab",
        "summary": "<p><b>Kodu</b>, originally named <i>Boku</i>, is a programming integrated development environment (IDE) by Microsoft's FUSE Labs. It runs on Xbox 360 and Microsoft Windows XP, Windows Vista, Windows 7, Windows 8 and Windows 10. It was released on the Xbox Live Marketplace on June 30, 2009. A Windows version is available to the general public for download from Microsoft's FUSE web portal.</p> \n\n",
        "infobox": {
            "name": "Kodu",
            "developer": "Microsoft Research",
            "released": "2009|6|30",
            "operating system": "Microsoft Windows|Windows",
            "genre": "Visual programming",
            "website": "kodugamelab.com"
        }
    },
    {
        "id": 303,
        "name": "Kojo (programming language)",
        "url": "https://en.wikipedia.org/wiki/Kojo_(learning_environment)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Kojo</b> is a programming language and integrated development environment (IDE) for computer programming and learning. It has many different features that enable playing, exploring, creating, and learning in the areas of computer programming, mental skills, (interactive) math, graphics, art, music, science, animation, games, and electronics. Kojo draws ideas from the programming languages Logo and Processing.</p><p>Kojo is open-source software. It was created,  and is actively developed, by Lalit Pant, a computer programmer and teacher living in Dehradun, India. Kojo provides domain-specific languages (DSLs) for its different areas of learning, and as such can be considered an educational programming language.\n</p><p>Kojo is written in, and its approach is based on, the programming language Scala, where users begin with a simple subset of the language and progress in steps. Its graphical user interface is based on Java Swing; a former version was based on the Java NetBeans platform.\n</p><p>Lalit chose Scala as the underlying language for Kojo because of its low barrier to entry and potential power.</p><p>Kojo has been used in schools and classes around the world. Some of these include:\n</p>\n<ul><li>Himjyoti School, Dehradun, India.</li>\n<li>Rishi Valley School, Madanapalle, India.</li>\n<li>Cardinal Forest Elementary School, Springfield, Virginia, USA.</li>\n<li>Diablo Valley College, Pleasant Hill, California, USA.</li>\n<li>Lady's Catholic High School, Preston, England.</li>\n<li>A Swedish 4th grade class consisting of 10-year-old children. Kojo has been featured by Dagens Nyheter (DN) and Computer Sweden as a result of the work done by this class.</li>\n<li>Events like Silicon Valley Code Camp, CoderDojo, Hack The Future, and Meetups.</li></ul><p>The development of Kojo is partly sponsored by Lightbend, formerly TypeSafe, and Lund University, Computer Science Department, where Kojo is used to introduce children and teachers to computer programming. Professor Björn Regnell of Lund University has an informative presentation on the subject. Professor Regnell writes, in translation: \"<i>Kojo is the best tool, with a low barrier of entry, I have seen for making real text based programming available for children, that is also  usable all the way up to university level</i>\".</p>",
        "infobox": {
            "name": "Kojo",
            "logo": "File:Kojo Logo with overlapping pentagons.png",
            "caption": "Example Kojo output",
            "paradigm": [
                "Object-oriented programming|object-oriented",
                "Functional programming|functional"
            ],
            "year": "2010",
            "designers": "Lalit Pant",
            "latest release version": "2.9.02",
            "latest release date": "2020|05|05",
            "typing": "Strong and weak typing|strong",
            "influenced by": [
                "Logo (programming language)|Logo",
                "Processing (programming language)|Processing",
                "The Geometer's Sketchpad"
            ],
            "platform": "x86",
            "operating system": [
                "Cross-platform: Linux",
                "macOS",
                "Microsoft Windows|Windows"
            ],
            "license": "GPL",
            "website": "www.kogics.net/kojo",
            "wikibooks": "Kojo",
            "file ext": [
                ".scala",
                ".kojo"
            ]
        }
    },
    {
        "id": 304,
        "name": "Korn shell",
        "url": "https://en.wikipedia.org/wiki/KornShell",
        "summary": "<p><b>KornShell</b> (<code><b>ksh</b></code>) is a Unix shell which was developed by David Korn at Bell Labs in the early 1980s and announced at USENIX on July 14, 1983.  The initial development was based on Bourne shell source code.  Other early contributors were Bell Labs developers Mike Veach and Pat Sullivan, who wrote the Emacs and vi-style line editing modes' code, respectively. KornShell is backward-compatible with the Bourne shell and includes many features of the C shell, inspired by the requests of Bell Labs users. </p>",
        "infobox": {
            "name": "KornShell",
            "author": "David Korn (computer scientist)|David Korn",
            "released": "1983",
            "latest_release_version": "u+",
            "latest_release_date": "release date and age|2012|08|01",
            "programming language": "C (programming language)|C",
            "operating system": "Unix",
            "language": "English",
            "genre": "Unix shell",
            "license": "plainlist|\n*'''AT&T KornShell''': Eclipse Public License|ref| name=\"ksh93epl\"|Cite web |url=https://about.att.com/error.html |title=Archived copy |access-date=2018-12-10 |archive-url=https://web.archive.org/web/20181114180733/http://about.att.com/error.html |archive-date=2018-11-14 |url-status=dead |</ref>|\n*'''pdksh''': public domain software|Public domain with some ISC License|ISC-like code|ref| name=\"pdksh_LEGAL\"|cite web |url=http://www.cs.mun.ca/~michael/pdksh/LEGAL |title=Archived copy |accessdate=2010-06-10 |url-status=dead |archiveurl=https://web.archive.org/web/20120206143309/http://www.cs.mun.ca/~michael/pdksh/LEGAL |archivedate=2012-02-06 |</ref>|\n*'''mksh''': MirOS Licence|ref| name=\"mkshlicense\"|cite web|url=https://www.mirbsd.org/mksh.htm|title=MirBSD Korn Shell|website=Mirbsd.org|accessdate=10 December 2018|</ref>|\n*'''dtksh''': Eclipse Public License with some LGPL *'''pdksh''': public domain software|Public domain with some ISC License|ISC-like code *'''mksh''': MirOS Licence *'''dtksh''': Eclipse Public License with some LGPL",
            "website": "url|http://www.kornshell.org/",
            "repo": "url|https://github.com/att/ast"
        }
    },
    {
        "id": 305,
        "name": "Kotlin (programming language)",
        "url": "https://en.wikipedia.org/wiki/Kotlin_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Kotlin</b> (<span></span>) is a cross-platform, statically typed, general-purpose programming language with type inference. Kotlin is designed to interoperate fully with Java, and the JVM version of its standard library depends on the Java Class Library, but type inference allows its syntax to be more concise. Kotlin mainly targets the JVM, but also compiles to JavaScript or native code (via LLVM). Language development costs are borne by JetBrains, while the Kotlin Foundation protects the Kotlin trademark.</p><p>On 7 May 2019, Google announced that the Kotlin programming language is now its preferred language for Android app developers.  Since the release of Android Studio 3.0 in October 2017, Kotlin has been included as an alternative to the standard Java compiler. The Android Kotlin compiler targets Java 6 by default, but lets the programmer choose between Java 8 to 13, for optimization.</p>",
        "infobox": {
            "name": "Kotlin",
            "logo": "Kotlin-logo.svg",
            "paradigm": "Multi-paradigm programming language|Multi-paradigm",
            "released": "2011",
            "designer": "JetBrains",
            "developer": "JetBrains",
            "latest release version": "1.3.72",
            "latest release date": "2020|04|15",
            "typing": [
                "Type inference|Inferred",
                "static typing|static",
                "strong typing|strong"
            ],
            "influenced by": "Hlist|C Sharp (programming language)|C#|Eiffel (programming language)|Eiffel|Gosu (programming language)|Gosu|Groovy (programming language)|Groovy|Java (programming language)|Java|ML (programming language)|ML|Python (programming language)|Python|Scala (programming language)|Scala|Swift (programming language)|Swift",
            "platform": [
                "Java virtual machine|JVM",
                "JavaScript",
                "LLVM"
            ],
            "operating system": "Cross-platform software|Cross-platform",
            "license": "Apache License 2.0",
            "file_ext": "Unbulleted list|.kt|.kts|.ktm",
            "website": "official URL"
        }
    },
    {
        "id": 306,
        "name": "LANSA (development environment)",
        "url": "https://en.wikipedia.org/wiki/LANSA_(development_environment)",
        "summary": "<p><b>LANSA</b> is an integrated development environment (IDE) for building desktop, web and mobile software applications that can be deployed to Cloud, Windows, Linux and IBM i server platforms. </p><p>The LANSA development environment includes:\n</p>\n<ul><li>High-level programming language</li>\n<li>Business rules and data definitions metadata repository</li>\n<li>Data management services</li>\n<li>Application framework</li>\n<li>Integrated development environment (IDE)</li></ul>",
        "infobox": "N/A"
    },
    {
        "id": 307,
        "name": "LINC 4GL",
        "url": "https://en.wikipedia.org/wiki/LINC_4GL",
        "summary": "<p> <b>LINC</b> (\"Logic and Information Network Compiler\") is a fourth-generation programming language, used mostly on Unisys computer systems.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 308,
        "name": "LINQ",
        "url": "https://en.wikipedia.org/wiki/Language_Integrated_Query",
        "summary": "<p><b>Language Integrated Query</b> (<b>LINQ</b>, pronounced \"link\") is a Microsoft .NET Framework component that adds native data querying capabilities to .NET languages, originally released as a major part of .NET Framework 3.5 in 2007. </p><p>LINQ extends the language by the addition of query expressions, which are akin to SQL statements, and can be used to conveniently extract and process data from arrays, enumerable classes, XML documents, relational databases, and third-party data sources. Other uses, which utilize query expressions as a general framework for readably composing arbitrary computations, include the construction of event handlers or monadic parsers. It also defines a set of method names (called <i>standard query operators</i>, or <i>standard sequence operators</i>), along with translation rules used by the compiler to translate query syntax expressions into expressions using fluent-style (called method syntax by Microsoft) with these method names, lambda expressions and anonymous types. Many of the concepts that LINQ introduced were originally tested in Microsoft's Cω research project. \n</p><p>Ports of LINQ exist for PHP (PHPLinq), JavaScript (linq.js), TypeScript (linq.ts), and ActionScript (ActionLinq), although none are strictly equivalent to LINQ in the .NET inspired languages C#, F# and VB.NET (where it is a part of the language, not an external library, and where it often addresses a wider range of needs).</p>",
        "infobox": {
            "name": "Language Integrated Query",
            "designer": "Microsoft Corporation",
            "developer": "Microsoft Corporation",
            "turing-complete": "No",
            "typing": "Strongly typed",
            "implementations": [
                "List of CLI languages|.NET languages (C Sharp (programming language)|C#",
                "F Sharp (programming language)|F#",
                "VB.NET)"
            ],
            "influenced_by": [
                "SQL",
                "Haskell (programming language)|Haskell"
            ]
        }
    },
    {
        "id": 309,
        "name": "LIS (programming language)",
        "url": "https://en.wikipedia.org/wiki/LIS_(programming_language)",
        "summary": "<p><b>LIS</b> (Language d'Implementation de Systèmes) was a system implementation programming language designed by Jean Ichbiah, who later designed Ada. </p><p>LIS was used to implement the compiler for the Ada-0 subset of Ada at Karlsruhe on the BS2000 Siemens operating system. Later on the Karlsruhe Ada compilation system got rewritten in Ada-0 itself, which was easy, because LIS and Ada-0 are very close.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 310,
        "name": "LPC (programming language)",
        "url": "https://en.wikipedia.org/wiki/LPMud",
        "summary": "<p><b>LPMud</b>, abbreviated <b>LP</b>, is a family of MUD server software.  Its first instance, the original LPMud game driver, was developed in 1989 by <b>L</b>ars <b>P</b>ensjö (hence the <b>LP</b> in LPMud).  LPMud was innovative in its separation of the MUD infrastructure into a virtual machine (known as the <b>driver</b>) and a development framework written in the LPC programming language (known as the <b>mudlib</b>).</p>",
        "infobox": "N/A"
    },
    {
        "id": 311,
        "name": "LSE (programming language)",
        "url": "https://en.wikipedia.org/wiki/LSE_(programming_language)",
        "summary": "<p><b>LSE</b> (French: <i lang=\"fr\">Langage symbolique d'enseignement</i>) is a programming language developed at Supélec and Télémécanique from the late 1960s to the mid 1970s.It is similar to BASIC, except with French-language instead of English-language keywords. It was derived from an earlier language called <i>LSD</i>, also developed at Supélec. It is most commonly said to be an acronym for <i>Langage Symbolique d'Enseignement</i> (Symbolic Teaching Language), but other expansions are also known (e.g. <i>Langage de Sup-Élec</i>, or the more cynical <i>Langage Sans Espoir</i> (hopeless language)). </p><p>It originally flourished due to support from the French Ministry of National Education, but declined as the ministry lost interest. It went through a number of revisions; earlier versions of LSE lacked full support for structured programming, which later version added, along with exception handling.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 312,
        "name": "LYaPAS",
        "url": "https://en.wikipedia.org/wiki/LYaPAS",
        "summary": "<p><b>Logical Language for the Representation of Synthesis Algorithms</b> (<b>LYaPAS</b>, Russian: <b>ЛЯПАС</b>) is a programming language created in the Soviet Union in 1964, by Arkady D.Zakrevskij of the <i>Laboratory of System Programming and Logical Synthesis</i>, of the <i>Academy of Sciences of the Byelorussian SSR</i>, since renamed the <i>National Academy of Sciences of Belarus</i>.</p><p>LYaPAS is an extension to the programming language APL, and was initially designed especially for non-numeric programming for the Soviet designed and built line of mainframe computers named Ural-1. LYaPAS uses octal numbers. </p><p>A further refinement of LYaPAS is LYaPAS-M.\n</p>",
        "infobox": {
            "name": "LYaPAS",
            "paradigms": [
                "Array programming|Array",
                "Functional programming|functional",
                "Structured programming|structured",
                "Modular programming|modular"
            ],
            "family": "APL (programming language)|APL",
            "designer": "Arkady D.Zakrevskij",
            "released": "1964",
            "typing": "Type system|Dynamic",
            "platform": "Ural (computer)|Ural-1 mainframe computer",
            "influenced by": "APL (programming language)|APL"
        }
    },
    {
        "id": 313,
        "name": "LabVIEW",
        "url": "https://en.wikipedia.org/wiki/LabVIEW",
        "summary": "<p><b>Laboratory Virtual Instrument Engineering Workbench</b> (<b>LabVIEW</b>) is a system-design platform and development environment for a visual programming language from National Instruments. </p><p>The graphical language is named \"G\"; not to be confused with G-code. Originally released for the Apple Macintosh in 1986, LabVIEW is commonly used for data acquisition, instrument control, and industrial automation on a variety of operating systems (OSs), including Microsoft Windows, various versions of Unix, Linux, and macOS.\n</p><p>The latest versions of LabVIEW are LabVIEW 2019 SP1 and LabVIEW NXG 4.0, released in November 2019. NI released the free for non-commercial use LabVIEW and LabVIEW NXG Community editions on April 28th, 2020.</p>\n\n\n",
        "infobox": {
            "name": "LabVIEW",
            "logo": "Image:LabVIEW_Logo.jpg|right|300px|LabVIEW logo.",
            "developer": "National Instruments",
            "released": "1986",
            "latest release version": "LabVIEW NXG 4.0\nLabVIEW 2019 SP1",
            "latest release date": "2019|11",
            "operating system": [
                "Cross-platform: Microsoft Windows|Windows",
                "macOS",
                "Linux"
            ],
            "genre": [
                "Data acquisition",
                "instrument control",
                "test automation",
                "analysis and signal processing",
                "Industrial control system|industrial control",
                "embedded system design"
            ],
            "license": "Proprietary software|Proprietary",
            "website": "https://www.ni.com/labview",
            "programming language": [
                "C",
                "C++",
                ".NET"
            ]
        }
    },
    {
        "id": 314,
        "name": "Ladder logic",
        "url": "https://en.wikipedia.org/wiki/Ladder_logic",
        "summary": "<p><b>Ladder logic</b> was originally a written method to document the design and construction of relay racks as used in manufacturing and process control. Each device in the relay rack would be represented by a symbol on the ladder diagram with connections between those devices shown. In addition, other items external to the relay rack such as pumps, heaters, and so forth would also be shown on the ladder diagram. </p><p>Ladder logic has evolved into a programming language that represents a program by a graphical diagram based on the circuit diagrams of relay logic hardware. Ladder logic is used to develop software for programmable logic controllers (PLCs) used in industrial control applications. The name is based on the observation that programs in this language resemble ladders, with two vertical rails and a series of horizontal rungs between them. While ladder diagrams were once the only available notation for recording programmable controller programs, today other forms are standardized in IEC 61131-3 (For example, as an alternative to the graphical ladder logic form, there is also a more assembly language like format called Instruction list within the  IEC 61131-3 standard.).\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 315,
        "name": "Language H",
        "url": "https://en.wikipedia.org/wiki/Language_H",
        "summary": "<p><b>Language H</b> is a proprietary, procedural programming language created by NCR based on COBOL.  The first compiler was developed in August 1962 to run on the National-Elliott 405M and produce object code for the National-Elliott 803B.  It is believed that the \"H\" stands for John C Harwell.</p>",
        "infobox": {
            "name": "Language H",
            "paradigm": "Procedural_programming|procedural",
            "year": "1962",
            "influenced_by": "COBOL"
        }
    },
    {
        "id": 316,
        "name": "Language for Instruction Set Architecture",
        "url": "https://en.wikipedia.org/wiki/LISA_(Language_for_Instruction_Set_Architecture)",
        "summary": "<p><b>LISA</b> (Language for Instruction Set Architectures) is a language to describe the instruction set architecture of a processor. LISA captures the information required to generate software tools (compiler, assembler, instruction set simulator, ...) and implementation hardware (in VHDL or Verilog) of a given processor. </p><p>LISA has been used to re-implement the hardware of existing processor cores, keeping the binary compatibility with the legacy version, as all software tools did already exist and legacy compiled software images could be executed on the newly created hardware. Another application has been to generate the ISS (instruction set simulator) for RISC processors such the ARM architecture ISSes.\n</p><p><b>LISA</b> is not focused on the modeling of other on-chip components around the processor core itself, such as peripherals, hardware accelerators, buses and memories; Other languages such as SystemC can be used for these.\n</p><p>The language has not been yet standardised by IEEE or ISO and is currently owned by RWTH Aachen University, in Germany.\n</p>",
        "infobox": {
            "name": "LISA",
            "year": [
                "1997",
                "last revised 2007"
            ],
            "designer": [
                "Vojin Zivojnovic",
                "Stefan Pees",
                "version 1.0"
            ],
            "dialects": [
                "LISA 2.0",
                "LISA+"
            ],
            "website": "http://www.ice.rwth-aachen.de/research/tools-projects/lisa/lisa"
        }
    },
    {
        "id": 317,
        "name": "Lasso (programming language)",
        "url": "https://en.wikipedia.org/wiki/Lasso_(programming_language)",
        "summary": "<p><b>Lasso</b> is an application server and server management interface used to develop internet applications and is a general-purpose, high-level programming language. Originally a web datasource connection tool, for Filemaker and later included in Apple Computer's FileMaker 4.0 and Claris Homepage as CDML, it has since evolved into a complex language used to develop and serve large-scale internet applications and web pages. </p><p>Lasso includes a simple template system allowing code to control generation of HTML and other content types. Lasso is object-oriented and every value is an object. It also supports procedural programming through <i>unbound</i> methods. The language uses traits and multiple dispatch extensively.\n</p><p>Lasso has a dynamic type system, where objects can be loaded and augmented at runtime, automatic memory management, a comprehensive standard library, and three compiling methodologies: dynamic (comparable to PHP-Python), just-in-time compilation (comparable to Java or .NET Framework), and pre-compiled (comparable to C). Lasso also supports Query Expressions, allowing elements within arrays and other types of sequences to be iterated, filtered, and manipulated using a natural language syntax similar to SQL.\nLasso includes full Unicode character support in the standard string object, allowing it to serve and support multi-byte characters such as Japanese and Swedish, and supports transparent UTF-8 conversion when writing string data to the network or file system.\n</p><p>Lasso is often used as a scripting language, and also used in a wide range of non-scripting contexts. Lasso code can be packaged into standalone executable programs called \"LassoApps\", in which folder structures are compiled into single files.</p><p>The Lasso Server application server runs as a system service and receives requests from the web server through FastCGI. It then hands the request off to the appropriate Lasso Instance, which formulates the response. Multiple individual instances are supported, allowing one server to handle multiple sites, each as separate processes. The server uses a high performance IO-based green threading system designed for multi-core systems.\n</p><p>Lasso can be compared to the server-side scripting languages PHP and Python, ColdFusion, Ruby, etc.</p><p>Free for development, Lasso allows partial access to its source code, allowing developers to add or change major components of the language (for example, Ke Carlton's DS implementation of the Lasso Inline). Licensing comes in both SAS and stand-alone versions.</p>",
        "infobox": {
            "name": "Lasso",
            "title": "Lasso",
            "logo": "File:LassoSoft and Lasso Logo.png|220px",
            "logo caption": "LassoSoft Inc. Logo",
            "released": "1995",
            "designer": "Kyle Jessup",
            "developer": "LassoSoft Inc.",
            "latest release version": "9.3.1",
            "latest release date": "2015|10|23",
            "frequently updated": "yes",
            "typing": [
                "Type system#Dynamic type-checking and runtime type information|Dynamic with constraints (strict-hybrid)",
                "Nominative type system|nominative",
                "Duck typing|duck (hybrid)"
            ],
            "implementations": [
                "Lasso 8",
                "Lasso 9"
            ],
            "influenced by": [
                "Dylan (programming language)|Dylan",
                "Smalltalk",
                "Scala (programming language)|Scala"
            ],
            "programming language": [
                "C (programming language)|C",
                "Lasso"
            ],
            "platform": "Cross-platform",
            "operating system": [
                "(OS X",
                "Microsoft Windows|Windows",
                "Linux)"
            ],
            "license": "Proprietary software|Proprietary",
            "file ext": [
                ".lasso",
                ".LassoApp"
            ],
            "website": "www.lassosoft.com",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: Structured programming|structured Object-oriented programming|object-oriented (Multiple dispatch|multi-dis),\nImperative programming|imperative: Procedural programming|procedural",
                "\nConcurrent computing|concurrent",
                " \nExpression-oriented programming language|exp-oriented,\nMetaprogramming|Meta: Reflection (computer programming)|reflective"
            ]
        }
    },
    {
        "id": 318,
        "name": "Lava (programming language)",
        "url": "https://en.wikipedia.org/wiki/Lava_(programming_language)",
        "summary": "<p><b>Lava</b> is an experimental, visual object-oriented, interpreter-based programming language with an associated programming environment (Lava Programming Environment or <b>LavaPE</b>) that uses structure editors instead of text editors. Only comments, constants, and new identifiers may be entered as text. </p><p><i>Declarations</i> are represented in LavaPE as tree structures whose subtrees may be collapsed or expanded. The properties of the declared Lava entities can be edited through pop-up dialogs.\n</p><p>Although <i>executable code</i> has a traditional text representation in LavaPE, it can be edited only as complete syntactic units, rather than character by character. If you insert a new syntactic construct, it will typically contain \"placeholders\" (syntactic variables) that can then be replaced by concrete constructs; the latter may in turn contain syntactic variables, etc. LavaPE provides a tool button for every type of syntactic construct, and a button is enabled only if it is syntactically correct to insert the associated construct at the selected place.\n</p><p>Further characteristic properties of Lava and LavaPE include the following:\n</p>\n<ul><li>It provides strict syntactic separation of interface (public) and implementation (private) sections of a Lava class.</li>\n<li>It distinguishes variable \"state objects\" from constant \"value objects\"; the latter cannot be modified any longer after creation/initialization.</li>\n<li>It supports \"virtual types\": type parameters of classes and packages (families of related classes). As a consequence, undermining of strong type checks by \"type casts\" is no longer required.</li>\n<li>It uses recursion and logical quantifiers instead of traditional loop constructs.</li>\n<li>It uses single assignment; i.e., a value can be assigned to a variable only once within the same branch of a function.</li>\n<li>It supports refactoring extensively via the LavaPE structure editors.</li>\n<li>It distinguishes between <i>constituents</i> (sub-objects) and <i>object acquaintances</i> (pointers to independent objects). Copying and deletion of complex objects is largely facilitated in this way.</li>\n<li>Since release 0.9.0, LavaPE completely prevents inadvertent access to uninitialized variables and null objects already at programming time by complete static initialization checks.</li></ul><p>Lava is open source software using the GPL license (see also Lava at the Free Software Foundation and at KDE-Apps.org). It currently runs on Microsoft Windows, Linux and Mac OS X platforms.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 319,
        "name": "Legoscript",
        "url": "https://en.wikipedia.org/wiki/Lego_Mindstorms",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Lego Mindstorms</b> is a hardware and software structure which is produced by Lego for the development of programmable robots based on Lego building blocks. Each version of the system includes an intelligent <i>brick</i> computer that controls the system, a set of modular sensors and motors, and Lego parts from the Technic line to create the mechanical systems.\n</p><p>Since creation, there have been four generations of the Mindstorms platform: the original Robotics Invention System, NXT, NXT 2.0, and EV3. With each platform release, the motor and sensor capabilities expanded. The latest system, Lego Mindstorms EV3, was released on 1 September 2013. Some robot competitions use this set, such as the FIRST Lego League and the World Robot Olympiad.\n</p>",
        "infobox": {
            "name": "Lego Mindstorms",
            "image": "File:Lego_Mindstorms_Sound_Finder.jpg",
            "caption": "Robot based on the NXT platform",
            "subject": "Robotics",
            "website": "https://www.lego.com/mindstorms"
        }
    },
    {
        "id": 320,
        "name": "LilyPond",
        "url": "https://en.wikipedia.org/wiki/LilyPond",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>LilyPond</b> is a computer program and file format for music engraving. One of LilyPond's major goals is to produce scores that are engraved with traditional layout rules, reflecting the era when scores were engraved by hand.\n</p><p>LilyPond is cross-platform, and is available for several common operating systems; released under the terms of the GNU General Public License, LilyPond is free software.\n</p><p>The MediaWiki Score extension allows editors to embed Lilypond notation in Wikipedia articles, and renders them into PNG images, audio, and MIDI files.\n</p>",
        "infobox": {
            "name": "LilyPond",
            "logo": "LilyPond-logo-with-music.png",
            "screenshot": "Fibonacci composition.svg",
            "operating system": [
                "Plainlist|\n*Windows 2000 and later\n*Mac OS X 10.4 and later\n*Linux\n*FreeBSD|ref|cite web|title=Downloads for LilyPond 2.18.2|url=http://lilypond.org/download.html|website=lilypond.org|accessdate=March 4",
                "2016|</ref>"
            ],
            "developer": [
                "David Kastrup",
                "Werner Lemberg",
                "Han-Wen Nienhuys",
                "Jan Nieuwenhuizen",
                "Carl Sorensen",
                "Janek Warchoł",
                "no wrap|et al."
            ],
            "released": "start date and age|1996",
            "license": "GPLv3",
            "programming language": [
                "C++",
                "Scheme (programming language)|Scheme",
                "Metafont",
                "PostScript",
                "Python (programming language)|Python"
            ],
            "website": "http://lilypond.org",
            "status": "Active",
            "size": "20–100 MB",
            "language": [
                "English",
                "Catalan",
                "Dutch",
                "French",
                "German",
                "Hungarian",
                "Italian",
                "Japanese",
                "Spanish"
            ],
            "standard": [
                "Encapsulated PostScript|EPS",
                "Musical Instrument Digital Interface|MIDI",
                "MusicXML",
                "Portable Document Format|PDF",
                "PostScript|PS",
                "Scalable Vector Graphics|SVG"
            ],
            "genre": [
                "Music software",
                "scorewriter"
            ]
        }
    },
    {
        "id": 321,
        "name": "Limbo (programming language)",
        "url": "https://en.wikipedia.org/wiki/Limbo_(programming_language)",
        "summary": "<p><b>Limbo</b> is a programming language for writing distributed systems and is the language used to write applications for the Inferno operating system. It was designed at Bell Labs by Sean Dorward, Phil Winterbottom, and Rob Pike. </p><p>The Limbo compiler generates architecture-independent object code which is then interpreted by the <b>Dis</b> virtual machine or compiled just before runtime to improve performance. Therefore all Limbo applications are completely portable across all Inferno platforms.\n</p><p>Limbo's approach to concurrency was inspired by Hoare's communicating sequential processes (CSP), as implemented and amended in Pike's earlier Newsqueak language and Winterbottom's Alef.\n</p>",
        "infobox": {
            "name": "Limbo",
            "paradigm": "Concurrent computing|Concurrent",
            "year": "1995",
            "designer": [
                "Sean Dorward",
                "Phil Winterbottom",
                "Rob Pike"
            ],
            "developer": "Bell Labs / Vita Nuova Holdings",
            "typing": "Strongly-typed programming language|Strong",
            "implementations": "Dis virtual machine",
            "influenced_by": [
                "C (programming language)|C",
                "Pascal (programming language)|Pascal",
                "Communicating sequential processes|CSP",
                "Alef (programming language)|Alef",
                "Newsqueak"
            ],
            "influenced": [
                "Stackless Python",
                "Go (programming language)|Go",
                "Rust (programming language)|Rust"
            ],
            "operating_system": "Inferno (operating system)|Inferno",
            "license": "Open-source software|Open source",
            "website": "http://www.vitanuova.com/inferno/limbo.html"
        }
    },
    {
        "id": 322,
        "name": "Limnor",
        "url": "https://en.wikipedia.org/wiki/Limnor",
        "summary": "<p><b>Limnor</b> is a generic-purpose codeless and visual programming system. The aim is to enable users to create computer software without directly coding in a texture programming language.  It can be extended by software developers. The general idea of Limnor codeless programming is to add \"Actions\" to classes. </p>",
        "infobox": "N/A"
    },
    {
        "id": 323,
        "name": "Linden Scripting Language",
        "url": "https://en.wikipedia.org/wiki/Second_Life",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><i><b>Second Life</b></i> is an online virtual world, developed and owned by the San Francisco-based  firm Linden Lab and launched on June 23, 2003. It saw rapid growth for some years and in 2013 it had approximately one million regular users; growth stabilised and by the end of 2017 active user count had declined to \"between 800,000 and 900,000\". In many ways, <i>Second Life</i> is similar to massively multiplayer online role-playing games; nevertheless, Linden Lab is emphatic that their creation is not a game: \"There is no manufactured conflict, no set objective\".</p><p>The virtual world can be accessed freely via Linden Lab's own client software or via alternative third-party viewers. <i>Second Life</i> users, also called <i>residents</i>, create virtual representations of themselves, called <i>avatars</i>, and are able to interact with places, objects and other avatars. They can explore the world (known as the grid), meet other residents, socialize, participate in both individual and group activities, build, create, shop, and trade virtual property and services with one another.\n</p><p>The platform principally features 3D-based user-generated content. <i>Second Life</i> also has its own virtual currency, the Linden Dollar, which is exchangeable with real world currency.</p><p><i>Second Life</i> is intended for people aged 16 and over, with the exception of 13–15-year-old users, who are restricted to the <i>Second Life</i> region of a sponsoring institution (e.g., a school).</p>",
        "infobox": {
            "name": "Second Life Viewer",
            "logo": "Second Life logo.svg",
            "developer": "Linden Lab",
            "released": "2003|06|23",
            "latest_release_version": "6.3.4.532299",
            "latest_release_date": "2019|11|4",
            "latest preview version": "6.3.5.532739",
            "latest preview date": "2019|11|15",
            "engine": "Havok (physics engine)",
            "platform": "plainlist|\n* Windows\n* macOS\n* Linux (development paused)",
            "license": "Open-source software|Open-source"
        }
    },
    {
        "id": 324,
        "name": "Lingo (programming language)",
        "url": "https://en.wikipedia.org/wiki/Lingo_(programming_language)",
        "summary": "<p><b>Lingo</b> is a verbose object-oriented (OO) scripting language developed by John H. Thompson for use in Adobe Director (formerly Macromedia Director). Lingo is used to develop desktop application software, interactive kiosks, CD-ROMs and Adobe Shockwave content.</p><p>Lingo is the primary programming language on the Adobe Shockwave platform, which dominated the interactive multimedia product market during the 1990s. Various graphic adventure games were developed with Lingo during the 1990s, including The Journeyman Project, Total Distortion, Mia's Language Adventure, Mia's Science Adventure, and the Didi &amp; Ditto series. Hundreds of free online video games were developed using Lingo, and published on websites such as Miniclip and Shockwave.com. </p><p>Lingo can be used to build user interfaces, to manipulate raster graphics, vector graphics and 3D computer graphics, and other data processing tasks. Lingo supports specialized syntax for image processing and 3D object manipulation. 3D meshes can also be created on the fly using Lingo.</p>",
        "infobox": "N/A"
    },
    {
        "id": 325,
        "name": "Lisp (programming language)",
        "url": "https://en.wikipedia.org/wiki/Lisp_(programming_language)",
        "summary": "<p><b>Lisp</b> (historically <b>LISP</b>) is a family of programming languages with a long history and a distinctive, fully parenthesized prefix notation. Originally specified in 1958, Lisp is the second-oldest high-level programming language in widespread use today. Only Fortran is older, by one year. Lisp has changed since its early days, and many dialects have existed over its history. Today, the best-known general-purpose Lisp dialects are Racket, Common Lisp, Scheme and Clojure.\n</p><p>Lisp was originally created as a practical mathematical notation for computer programs, influenced by the notation of Alonzo Church's lambda calculus. It quickly became the favored programming language for artificial intelligence (AI) research. As one of the earliest programming languages, Lisp pioneered many ideas in computer science, including tree data structures, automatic storage management, dynamic typing, conditionals, higher-order functions, recursion, the self-hosting compiler, and the read–eval–print loop.</p><p>The name <i>LISP</i> derives from \"LISt Processor\". Linked lists are one of Lisp's major data structures, and Lisp source code is made of lists. Thus, Lisp programs can manipulate source code as a data structure, giving rise to the macro systems that allow programmers to create new syntax or new domain-specific languages embedded in Lisp.\n</p><p>The interchangeability of code and data gives Lisp its instantly recognizable syntax. All program code is written as <i>s-expressions</i>, or parenthesized lists. A function call or syntactic form is written as a list with the function or operator's name first, and the arguments following; for instance, a function <code class=\"mw-highlight mw-highlight-lang-lisp\" dir=\"ltr\"><span>f</span></code> that takes three arguments would be called as <code class=\"mw-highlight mw-highlight-lang-lisp\" dir=\"ltr\"><span>(</span><span>f</span> <span>arg1</span> <span>arg2</span> <span>arg3</span><span>)</span></code>.\n</p>",
        "infobox": {
            "name": "Lisp",
            "logo": "Lisplogo.png",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm: functional programming|functional",
                "procedural programming|procedural",
                "Reflection (computer programming)|reflective",
                "metaprogramming|meta"
            ],
            "released": "1958",
            "designer": "John McCarthy (computer scientist)|John McCarthy",
            "developer": [
                "Steve Russell (computer scientist)|Steve Russell",
                "Timothy P. Hart",
                "and Mike Levin"
            ],
            "turing-complete": "Yes",
            "typing": [
                "Dynamic typing|Dynamic",
                "Strong and weak typing|strong"
            ],
            "dialects": "startflatlist *Arc (programming language)|Arc\n*AutoLISP\n*Clojure\n*Common Lisp\n*Emacs Lisp\n*EuLisp\n*Franz Lisp\n*Hy\n*Interlisp\n*ISLISP\n*LeLisp \n*LFE (programming language)|LFE \n*Maclisp \n*MDL (programming language)|MDL \n*newLISP \n*NIL (programming language)|NIL \n*Picolisp \n*Portable Standard Lisp \n*Racket (programming language)|Racket \n*RPL (programming language)|RPL \n*Scheme (programming language)|Scheme \n*Cadence SKILL|SKILL \n*Spice Lisp \n*T (programming language)|T\n*Zetalisp endflatlist",
            "influenced by": "Information Processing Language|IPL",
            "influenced": "startflatlist *CLIPS \n*CLU (programming language)|CLU \n*COWSEL \n*Dylan (programming language)|Dylan \n*Elixir (programming language)|Elixir \n*Forth (programming language)|Forth \n*Haskell (programming language)|Haskell \n*Io (programming language)|Io \n*Ioke (programming language)|Ioke \n*JavaScript \n*Julia (programming language)|Julia *Logo (programming language)|Logo \n*Lua (programming language)|Lua \n*ML (programming language)|ML \n*Nim (programming language)|Nim \n*Nu (programming language)|Nu \n*OPS5 \n*Perl \n*POP-2/POP-11|11 \n*Python (programming language)|Python \n*R (programming language)|R \n*Rebol \n*Ruby (programming language)|Ruby \n*Scala (programming language)|Scala \n*Swift (programming language)|Swift\n*Smalltalk \n*Tcl \n*Wolfram Language endflatlist"
        }
    },
    {
        "id": 326,
        "name": "List of BASIC dialects",
        "Error": "List of BASIC dialects"
    },
    {
        "id": 327,
        "name": "List of BASIC dialects by platform",
        "Error": "List of BASIC dialects by platform"
    },
    {
        "id": 328,
        "name": "List of markup languages",
        "url": "https://en.wikipedia.org/wiki/List_of_markup_languages",
        "summary": "<p>This is a list of markup languages. This page directly lists markup languages that have not yet been assigned to more specific categories. However, many specific markup language are instead listed only under the narrower lists referenced below. </p>\n<ul><li>List of document markup languages -- This term is often used synonymously with \"markup language\", presumably because document can refer to any written or recorded representation.</li>\n<li>List of XML markup languages -- XML itself is properly a meta-language used to define other markup languages.</li>\n<li>List of general purpose markup languages</li>\n<li>List of content syndication markup languages</li>\n<li>List of lightweight markup languages</li>\n<li>List of user interface markup languages</li>\n<li>List of vector graphics markup languages</li>\n<li>Unclassified markup languages:\n<ul><li>BNML (Business Narrative Markup Language) [1]</li>\n<li>BPML (Business Process Modeling Language) [2]</li>\n<li>BulletML</li>\n<li>CFML (ColdFusion Markup Language)</li>\n<li>Emotion Markup Language</li>\n<li>FpML (Financial Product Markup Language)</li>\n<li>Fountain</li>\n<li>GolfML [3]</li>\n<li>InkML</li>\n<li>Meta Content Framework</li>\n<li>OBML (Opera Binary Markup Language)</li>\n<li>Parameter Value Language</li>\n<li>Serializations of RDF (Resource Description Framework) like RDF/XML and RDF/N3</li>\n<li>SMIL (Synchronized Multimedia Integration Language)</li>\n<li>SBML (Systems Biology Markup Language)</li>\n<li>SML (Spacecraft Markup Language)</li>\n<li>VoiceXML</li>\n<li>VHML (Virtual Human Markup Language)</li>\n<li>Wiki Markup Language</li>\n<li>XBEL (XML Bookmark Exchange Language) [4]</li>\n<li>XBL (eXtensible Bindings Language)</li>\n<li>XBRL (eXtensible Business Reporting Language)</li>\n<li>XMPP (Extensible Messaging and Presence Protocol)</li></ul></li></ul>",
        "infobox": "N/A"
    },
    {
        "id": 329,
        "name": "List of programming languages by type",
        "url": "https://en.wikipedia.org/wiki/List_of_programming_languages_by_type",
        "summary": "<p>This is a list of notable programming languages, grouped by type. </p><p>There is no overarching classification scheme for programming languages. Thus, in many cases, a language is listed under multiple headings.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 330,
        "name": "List of stylesheet languages",
        "url": "https://en.wikipedia.org/wiki/List_of_stylesheet_languages",
        "summary": "<p>The following is a list of style sheet languages. </p>",
        "infobox": "N/A"
    },
    {
        "id": 331,
        "name": "Lists of programming languages",
        "url": "https://en.wikipedia.org/wiki/Lists_of_programming_languages",
        "summary": "<p>There are thousands of programming languages. These are listed in various ways: </p>",
        "infobox": "N/A"
    },
    {
        "id": 332,
        "name": "Lite-C",
        "url": "https://en.wikipedia.org/wiki/Lite-C",
        "summary": "<p><b>Lite-C</b> is a programming language for multimedia applications and personal computer games, using a syntax subset of the C language with some elements of the C++ language. Its main difference to C is the native implementation of multimedia and computer game related objects like sounds, images, movies, GUI elements, 2D and 3D models, collision detection and rigid body physics. Lite-C executables are compiled instead of interpreted. Lite-C runs on 32-bit and 64-bit Windows XP or Vista operating systems. </p><p>Lite-C claims to allow very fast programming with a minimum of code, and easy access to non-programmers. For this, the developer provides a 25-lesson workshop that especially deals with the game and multimedia related objects of the language. \n</p><p>Lite-C supports the Windows API and the Component Object Model (COM); therefore OpenGL and DirectX programs can directly be written in lite-C. It has integrated the free A8 rendering engine.\n</p>",
        "infobox": {
            "name": "Lite-C",
            "released": "2007",
            "developer": [
                "Atari",
                "Inc"
            ],
            "latest release version": "8.45",
            "latest release date": "start date and age|2014|02|09",
            "operating system": [
                "Windows XP",
                "Vista",
                "7",
                "8"
            ],
            "license": "free",
            "website": "[http://www.3dgamestudio.de/litec.php www.3dgamestudio.de/litec.php]"
        }
    },
    {
        "id": 333,
        "name": "Lithe (programming language)",
        "url": "https://en.wikipedia.org/wiki/Lithe",
        "summary": "<p><b>Lithe</b> is an experimental programming language created in 1982 by David Sandberg at the University of Washington which allows the programmer to freely choose their own syntax. Lithe combines the ideas of syntax-directed translation and classes in a novel manner that results in a remarkably simple yet powerful language. </p>",
        "infobox": "N/A"
    },
    {
        "id": 334,
        "name": "Little Computer 3",
        "url": "https://en.wikipedia.org/wiki/Little_Computer_3",
        "summary": "<p><b>Little Computer 3</b>, or <b>LC-3</b>, is a type of computer educational programming language, an assembly language, which is a type of low-level programming language. </p><p>It features a relatively simple instruction set, but can be used to write moderately complex assembly programs, and is a theoretically viable target for a C compiler. The language is less complex than x86 assembly but has many features similar to those in more complex languages. These features make it useful for beginning instruction, so it is most often used to teach fundamentals of programming and computer architecture to computer science and computer engineering students.\n</p><p>The LC-3 was developed by Yale N. Patt at the University of Texas at Austin and Sanjay J. Patel at the University of Illinois at Urbana–Champaign. Their specification of the instruction set, the overall architecture of the LC-3, and a hardware implementation can be found in the second edition of their textbook. Courses based on the LC-3 and Patt and Patel's book are offered in many computer engineering and computer science departments.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 335,
        "name": "Little Implementation Language",
        "url": "https://en.wikipedia.org/wiki/Little_Implementation_Language",
        "summary": "<p><b>LIL</b>, the <b>Little Implementation Language</b>, was a system programming language during the early days of Unix history on PDP-11 machines. It was written by P. J. Plauger of Bell Labs. </p><p>LIL attempted to fill the gap between assemblers and machine-independent system implementation languages (such as the C programming language), by basically adding structured programming to the PDP-11 assembly language. LIL resembled PL360 with C-like flow control syntax.\n</p><p>The LIL compiler \"lc\" was part of Fifth Edition Unix (1974), but was dropped by Sixth Edition Unix (1975). Plauger left Bell Labs in the same year.\n</p><p>Plauger explains why LIL was abandoned in Bell Labs in favor of C: [1]\n</p>\n<dl><dd><i>... LIL is, however, a failure. Its stiffest competition at Bell Labs is the language C, which is higher level, and machine independent. Every time it looked like C was too expensive to use for a particular project, LIL was considered. But almost every time, it proved easier (and more rewarding) to improve C, or its runtime support, or the hardware, than to invest time in yet another language. ... A machine independent language is always superior -- even for writing machine dependent code (it's easier to find trained programmers) -- so long as the overhead can be endured. It is clear now that writing straightforward code and then measuring it is the formula for the best end product. At worst there will be 5-15 per cent overhead, which is seldom critical. Once system writers become mature enough to recognize this basic truth, they gravitate naturally toward machine independent SILs. ... it looks like the little implementation language is an idea whose time as come -- and gone.</i></dd></dl>",
        "infobox": "N/A"
    },
    {
        "id": 336,
        "name": "Little b (programming language)",
        "url": "https://en.wikipedia.org/wiki/Little_b_(programming_language)",
        "summary": "<p><b>Little b</b> is a domain-specific programming language, more specifically, a modeling language, designed to build modular mathematical models of biological systems.  It was designed and authored by Aneil Mallavarapu.  Little b is being developed in the Virtual Cell Program at Harvard Medical School, headed by mathematician Jeremy Gunawardena. </p><p>This language is based on Lisp and is meant to allow modular programming to model biological systems.  It will allow more flexibility to facilitate rapid change that is required to accurately capture complex biological systems.\n</p><p>The language draws on techniques from artificial intelligence and symbolic mathematics, and provides  syntactic conveniences derived from object-oriented languages.  The language was originally denoted with a lowercase b (distinguishing it from B, the predecessor to the widely used C programming language, but the name was eventually changed to \"little b\" to avoid confusion and to pay homage to Smalltalk, the first object-oriented programming language.\n</p>",
        "infobox": {
            "name": "Little b",
            "paradigm": "Functional programming|functional",
            "year": "2004",
            "designer": "Aneil Mallavarapu",
            "developer": "Harvard Medical School Department of Systems Biology",
            "latest_release_version": "1.6.0",
            "latest_release_date": "2008|09|06",
            "typing": [
                "Type system|dynamic",
                "Strong typing|strong"
            ],
            "implementations": [
                "Linux",
                "Mac OS X",
                "Microsoft Windows|Windows"
            ],
            "influenced_by": "Lisp (programming language)|Lisp",
            "website": "[https://web.archive.org/web/20051102195348/http://www.littleb.org/ www.littleb.org]"
        }
    },
    {
        "id": 337,
        "name": "LiveCode",
        "url": "https://en.wikipedia.org/wiki/LiveCode",
        "summary": "<p><b>LiveCode</b> (formerly Revolution and MetaCard) is a cross-platform rapid application development runtime system inspired by HyperCard. It features the <i>LiveCode Script</i> (formerly MetaTalk) programming language which belongs to the family of xTalk scripting languages like HyperCard's HyperTalk.</p><p>The environment was introduced in 2001.  The \"Revolution\" development system was based on the MetaCard engine technology which Runtime Revolution later acquired from MetaCard Corporation in 2003. The platform won the Macworld Annual Editor's Choice Award for \"Best Development Software\" in 2004.  \"Revolution\" was renamed \"LiveCode\" in the fall of 2010.  \"LiveCode\" is developed and sold by Runtime Revolution Ltd., based in Edinburgh, Scotland. In March, 2015, the company was renamed \"LiveCode Ltd.\", to unify the company name with the product. In April 2013 a free/open source version 'LiveCode Community Edition 6.0' was published after a successful crowdfunding campaign at Kickstarter. The code base was re-licensed and made available as free and open source software with a version in April 2013. </p><p>LiveCode runs on iOS, Android, OS X, Windows 95 through Windows 10, Raspberry Pi and several variations of Unix, including Linux, Solaris, and BSD. It can be used for mobile, desktop and server/CGI applications. The iOS (iPhone and iPad) version was released in December 2010. The first version to deploy to the Web was released in 2009. It is the most widely used HyperCard/HyperTalk clone, and the only one that runs on all major operating systems.\n</p><p>A developer release of v.8 was announced in New York on March 12, 2015. This major enhancement to the product includes a new, separate development language, known as \"LiveCode Builder\",  which is capable of creating new object classes called \"widgets\". In earlier versions, the set of object classes was fixed, and could be enhanced only via the use of ordinary procedural languages such as C. The new language, which runs in its own IDE, is a departure from the transitional x-talk paradigm in that it permits typing of variables. But the two environments are fully integrated, and apart from the ability to create new objects, development in LiveCode proceeds in the normal way, within the established IDE.\n</p><p>A second crowdfunding campaign to Bring HTML5 to LiveCode reached funding goals of nearly $400,000 USD on July 31, 2014. LiveCode developer release 8.0 DP4 (August 31, 2015) was the first to include a standalone deployment option to HTML5.\n</p>",
        "infobox": {
            "name": "LiveCode",
            "developer": "LiveCode (company)|LiveCode Ltd.",
            "released": "2001|07|11",
            "latest_release_version": "9.5.1",
            "latest_release_date": "2019|12|16",
            "latest preview version": "9.6.0DP4",
            "latest preview date": "2020|04|16",
            "operating_system": [
                "macOS",
                "Windows (operating system)|Windows",
                " Linux",
                "Unix",
                "Android (operating system)|Android",
                "iOS",
                "HTML5"
            ],
            "genre": "Programming language|Programming",
            "license": [
                "GPL",
                "Proprietary software|Proprietary"
            ],
            "website": "livecode.org Official URL"
        }
    },
    {
        "id": 338,
        "name": "LiveScript",
        "url": "https://en.wikipedia.org/wiki/LiveScript",
        "summary": "<p><b>LiveScript</b> is a functional programming language that compiles to JavaScript. It was created by Jeremy Ashkenas—the creator of CoffeeScript—along with Satoshi Muramaki, George Zahariev, and many others. For a brief period in the 1990s, <i>LiveScript</i> was the name of JavaScript.</p>",
        "infobox": {
            "name": "LiveScript",
            "paradigm": [
                "programming paradigm|multi-paradigm",
                "functional programming|functional",
                "object-oriented programming|object-oriented"
            ],
            "year": "start date and age|2011",
            "designer": [
                "Jeremy Ashkenas",
                "Satoshi Murakami",
                "George Zahariev"
            ],
            "developer": [
                "Jeremy Ashkenas",
                "Satoshi Murakami",
                "George Zahariev"
            ],
            "latest release version": "LiveScript 1.6.0",
            "latest release date": "start date and age|df|=|yes|2018|08|24",
            "typing": [
                "dynamic typing|dynamic",
                "weak typing|weak"
            ],
            "influenced by": [
                "JavaScript",
                "Haskell (programming language)|Haskell",
                "CoffeeScript",
                "F Sharp (programming language)|F#"
            ],
            "operating system": "Cross-platform",
            "license": "MIT License|MIT",
            "website": "url|livescript.net",
            "file ext": "<code>.ls</code>"
        }
    },
    {
        "id": 339,
        "name": "Logo (programming language)",
        "url": "https://en.wikipedia.org/wiki/Logo_(programming_language)",
        "summary": "<p><b>Logo</b> is an educational programming language, designed in 1967 by Wally Feurzeig, Seymour Papert, and Cynthia Solomon. <i>Logo</i> is not an acronym: the name was coined by Feurzeig while he was at Bolt, Beranek and Newman, and derives from the Greek <i>logos</i>, meaning <i>word</i> or <i>thought</i>. </p><p>A general-purpose language, Logo is widely known for its use of turtle graphics, in which commands for movement and drawing produced line or vector graphics, either on screen or with a small robot termed a turtle. The language was conceived to teach concepts of programming related to Lisp and only later to enable what Papert called \"body-syntonic reasoning\", where students could understand, predict, and reason about the turtle's motion by imagining what they would do if they were the turtle. There are substantial differences among the many dialects of Logo, and the situation is confused by the regular appearance of turtle graphics programs that are named Logo.\n</p><p>Logo is a multi-paradigm adaptation and dialect of Lisp, a functional programming language. There is no standard Logo, but UCBLogo has the best facilities for handling lists, files, I/O, and recursion in scripts, and can be used to teach all computer science concepts, as UC Berkeley lecturer Brian Harvey did in his <i>Computer Science Logo Style</i> trilogy.</p><p>Logo is usually an interpreted language, although compiled Logo dialects (such as Lhogho and Liogo) have been developed. Logo is not case-sensitive but retains the case used for formatting purposes.\n</p>",
        "infobox": {
            "name": "Logo",
            "logo": "Remi turtlegrafik.png",
            "logo caption": "Example Logo output",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Functional programming|functional",
                "Educational programming language|educational",
                "Procedural programming|procedural",
                "Reflection (computer science)|reflective"
            ],
            "family": "Lisp (programming language)|Lisp",
            "designers": [
                "Wally Feurzeig",
                "Seymour Papert",
                "Cynthia Solomon"
            ],
            "developer": [
                "BBN Technologies|Bolt",
                "Beranek and Newman"
            ],
            "released": "1967",
            "typing": "Dynamic typing|dynamic",
            "implementations": [
                "UCBLogo",
                "many others"
            ],
            "dialects": [
                "StarLogo",
                "NetLogo"
            ],
            "influenced": [
                "AgentSheets",
                "NetLogo",
                "Smalltalk",
                "Etoys (programming language)|Etoys",
                "Scratch (programming language)|Scratch",
                "KTurtle",
                "REBOL",
                "Boxer (programming environment)|Boxer"
            ],
            "influenced by": "Lisp (programming language)|Lisp"
        }
    },
    {
        "id": 340,
        "name": "Logtalk",
        "url": "https://en.wikipedia.org/wiki/Logtalk",
        "summary": "<p><b>Logtalk</b> is an object-oriented logic programming language that extends and leverages the Prolog language with a feature set suitable for programming in the large. It provides support for encapsulation and data hiding, separation of concerns and enhanced code reuse. Logtalk uses standard Prolog syntax with the addition of a few operators and directives. </p><p>The Logtalk language implementation is distributed under an open source license and can run using a Prolog implementation (compliant with official and de facto standards) as the back-end compiler.\n</p>",
        "infobox": {
            "name": "Logtalk",
            "paradigm": [
                "Logic programming",
                "object-oriented programming",
                "prototype-based programming"
            ],
            "year": "1998",
            "designer": "Paulo Moura",
            "latest release version": "3.33.0",
            "latest release date": "2019|12|03",
            "operating_system": "Cross-platform",
            "license": "Artistic License 2.0 (2.x) / Apache License 2.0 (3.01.x)",
            "influenced_by": [
                "Prolog",
                "Smalltalk",
                "Objective-C"
            ],
            "website": "//logtalk.org"
        }
    },
    {
        "id": 341,
        "name": "LotusScript",
        "url": "https://en.wikipedia.org/wiki/LotusScript",
        "summary": "<p><b>LotusScript</b> is an object oriented programming language used by Lotus Notes (since version 4.0) and other IBM Lotus Software products. </p><p>LotusScript is similar to Visual Basic.  Developers familiar with one can easily understand the syntax and structure of code in the other.  The major differences between the two are in their respective Integrated Development Environments and in the product-specific object classes provided in each language that are included.  VB includes a richer set of classes for UI manipulation, whereas LotusScript includes a richer set of application-specific classes for Lotus Notes, Lotus Word Pro and Lotus 1-2-3.  In the case of Lotus Notes, there are classes to work with Notes databases, documents (records) in those databases, etc. These classes can also be used as OLE Automation objects outside the Lotus Notes environment, from Visual Basic.\n</p><p>LotusScript also allows the definition of user-defined types and classes, although it is not possible to inherit from the product-specific classes. LotusScript programs can access Microsoft Office documents by using the OLE automation in libraries from MS Office.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 342,
        "name": "Lua (programming language)",
        "url": "https://en.wikipedia.org/wiki/Lua_(programming_language)",
        "summary": "<p><b>Lua</b> (<span></span> <i title=\"English pronunciation respelling\"><span>LOO</span>-ə</i>; from Portuguese: <i lang=\"pt\">lua</i> <span></span><span title=\"Representation in the International Phonetic Alphabet (IPA)\">[ˈlu.(w)ɐ]</span> meaning <i>moon</i>) is a lightweight, high-level, multi-paradigm programming language designed primarily for embedded use in applications. Lua is cross-platform, since the interpreter of compiled bytecode is written in ANSI C, and Lua has a relatively simple C API to embed it into applications.</p><p>Lua was originally designed in 1993 as a language for extending software applications to meet the increasing demand for customization at the time. It provided the basic facilities of most procedural programming languages, but more complicated or domain-specific features were not included; rather, it included mechanisms for extending the language, allowing programmers to implement such features. As Lua was intended to be a general embeddable extension language, the designers of Lua focused on improving its speed, portability, extensibility, and ease-of-use in development. </p>",
        "infobox": {
            "name": "Lua",
            "logo": "File:Lua-Logo.svg|128px",
            "paradigm": [
                "Multi-paradigm: scripting language|scripting",
                "imperative programming|imperative (procedural programming|procedural",
                "prototype-based programming|prototype-based",
                "object-oriented programming|object-oriented)",
                "functional programming|functional"
            ],
            "year": "df|=|yes|1993",
            "designer": "Roberto Ierusalimschy<br /> Waldemar Celes<br /> Luiz Henrique de Figueiredo",
            "latest_release_version": "5.4.0",
            "latest_release_date": "2020|6|29",
            "latest preview version": "5.4.0-rc6",
            "latest preview date": "2020|6|18",
            "typing": [
                "Dynamic typing|Dynamic",
                "Strong and weak typing|strong",
                "Duck typing|duck"
            ],
            "implementations": [
                "[//www.lua.org/download.html Lua]",
                "[//luajit.org/ LuaJIT]",
                "[//eliasdaler.github.io/luavela/ LuaVela]"
            ],
            "programming_language": "ANSI C",
            "dialects": [
                "[http://metalua.luaforge.net/ Metalua ]",
                "[http://idle.thomaslauer.com Idle]",
                "[https://www.nongnu.org/gsl-shell/ GSL Shell]",
                "[https://roblox.github.io/luau/ Luau]"
            ],
            "influenced_by": [
                "C++",
                "CLU (programming language)|CLU",
                "Modula-2|Modula",
                "Scheme (programming language)|Scheme",
                "SNOBOL"
            ],
            "influenced": [
                "GameMonkey Script|GameMonkey ",
                "Io (programming language)|Io ",
                "JavaScript",
                "Julia (programming language)|Julia ",
                "MiniD ",
                "Red (programming language)|Red",
                "Ring",
                "Ruby (programming language)|Ruby",
                "Squirrel (programming language)|Squirrel ",
                "MoonScript ",
                "C--"
            ],
            "operating_system": "Cross-platform",
            "license": "MIT License",
            "website": "//www.lua.org/",
            "file ext": ".lua"
        }
    },
    {
        "id": 343,
        "name": "Lucid (programming language)",
        "url": "https://en.wikipedia.org/wiki/Lucid_(programming_language)",
        "summary": "<p><b>Lucid</b> is a dataflow programming language designed to experiment with non-von Neumann programming models. It was designed by Bill Wadge and Ed Ashcroft and described in the 1985 book <i>Lucid, the Dataflow Programming Language</i>.</p><p>pLucid was the first interpreter for Lucid. </p>",
        "infobox": {
            "name": "Lucid",
            "paradigm": "Dataflow",
            "year": "1976",
            "designer": "Edward A. Ashcroft<br>William W. Wadge",
            "typing": "Typeless",
            "implementations": "pLucid",
            "dialects": [
                "GIPSY",
                "Granular Lucid"
            ],
            "influenced_by": "ISWIM",
            "influenced": [
                "SISAL",
                "PureData",
                "Lustre (programming language)|Lustre"
            ]
        }
    },
    {
        "id": 344,
        "name": "Lustre (programming language)",
        "url": "https://en.wikipedia.org/wiki/Lustre_(programming_language)",
        "summary": "<p><b>Lustre</b> is a formally defined, declarative, and synchronous dataflow programming language for programming reactive systems. It began as a research project in the early 1980s. A formal presentation of the language can be found in the 1991 Proceedings of the IEEE. In 1993 it progressed to practical, industrial use in a commercial product as the core language of the industrial environment SCADE, developed by Esterel Technologies. It is now used for critical control software in aircraft, helicopters, and nuclear power plants. </p>",
        "infobox": "N/A"
    },
    {
        "id": 345,
        "name": "Lynx (programming language)",
        "url": "https://en.wikipedia.org/wiki/Lynx_(programming_language)",
        "summary": "<p><b>Lynx</b> is a programming language for large distributed networks, using remote procedure calls. It was developed by the University of Wisconsin–Madison in 1984 for the Charlotte multicomputer operating system.  </p><p>In 1986 at the University of Rochester Lynx was ported to the Chrysalis operating system running on a BBN Butterfly multiprocessor.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 346,
        "name": "M2001",
        "url": "https://en.wikipedia.org/wiki/M2001",
        "summary": "<p><b>M2001</b> is a modular educational mathematical programming language for developing and presenting mathematical algorithms, from the modern discrete to the classical continuous mathematics. M2001 is built on a semantic framework that is based in category theory and has a syntax similar to that of Pascal or Modula-2. </p><p>It is designed purely for pedagogic use, so efficiency and ease of implementation have been far less important in its development than generality and range of application. It was created to play an important role in forming a formal algorithmic foundation for first-year college math students.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 347,
        "name": "M4 (computer language)",
        "url": "https://en.wikipedia.org/wiki/M4_(computer_language)",
        "summary": "<p><span></span> </p>\n<p><b>m4</b> is a general-purpose macro processor included in all UNIX-like operating systems, and is a component of the POSIX standard.\n</p><p>The language was designed by Brian Kernighan and Dennis Ritchie for the original versions of UNIX. It is an extension of an earlier macro processor <b>m3</b>, written by Ritchie for an unknown AP-3 minicomputer.</p><p>The macro preprocessor operates as a text-replacement tool. It is employed to re-use text templates, typically in computer programming applications, but also in text editing and text-processing applications. Most users require m4 as a dependency of GNU autoconf.\n</p>",
        "infobox": {
            "name": "m4",
            "paradigm": "macro (computer science)|macro",
            "year": "1977",
            "designer": [
                "Brian Kernighan",
                "Dennis Ritchie"
            ],
            "implementations": "GNU m4"
        }
    },
    {
        "id": 348,
        "name": "MAD (programming language)",
        "url": "https://en.wikipedia.org/wiki/MAD_(programming_language)",
        "summary": "<p><b>MAD</b> (<b>Michigan Algorithm Decoder</b>) is a programming language and compiler for the IBM 704 and later the IBM 709, IBM 7090, IBM 7040, UNIVAC 1107, UNIVAC 1108, Philco 210-211, and eventually the IBM S/370 mainframe computers. Developed in 1959 at the University of Michigan by Bernard Galler, Bruce Arden and Robert M. Graham, MAD is a variant of the ALGOL language. It was widely used to teach programming at colleges and universities during the 1960s and played a minor role in the development of CTSS, Multics, and the Michigan Terminal System computer operating systems.</p><p>The archives at the Bentley Historical Library of the University of Michigan contain reference materials on the development of MAD and MAD/I, including three linear feet of printouts with hand-written notations and original printed manuals.</p>",
        "infobox": {
            "name": "MAD",
            "paradigm": "Imperative programming|Imperative",
            "implementations": [
                "IBM 704",
                "IBM 7090",
                "UNIVAC 1108",
                "Philco 210-211",
                "S/360|IBM S/360",
                "and S/370|IBM S/370"
            ],
            "dialects": [
                "MAD",
                "MAD/I",
                "GOM"
            ],
            "year": "1959",
            "developer": [
                "Galler",
                "Arden",
                "and Graham"
            ],
            "influenced_by": [
                "ALGOL 58|IAL",
                "ALGOL 58"
            ],
            "operating_system": [
                "University of Michigan Executive System|UMES",
                "Michigan Terminal System|MTS",
                "Compatible Time-Sharing System|CTSS",
                "others"
            ]
        }
    },
    {
        "id": 349,
        "name": "MAPPER",
        "url": "https://en.wikipedia.org/wiki/MAPPER",
        "summary": "<p><br><b>MAPPER</b>, now known as BIS, is a  fourth-generation programming language from Sperry Univac. Mapper originated in the 1970s based on some work in the 1960s, but has been kept current. It was renamed and also given an extension named ICE - Internet Commerce Enabler.</p><p>Originally available on Sperry's Univac 1108, implementations now also exist for Windows NT, Sun Solaris and Linux. The GUI on Windows is the most advanced of these.</p>",
        "infobox": "N/A"
    },
    {
        "id": 350,
        "name": "MARK IV (software)",
        "url": "https://en.wikipedia.org/wiki/MARK_IV_(software)",
        "summary": "<p><b>MARK IV</b> is a fourth-generation programming language that was created by Informatics, Inc.  in the 1960s. Informatics took advantage of IBM's decision to unbundle their software; MARK IV was the first \"software product to have cumulative sales of $10 million\". </p><p>MARK IV was developed for IBM Systems (360 and 370) and for the RCA Spectra 70. Its main benefit was allowing faster application development on the order of 6 to 10 times faster than doing a system using a 3GL, such as COBOL. MARK IV, being an early 4GL, allowed user development of systems related to business. In a 1971 ad by Informatics, there are several quotes from customers, such as:\n</p>\n<dl><dd>We conservatively estimate that the benefits derived from the MARK IV System have completely returned  the cost of our investment in a period of less than 3 months.</dd>\n<dd>MARK IV runs ... handle Accounts Receivable, Inventory, Sales Analyses, etc. on about 26 different factories.</dd></dl><p>MARK IV went to Sterling Software in 1985 as part of that company's acquisition of Informatics General.  As VISION:BUILDER it is now part of the product suite from Computer Associates.</p>",
        "infobox": "N/A"
    },
    {
        "id": 351,
        "name": "MATH-MATIC",
        "url": "https://en.wikipedia.org/wiki/MATH-MATIC",
        "summary": "<p><b>MATH-MATIC</b> is the marketing name for the AT-3 (Algebraic Translator 3) compiler, an early programming language for the UNIVAC I and UNIVAC II. </p><p>MATH-MATIC was written beginning around 1955 by a team led by Charles Katz under the direction of Grace Hopper. A preliminary manual was produced in 1957 and a final manual the following year.\n</p><p>Syntactically, MATH-MATIC was similar to Univac's contemporaneous business-oriented language, FLOW-MATIC, differing in providing algebraic-style expressions and floating-point arithmetic, and arrays rather than record structures.\n</p>",
        "infobox": {
            "name": "MATH-MATIC",
            "paradigm": "imperative programming|imperative",
            "year": "start-date|1957",
            "designer": "Remington Rand",
            "influenced_by": "FLOW-MATIC",
            "influenced": "UNICODE (programming language)",
            "platform": [
                "UNIVAC I",
                "UNIVAC II"
            ]
        }
    },
    {
        "id": 352,
        "name": "MATLAB",
        "url": "https://en.wikipedia.org/wiki/MATLAB",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n\n<p><b>MATLAB</b> (<i>matrix laboratory</i>) is a multi-paradigm numerical computing environment and proprietary programming language developed by MathWorks. MATLAB allows matrix manipulations, plotting of functions and data, implementation of algorithms, creation of user interfaces, and interfacing with programs written in other languages.\n</p><p>Although MATLAB is intended primarily for numerical computing, an optional toolbox uses the MuPAD symbolic engine allowing access to symbolic computing abilities. An additional package, Simulink, adds graphical multi-domain simulation and model-based design for dynamic and embedded systems.\n</p><p>As of 2020, MATLAB has more than 4 million users worldwide. MATLAB users come from various backgrounds of engineering, science, and economics.\n</p>",
        "infobox": {
            "name": "MATLAB (software)",
            "logo": "File:Matlab Logo.png|100px",
            "logo caption": "L-shaped membrane logo",
            "screenshot": "File:MATLAB_R2015b.png|320px",
            "caption": "MATLAB R2015b running on Windows 10",
            "developer": "MathWorks",
            "released": "1984",
            "latest release version": "R2020a",
            "latest release date": "2020|03|19",
            "programming language": [
                "C (programming language)|C/C++",
                "MATLAB"
            ],
            "operating system": [
                "Microsoft Windows|Windows",
                "macOS",
                "and Linux"
            ],
            "platform": [
                "IA-32",
                "x86-64"
            ],
            "genre": "List of numerical analysis software|Numerical computing",
            "license": "Proprietary software|Proprietary commercial software",
            "website": "https://www.mathworks.com/products/matlab.html|mathworks.com"
        }
    },
    {
        "id": 353,
        "name": "MDL (programming language)",
        "url": "https://en.wikipedia.org/wiki/MDL_(programming_language)",
        "summary": "<p><b>MDL</b> (<b>Model Development Language</b> or <b>More Datatypes than Lisp</b> or <b>MIT Design Language</b>) is a programming language, a descendant of the language Lisp. Its initial purpose was to provide high level language support for the Dynamic Modeling Group at Massachusetts Institute of Technology's (MIT) Project MAC. It was initially developed in 1971 on a PDP-10 computer on a time-sharing operating system named Incompatible Timesharing System (ITS). It later ran on TENEX, TOPS-20,, BSD, and AEGIS. </p><p>The initial development team consisted of Gerald Sussman and Carl Hewitt of the Artificial Intelligence Lab, and Chris Reeve, Bruce Daniels, and David Cressey of the Dynamic Modeling Group. Later, Stu Galley, also of the Dynamic Modeling Group, wrote the MDL documentation.</p><p>MDL was initially called <i>Muddle</i>. This style of self-deprecating humor was not widely understood or appreciated outside of Project MAC and a few other early citadels of information technology. So the name was sanitized to MDL.</p><p>MDL provides several enhancements to classic Lisp.  It supports several built-in data types, including lists, strings and arrays, and user-defined data types.  It offers multithreaded expression evaluation and coroutines. Variables can carry both a local value within a scope, and a global value, for passing data between scopes. Advanced built-in functions supported interactive debugging of MDL programs, incremental development, and reconstruction of source programs from object programs.\n</p><p>Although MDL is obsolete, some of its features have been incorporated in later versions of Lisp.  Gerald Sussman went on to develop the Scheme language, in collaboration with Guy Steele, who later wrote the specifications for Common Lisp and Java.  Carl Hewitt had already published the idea for the language <i>Planner</i> before the MDL project began, but his subsequent thinking on Planner reflected lessons learned from building MDL.  Planner concepts influenced languages such as Prolog and Smalltalk. Smalltalk and Simula, in turn, influenced Hewitt's future work on the actor model.\n</p><p>But the largest influence that MDL had was on the software genre of interactive fiction (IF).  An IF game named Zork, sometimes called Dungeon, was first written in MDL. Later, Reeve, Daniels, Galley and other members of Dynamic Modeling went on to start Infocom, a company that produced many early commercial works of interactive fiction.\n</p>",
        "infobox": {
            "name": "MDL",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Functional programming|functional",
                "Procedural programming|procedural",
                "Reflection (computer programming)|reflective",
                "Metaprogramming|meta"
            ],
            "family": "Lisp (programming language)|Lisp",
            "designers": [
                "Gerald Sussman",
                "Carl Hewitt",
                "Chris Reeve",
                "Bruce Daniels"
            ],
            "developer": "Massachusetts Institute of Technology|MIT Project MAC",
            "released": "1971",
            "latest release version": "105",
            "latest release date": "1980",
            "typing": [
                "Dynamic typing|Dynamic",
                "Strong and weak typing|strong"
            ],
            "scope": [
                "Scope (programming)|Static",
                "lexical"
            ],
            "programming language": "MDL",
            "discontinued": "Yes",
            "platform": [
                "PDP-10",
                "VAX",
                "Apollo/Domain"
            ],
            "operating system": [
                "Incompatible Timesharing System|ITS",
                "TENEX (operating system)|TENEX",
                "TOPS-20",
                "Berkeley Software Distribution|BSD",
                "Domain/OS#AEGIS|AEGIS"
            ],
            "license": "Open-source license|Open-source",
            "influenced by": "Lisp (programming language)|Lisp",
            "influenced": [
                "Planner (programming language)|Planner",
                "Scheme (programming language)|Scheme",
                "Common Lisp",
                "Java (programming language)|Java",
                "Prolog",
                "Smalltalk; actor model",
                "interactive fiction"
            ]
        }
    },
    {
        "id": 354,
        "name": "MHEG-5",
        "url": "https://en.wikipedia.org/wiki/MHEG-5",
        "summary": "<p><b>MHEG-5</b>, or ISO/IEC 13522-5, is part of a set of international standards relating to the presentation of multimedia information, standardised by the Multimedia and Hypermedia Experts Group (MHEG). It is most commonly used as a language to describe interactive television services. </p>",
        "infobox": "N/A"
    },
    {
        "id": 355,
        "name": "MIIS (programming language)",
        "url": "https://en.wikipedia.org/wiki/MIIS_(programming_language)",
        "summary": "<p><b>MIIS</b> (Meditech Interpretive Information System) is a MUMPS-like programming language that was created by A.Neil Pappalardo and Curt W. Marble, on a DEC PDP at Mass General Hospital from 1964 to 1968. MUMPS evolution took two major directions: MUMPS proper and MIIS. MUMPS became an ANSI and ISO-standard language. When many MUMPS implementations standardized to be compatible, MIIS did not standardize, but became a proprietary system instead. </p><p>As an example of the differences between MUMPS and MIIS, the value of a logical expression in MUMPS may be false = zero (0) or true = non-zero, canonically, one (1). In MIIS, the value false is the empty string and the value of true is a string consisting of the ASCII delete character (code 127 decimal).\n</p><p>There is also a philosophical difference between the dialects.  MIIS often takes the approach that code should march along, regardless of possible errors, where MUMPS will error out to prevent more serious problems.  For example, when encountering an undefined variable, MUMPS generates an error where MIIS treats it as nil.\n</p><p>In the 1980s Brigham and Women's Hospital in Massachusetts used MIIS to program their Data General Mainframe.\nIn 1986, SCAMC reported that Vancouver General Hospital also had an Integrated Cardiology Patient Management System written in MIIS.\n</p><p>The MIIS language has been used in programming library systems as well as health industry systems. The OCLC's library system is one example. It has also been used to create financial systems for insurance brokers, as seen in Ireland and the UK in the late 1970s.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 356,
        "name": "MIMIC",
        "url": "https://en.wikipedia.org/wiki/MIMIC",
        "summary": "<p><b>MIMIC</b>, known in capitalized form only, is a former simulation computer language developed 1964 by H. E. Petersen, F. J. Sansom and L. M. Warshawsky of Systems Engineering Group within the Air Force Materiel Command at the Wright-Patterson AFB in Dayton, Ohio, United States. It is an expression-oriented continuous block simulation language, but capable of incorporating blocks of FORTRAN-like algebra. </p><p>MIMIC is a further development from MIDAS (<b>M</b>odified <b>I</b>ntegration <b>D</b>igital <b>A</b>nalog <b>S</b>imulator), which represented analog computer design. Written completely in FORTRAN but one routine in COMPASS, and ran on Control Data supercomputers, MIMIC is capable of solving much larger simulation models.\n</p><p>With MIMIC, ordinary differential equations describing mathematical models in several scientific disciplines as in engineering, physics, chemistry, biology, economics and as well as in social sciences can easily be solved by numerical integration and the results of the analysis are listed or drawn in diagrams. It also enables the analysis of nonlinear dynamic conditions.\n</p><p>The MIMIC software package, written as FORTRAN overlay programs, executes input statements of the mathematical model in six consecutive passes. Simulation programs written in MIMIC are compiled rather than interpreted. The core of the simulation package is a variable step numerical integrator of fourth-order Runge-Kutta method. Many useful functions related to electrical circuit elements exist besides some mathematical functions found in most scientific programming languages. There is no need to sort the statements in order of dependencies of the variables, since MIMIC does it internally.\n</p><p>Parts of the software organized in overlays are:\n</p>\n<ul><li>MIMIN (input)– reads in user simulation program and data,</li>\n<li>MIMCO (compiler) – compiles the user program and creates an in-core array of instructions,</li>\n<li>MIMSO (sort)– sorts the instructions array after dependencies of variables,</li>\n<li>MIMAS (assembler) – converts the BCD instructions into machine-oriented code,</li>\n<li>MIMEX (execute)– executes the user program by integrating,</li>\n<li>MIMOUT (output)– puts out the data as a list or diagram of data.</li></ul>",
        "infobox": "N/A"
    },
    {
        "id": 357,
        "name": "MIRC scripting language",
        "url": "https://en.wikipedia.org/wiki/MIRC_scripting_language",
        "summary": "<p><span></span> </p>\n\n<p>The <b>mIRC scripting language</b> (often unofficially abbreviated to \"<b>mSL</b>\") is the scripting language embedded in mIRC, an IRC client for Windows.\n</p>",
        "infobox": {
            "name": "mIRC Scripting Language",
            "file_ext": [
                ".mrc",
                ".ini"
            ],
            "paradigm": [
                "Event-driven programming",
                "Procedural programming"
            ],
            "year": "1995",
            "designer": "Khaled Mardam-Bey",
            "developer": "Khaled Mardam-Bey",
            "typing": "Dynamic typing",
            "implementations": "mIRC",
            "operating_system": "Microsoft Windows",
            "license": "Proprietary software",
            "website": "[http://mirc.com/ http://mirc.com]"
        }
    },
    {
        "id": 358,
        "name": "MIVA Script",
        "url": "https://en.wikipedia.org/wiki/MIVA_Script",
        "summary": "<p><b>Miva Script</b> is a proprietary computer scripting language mainly used for internet applications such as e-commerce. As of 2015, it is developed, maintained and owned by Miva Merchant, Inc., based in San Diego, California. Many web hosting companies support Miva Script on their servers, but it is significantly less widespread than other popular web languages.\n</p>",
        "infobox": {
            "paradigm": "Imperative programming|imperative",
            "developer": "[http://www.mivamerchant.com Miva Merchant]",
            "typing": [
                "Dynamic",
                "loose"
            ],
            "implementations": "[http://www.mivascript.com MivaScript]",
            "license": "[http://www.mivamerchant.com/support/docs/empresa-license-agreement Empresa]",
            "website": "www.mivascript.com",
            "file_ext": [
                ".mv",
                ".mvc",
                ".mvt"
            ],
            "influenced_by": [
                "C (programming language)|C",
                "Perl",
                "Java (programming language)|Java",
                "C++"
            ],
            "latest_release_version": "5.31",
            "operating_system": "Cross-platform",
            "year": "start-date|1996"
        }
    },
    {
        "id": 359,
        "name": "ML (programming language)",
        "url": "https://en.wikipedia.org/wiki/ML_(programming_language)",
        "summary": "<p><b>ML</b> (\"Meta Language\") is a general-purpose functional programming language.  It has roots in Lisp, and has been characterized as \"Lisp with types\".  ML is a statically-scoped functional programming language like Scheme.  It is known for its use of the polymorphic Hindley–Milner type system, which automatically assigns the types of most expressions without requiring explicit type annotations, and ensures type safety – there is a formal proof that a well-typed ML program does not cause runtime type errors.   ML provides pattern matching for function arguments, garbage collection, imperative programming, call-by-value and currying.  It is used heavily in programming language research and is one of the few languages to be completely specified and verified using formal semantics.  Its types and pattern matching make it well-suited and commonly used to operate on other formal languages, such as in compiler writing, automated theorem proving, and formal verification. </p>",
        "infobox": {
            "name": "ML",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm: functional programming|functional",
                "imperative programming|imperative"
            ],
            "year": "start date and age|1973",
            "designer": "Robin Milner and others at the University of Edinburgh",
            "typing": [
                "Type inference|Inferred",
                "static typing|static",
                "strong typing|strong"
            ],
            "dialects": [
                "OCaml",
                "Standard ML",
                "F Sharp (programming language)|F#"
            ],
            "influenced by": "ISWIM",
            "influenced": [
                "Clojure",
                "Coq",
                "Cyclone (programming language)|Cyclone",
                "C++",
                "Elm (programming language)|Elm",
                "F Sharp (programming language)|F#",
                "F* (programming language)|F*",
                "Haskell (programming language)|Haskell",
                "Idris (programming language)|Idris",
                "Kotlin (programming_language)|Kotlin",
                "Miranda (programming language)|Miranda",
                "Nemerle",
                "OCaml",
                "Opa (programming language)|Opa",
                "Erlang (programming language)|Erlang",
                "Rust (programming language)|Rust",
                "Scala (programming language)|Scala",
                "Standard ML"
            ]
        }
    },
    {
        "id": 360,
        "name": "MOO (programming language)",
        "url": "https://en.wikipedia.org/wiki/MOO_(programming_language)",
        "summary": "<p>The <b>MOO programming language</b> is a relatively simple programming language used to support the MOO Server. It is dynamically typed and uses a prototype-based object-oriented system, with syntax roughly derived from the Ada school of programming languages. </p>",
        "infobox": {
            "name": "MOO",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: structured programming|structured",
                "Prototype-based programming|prototype-based"
            ],
            "year": "1990",
            "designer": "Stephen White",
            "developer": "Stephen White and Pavel Curtis",
            "latest release version": "1.8.1",
            "latest release date": [
                "January 10",
                "2001"
            ],
            "typing": "dynamic typing|dynamic",
            "implementations": "MOO",
            "influenced_by": [
                "Algol programming language|Algol",
                "Lisp programming language|Lisp",
                "Scheme (programming language)|Scheme",
                "Smalltalk",
                "Self (programming language)|Self",
                "C (programming language)|C",
                "Ada (programming language)|Ada",
                "MUF (programming language)|MUF"
            ],
            "influenced": [
                "CoolMUD",
                "ColdC"
            ]
        }
    },
    {
        "id": 361,
        "name": "MPD (programming language)",
        "url": "https://en.wikipedia.org/wiki/MPD_(programming_language)",
        "summary": "<p><b>Multithreaded, Parallel, and Distributed Programming</b> (<b>MPD</b>) is a concurrent programming language whose syntax is derived from the one used in the book <i>Foundations of Multithreaded, Parallel, and Distributed Programming</i>. The name lists the distinguishing features of the language, namely that it supports all three of these concurrent programming techniques. </p><p>MPD is implemented as a variant of the SR programming language. It has a different parser, but it uses the same intermediate form and run-time system as SR. Consequently, MPD provides the same variety of concurrent programming mechanisms as does SR.\n</p><p>MPD programs can execute on single processors, shared-memory multiprocessors, or clusters of (homogeneous) processors. The implementation transparently supports a variety of different kinds of processors and Unix systems.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 362,
        "name": "MUMPS",
        "url": "https://en.wikipedia.org/wiki/MUMPS",
        "summary": "<p><b>MUMPS</b> (\"Massachusetts General Hospital Utility Multi-Programming System\"), or <b>M</b>, is a general-purpose computer programming language originally designed in 1966 for the healthcare industry. Its differentiating feature is its \"built-in\" database, enabling high-level access to disk storage using simple symbolic program variables and subscripted arrays; similar to the variables used by most languages to access main memory.</p><p>It continues to be used today by many large hospitals and banks to provide high-throughput transaction data processing. </p>",
        "infobox": {
            "name": "MUMPS",
            "paradigm": "Procedural programming|Procedural",
            "year": "1966",
            "designer": "Neil Pappalardo",
            "latest_release_version": "ANSI X11.1-1995",
            "latest_release_date": "release date|1995|12|8",
            "typing": "Typeless",
            "influenced_by": "JOSS",
            "influenced": [
                "Profile Scripting Language|PSL",
                "Caché ObjectScript"
            ],
            "operating_system": "Cross-platform"
        }
    },
    {
        "id": 363,
        "name": "M Sharp (programming language)",
        "url": "https://en.wikipedia.org/wiki/M_Sharp",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p><b>M#</b> (pronounced <i>em sharp</i>) is a code generation tool and a domain-specific language that can be used to create websites and web applications. It can translate entities and page definitions to ASP.NET Web Forms and MVC and C# code which in turn form the user interface and business logic layer of the application. Its main goals are to reduce time of development, increase code quality, and reduce human errors.</p>",
        "infobox": {
            "name": "M#",
            "logo": "File:msharp logo.png|205px",
            "designer": "Geeks ltd.",
            "developer": "Geeks ltd.",
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Structured programming|structured",
                "Object-oriented programming|object-oriented",
                "Event-driven programming|event-driven",
                "procedural programming|procedural",
                "metaprogramming|meta"
            ],
            "year": "2012",
            "implementations": [
                "Microsoft Visual C Sharp|Visual C#",
                ".NET Framework",
                "ASP.NET",
                "Domain-specific language"
            ],
            "typing": [
                "Static typing|static",
                "Dynamic typing|dynamic"
            ],
            "license": "proprietary",
            "website": "http://www.msharp.co.uk/"
        }
    },
    {
        "id": 364,
        "name": "Machine code",
        "url": "https://en.wikipedia.org/wiki/Machine_code",
        "summary": "<p>In computer programming, <b>machine code</b>, consisting of <b>machine language</b> instructions, is a low-level programming language used to directly control a computer's central processing unit (CPU). Each instruction causes the CPU to perform a very specific task, such as a load, a store, a jump, or an arithmetic logic unit (ALU) operation on one or more units of data in the CPU's registers or memory. </p><p>Machine code is a strictly numerical language which is intended to run as fast as possible, and may be regarded as the lowest-level representation of a compiled or assembled computer program or as a primitive and hardware-dependent programming language. While it is possible to write programs directly in machine code, managing individual bits and calculating numerical addresses and constants manually is tedious and error-prone. For this reason, programs are very rarely written directly in machine code in modern contexts, but may be done for low level debugging, program patching (especially when assembler source is not available) and assembly language disassembly.\n</p><p>The overwhelming majority of practical programs today are written in higher-level languages or assembly language. The source code is then translated to executable machine code by utilities such as compilers, assemblers, and linkers, with the important exception of interpreted programs, which are not translated into machine code. However, the <i>interpreter</i> itself, which may be seen as an executor or processor performing the instructions of the source code, typically consists of directly executable machine code (generated from assembly or high-level language source code).\n</p><p>Machine code is by definition the lowest level of programming detail visible to the programmer, but internally many processors use microcode or optimise and transform machine code instructions into sequences of micro-ops. This is not generally considered to be a machine code.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 365,
        "name": "Macsyma",
        "url": "https://en.wikipedia.org/wiki/Macsyma",
        "summary": "<p><b>Macsyma</b> (<span></span>; \"Project MAC's SYmbolic MAnipulator\") is one of the oldest general-purpose computer algebra systems  still in wide use. It was originally developed from 1968 to 1982 at MIT's Project MAC. </p><p>In 1982, Macsyma was licensed to Symbolics and became a commercial product. In 1992, Symbolics Macsyma was spun off to Macsyma, Inc., which continued to develop Macsyma until 1999. That version is still available for Microsoft's Windows XP operating system.\n</p><p>The 1982 version of MIT Macsyma remained available to academics and US government agencies, and it is distributed by the US Department of Energy (DOE). That version, DOE Macsyma, was maintained by Bill Schelter. Under the name of Maxima, it was released under the GPL in 1999, and remains under active maintenance.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 366,
        "name": "Magik (programming language)",
        "url": "https://en.wikipedia.org/wiki/Magik_(programming_language)",
        "summary": "<p><b>Magik</b> is an object-oriented programming language that supports multiple inheritance and polymorphism, and it is dynamically typed. It was designed and implemented in 1989 by Arthur Chance of Smallworld Systems Ltd. as part of Smallworld Geographical Information System (GIS). Following Smallworld's acquisition in 2000, Magik is now provided by GE Energy, still as part of its Smallworld technology platform. </p><p>Magik (Inspirational Magik) was originally introduced in 1990 and has been improved and updated over the years. Its current version is 5.2.\n</p><p>In July 2012, Magik developers announced that they were in the process of porting Magik language on the Java virtual machine. The successful porting was confirmed by Oracle Corporation in November of the same year.</p>",
        "infobox": "N/A"
    },
    {
        "id": 367,
        "name": "Magma computer algebra system",
        "url": "https://en.wikipedia.org/wiki/Magma_(computer_algebra_system)",
        "summary": "<p><b>Magma</b> is a computer algebra system designed to solve problems in algebra, number theory, geometry and combinatorics. It is named after the algebraic structure magma. It runs on Unix-like operating systems, as well as Windows. </p>",
        "infobox": {
            "name": "Magma",
            "logo": "Magma-logo.png",
            "developer": [
                "Computational Algebra Group",
                "Sydney School of Mathematics and Statistics|School of Mathematics and Statistics",
                "University of Sydney"
            ],
            "latest_release_version": "2.25-5",
            "latest_release_date": "2020|04|29",
            "operating_system": "Cross-platform",
            "genre": "Computer algebra system",
            "license": "Cost recovery (non-commercial proprietary)",
            "website": "magma.maths.usyd.edu.au"
        }
    },
    {
        "id": 368,
        "name": "Maple (software)",
        "url": "https://en.wikipedia.org/wiki/Maple_(software)",
        "summary": "<p><b>Maple</b> is a symbolic and numeric computing environment as well as a multi-paradigm programming language. It covers several areas of technical computing, such as symbolic mathematics, numerical analysis, data processing, visualization, and others. A toolbox, MapleSim, adds functionality for multidomain physical modeling and code generation.  </p><p>Maple's capacity for symbolic computing include those of a general-purpose computer algebra system. For instance, it can manipulate mathematical expressions and find symbolic solutions to\ncertain problems, such as those arising from ordinary and partial differential equations.\n</p><p>Maple is developed commercially by the Canadian software company Maplesoft. The name 'Maple' is a reference to the software's Canadian heritage.\n</p>",
        "infobox": {
            "name": "Maple",
            "screenshot": "Maple 2016 Core Screenshots.jpg",
            "caption": "Maple interface",
            "developer": "Waterloo Maple (Maplesoft)",
            "released": "1982",
            "latest release version": "Latest stable software release/Maple",
            "programming language": [
                "C (programming language)|C",
                "Java (programming language)|Java",
                "Maple"
            ],
            "genre": [
                "Computer algebra system",
                "Numeric computation"
            ],
            "license": "Proprietary software|Proprietary commercial software",
            "platform": [
                "Microsoft Windows|Windows (7",
                "8 and 10)",
                "macOS",
                "Linux"
            ],
            "language": [
                "English language|English",
                "Japanese language|Japanese",
                "and limited support in additional languages"
            ],
            "website": "https://www.maplesoft.com/products/Maple/"
        }
    },
    {
        "id": 369,
        "name": "Markup language",
        "url": "https://en.wikipedia.org/wiki/Markup_language",
        "summary": "<p>In computer text processing, a <b>markup language</b> is a system for annotating a document in a way that is syntactically distinguishable from the text, meaning when the document is processed for display, the markup language is not shown, and is only used to format the text. The idea and terminology evolved from the \"marking up\" of paper manuscripts (i.e., the revision instructions by editors), which is traditionally written with a red or blue pencil on authors' manuscripts. Such \"markup\" typically includes both content corrections (such as spelling, punctuation, or movement of content), and also typographic instructions, such as to make a heading larger or boldface. </p><p>In digital media, this \"blue pencil instruction text\" was replaced by tags which ideally indicate what the parts of the document <i>are</i>, rather than details of how they might be shown on some display. This lets authors avoid formatting every instance of the same kind of thing redundantly (and possibly inconsistently). It also avoids the specification of fonts and dimensions which may not apply to many users (such as those with different-size displays, impaired vision and screen-reading software).\n</p><p>Early markup systems typically included typesetting instructions, as troff, TeX and LaTeX do, while Scribe and most modern markup systems name components, and later process those names to apply formatting or other processing, as in the case of XML.\n</p><p>Some markup languages, such as the widely used HTML, have pre-defined presentation semantics—meaning that their specification prescribes some aspects of how to present the structured data on particular media. HTML, like DocBook, Open eBook, JATS and countless others, is a specific application of the markup meta-languages SGML and XML. That is, SGML and XML enable users to specify particular schemas, which determine just what elements, attributes, and other features are permitted, and where.\n</p><p>One extremely important characteristic of most markup languages is that they allow mixing markup directly into text streams. This happens all the time in documents: A few words in a sentence must be emphasized, or identified as a proper name, defined term, or other special item. This is quite different structurally from traditional databases, where it is by definition impossible to have data that is (for example) within a record, but not within any field. Likewise, markup for natural language texts must maintain ordering: it would not suffice to make each paragraph of a book into a \"paragraph\" record, where those records do not maintain order.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 370,
        "name": "Mary (programming language)",
        "url": "https://en.wikipedia.org/wiki/Mary_(programming_language)",
        "summary": "<p><b>Mary</b> is a programming language designed and implemented by RUNIT at Trondheim, Norway in the 1970s. It borrowed many features from ALGOL 68 but was designed for systems programming (machine-oriented programming). </p><p>An unusual feature of its syntax was that expressions were constructed using the conventional infix operators, but all of them had the same precedence and evaluation went from left to right unless there were brackets. Assignment had the destination on the right and assignment was considered just another operator.\n</p><p>Similar to C, several language features appear to have existed to allow producing reasonably well optimised code, despite a quite primitive code generator in the compiler. These included operators similar to the <code>+=</code> <i>et alter</i> in C and explicit register declarations for variables.\n</p><p>Notable features:\n</p>\n<ul><li>Dataflow syntax – values flow from left to right, including assignment</li>\n<li>Most constructs could be used in expressions: blocks, IF, CASE, etc.</li>\n<li>Text-based recursive macros</li>\n<li>Overloaded user-defined operators, not constrained to predefined identifiers as in C++</li>\n<li>Automatic building and dereferencing of pointers from type context</li>\n<li>Scalar range types</li>\n<li>Array and set enumeration in loop iterators</li>\n<li>Dynamic array descriptors (ROW)</li></ul><p>A book describing Mary was printed in 1974 (Fourth and last edition in 1979): <i>Mary Textbook</i> by Reidar Conradi &amp; Per Holager.\n</p><p>Compilers were made for Kongsberg Våpenfabrikk's SM-4 and Norsk Data Nord-10/ND-100 mini-computers. The original Mary compiler was written in NU ALGOL, ran on the Univac-1100 series and was used to bootstrap a native compiler for ND-100/Sintran-III. RUNIT implemented a CHILL compiler written in Mary which ran on ND-100 and had Intel 8086 and 80286 targets. When this compiler was ported to the VAX platform, a common backend for Mary and CHILL was implemented. Later, backends for i386 and SPARC were available. Since the Mary compiler was implemented in Mary, it was possible to run the compiler on all these platforms.\n</p><p>Mary is no longer maintained.\n</p>",
        "infobox": {
            "name": "Mary",
            "paradigm": "Imperative programming|imperative",
            "family": "ALGOL",
            "developer": "SINTEF|RUNIT",
            "released": "1971",
            "typing": [
                "static typing|static",
                "strong typing|strong"
            ],
            "influenced by": "ALGOL 68",
            "operating system": [
                "Cross-platform: Kongsberg Defence Systems|Kongsberg Våpenfabrikk SM-4",
                "Norsk Data Nord-10/ND-100",
                "Univac-1100 series",
                "Norsk Data|ND-100/Sintran-III",
                "i386",
                "SPARC"
            ]
        }
    },
    {
        "id": 371,
        "name": "Maude system",
        "url": "https://en.wikipedia.org/wiki/Maude_system",
        "summary": "<p>The <b>Maude system</b> is an implementation of rewriting logic developed at SRI International. It is similar in its general approach to Joseph Goguen's OBJ3 implementation of equational logic, but based on rewriting logic rather than order-sorted equational logic, and with a heavy emphasis on powerful metaprogramming based on reflection. </p><p>Maude is free software, and tutorials are available online.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 372,
        "name": "Max (software)",
        "url": "https://en.wikipedia.org/wiki/Max_(software)",
        "summary": "<p><b>Max</b>, also known as Max/MSP/Jitter, is a visual programming language for music and multimedia developed and maintained by San Francisco-based software company Cycling '74. Over its more than thirty-year history, it has been used by composers, performers, software designers, researchers, and artists to create recordings, performances, and installations.</p><p>The Max program is modular, with most routines existing as shared libraries. An application programming interface (API) allows third-party development of new routines (named <i>external objects</i>). Thus, Max has a large user base of programmers unaffiliated with Cycling '74 who enhance the software with commercial and non-commercial extensions to the program. Because of this extensible design, which simultaneously represents both the program's structure and its graphical user interface (GUI), Max has been described as the lingua franca for developing interactive music performance software.</p>",
        "infobox": {
            "name": "Max",
            "logo": "Logo Max 8 software.jpg",
            "logo size": "180px",
            "developer": "Cycling '74",
            "latest release version": "8.1.2",
            "latest release date": "2020|01|28",
            "programming language": [
                "C (programming language)|C",
                "C++ (on JUCE platform)"
            ],
            "operating system": [
                "Microsoft Windows",
                "macOS"
            ],
            "genre": "Music and multimedia development",
            "license": "Proprietary software|Proprietary",
            "website": "//cycling74.com/products/max/"
        }
    },
    {
        "id": 373,
        "name": "Maxima (software)",
        "url": "https://en.wikipedia.org/wiki/Maxima_(software)",
        "summary": "<p><b>Maxima</b> (<span></span>) is a computer algebra system (CAS) based on a 1982 version of Macsyma. It is written in Common Lisp and runs on all POSIX platforms such as macOS, Unix, BSD, and Linux, as well as under Microsoft Windows and Android. It is free software released under the terms of the GNU General Public License (GPL). </p>",
        "infobox": {
            "name": "Maxima",
            "logo": "Maxima-new.svg",
            "screenshot": "Maximaplot.png",
            "caption": [
                "Screenshot of Maxima",
                "plotting the 2D graph of a function with the gnuplot-x11 package running on Ubuntu Linux"
            ],
            "developer": "Macsyma group at Project MAC and volunteer contributors",
            "released": "1982",
            "latest release version": "5.44.0",
            "latest release date": "Release date and age|2020|06|08",
            "programming language": "Common Lisp",
            "operating system": "Cross-platform",
            "genre": "Mathematical software",
            "license": "GNU General Public License|GPL",
            "website": "http://maxima.sourceforge.net/"
        }
    },
    {
        "id": 374,
        "name": "Maya Embedded Language",
        "url": "https://en.wikipedia.org/wiki/Maya_Embedded_Language",
        "summary": "<p>The <b>Maya Embedded Language</b> (MEL) is a scripting language used to simplify tasks in Autodesk's 3D Graphics Software <i>Maya</i>. Most tasks that can be achieved through Maya's GUI can be achieved with MEL, as well as certain tasks that are not available from the GUI. MEL offers a method of speeding up complicated or repetitive tasks, as well as allowing users to redistribute a specific set of commands to others that may find it useful. </p>",
        "infobox": "N/A"
    },
    {
        "id": 375,
        "name": "Mercury (programming language)",
        "url": "https://en.wikipedia.org/wiki/Mercury_(programming_language)",
        "summary": "<p><b>Mercury</b> is a functional logic programming language made for real-world uses. The first version was developed at the University of Melbourne, Computer Science department, by Fergus Henderson, Thomas Conway, and Zoltan Somogyi, under Somogyi's supervision, and released on April 8, 1995. </p><p>Mercury is a purely declarative logic programming language. It is related to both Prolog and Haskell. It features a strong, static, polymorphic type system, and a strong mode and determinism system.\n</p><p>The official implementation, the Melbourne Mercury Compiler, is available for most Unix and Unix-like platforms, including Linux, macOS, and for Windows.\n</p>",
        "infobox": {
            "name": "Mercury",
            "logo": "Mercury (programming language) logo.jpg",
            "paradigm": [
                "Logic programming|Logic",
                "Functional programming|functional",
                "Object-oriented programming|object-oriented"
            ],
            "designer": "Zoltan Somogyi",
            "developer": "University of Melbourne",
            "released": "1995|04|08",
            "latest release version": "20.06",
            "latest release date": "2020|06|30",
            "typing": [
                "Strong and weak typing|Strong",
                "Type system#Static type checking|static",
                "Polymorphism (computer science)|polymorphic"
            ],
            "programming language": "Mercury",
            "platform": [
                "IA-32",
                "x86-64",
                "ARM architecture|ARM",
                "SPARC|Sparc64",
                "Java (software platform)|Java",
                "Common Language Infrastructure|CLI",
                "Open Telecom Platform|Erlang/OTP"
            ],
            "operating system": [
                "Cross-platform: Unix",
                "Linux",
                "macOS",
                "Solaris (operating system)|Solaris",
                "FreeBSD",
                "OpenBSD",
                "Microsoft Windows|Windows",
                "Android (operating system)|Android"
            ],
            "license": "GNU General Public License|GPL compiler,<br />GNU Lesser General Public License|LGPL standard library",
            "file ext": ".m",
            "website": "www.mercurylang.org",
            "implementations": "Melbourne Mercury Compiler",
            "influenced by": [
                "Prolog",
                "Hope (programming language)|Hope",
                "Haskell (programming language)|Haskell"
            ]
        }
    },
    {
        "id": 376,
        "name": "Mesa (programming language)",
        "url": "https://en.wikipedia.org/wiki/Mesa_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Mesa</b> is a programming language developed in the late 1970s at the Xerox Palo Alto Research Center in Palo Alto, California, United States. The language name was a pun based upon the programming language catchphrases of the time, because Mesa is a \"high level\" programming language.\n</p><p>Mesa is an ALGOL-like language with strong support for modular programming. Every library module has at least two source files: a <i>definitions</i> file specifying the library's interface plus one or more <i>program</i> files specifying the implementation of the procedures in the interface. To use a library, a program or higher-level library must \"import\" the definitions. The Mesa compiler type-checks all uses of imported entities; this combination of separate compilation with type-checking was unusual at the time.</p><p>Mesa introduced several other innovations in language design and implementation, notably in the handling of software exceptions, thread synchronization, and incremental compilation.\n</p><p>Mesa was developed on the Xerox Alto, one of the first personal computers with a graphical user interface, however, most of the Alto's system software was written in BCPL. Mesa was the system programming language of the later Xerox Star workstations, and for the GlobalView desktop environment.  Xerox PARC later developed Cedar, which was a superset of Mesa.\n</p><p>Mesa and Cedar had a major influence on the design of other important languages, such as Modula-2 and Java, and was an important vehicle for the development and dissemination of the fundamentals of GUIs, networked environments, and the other advances Xerox contributed to the field of computer science.\n</p>",
        "infobox": {
            "name": "Mesa",
            "designer": "Computer Systems Laboratory (CSL)",
            "developer": "Xerox PARC",
            "released": "start date and age|df|=|yes|1976",
            "latest release version": "Mesa 6.0 (Version 41)",
            "latest release date": "start date and age|df|=|yes|1981|07",
            "typing": [
                "Strong",
                "static"
            ],
            "influenced by": "ALGOL",
            "influenced": [
                "Java (programming language)|Java",
                "Modula-2",
                "Cedar (programming language)|Cedar",
                "PostScript"
            ]
        }
    },
    {
        "id": 377,
        "name": "Metafont",
        "url": "https://en.wikipedia.org/wiki/Metafont",
        "summary": "<p><b>Metafont</b> is a description language used to define raster fonts. It is also the name of the interpreter that executes Metafont code, generating the bitmap fonts that can be embedded into e.g. PostScript. Metafont was devised by Donald Knuth as a companion to his TeX typesetting system. </p><p>One of the characteristics of Metafont is that the points defining the shapes of the glyphs—for example top of a stem, or intersection of a stem and crossbar—are defined with geometrical equations; the intent that the three stems of an ‘m’ are equally spaced horizontally might be expressed as <span><span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x_{2}-x_{1}=x_{3}-x_{2}}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msub>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>2</mn>\n          </mrow>\n        </msub>\n        <mo>−</mo>\n        <msub>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>1</mn>\n          </mrow>\n        </msub>\n        <mo>=</mo>\n        <msub>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>3</mn>\n          </mrow>\n        </msub>\n        <mo>−</mo>\n        <msub>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>2</mn>\n          </mrow>\n        </msub>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x_{2}-x_{1}=x_{3}-x_{2}}</annotation>\n  </semantics></math></span></span> if points 1, 2, and 3 are at the bottom ends of the three stems, whereas the intent that they all end on the same vertical position would be <span><span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle y_{1}=y_{2}=y_{3}}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msub>\n          <mi>y</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>1</mn>\n          </mrow>\n        </msub>\n        <mo>=</mo>\n        <msub>\n          <mi>y</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>2</mn>\n          </mrow>\n        </msub>\n        <mo>=</mo>\n        <msub>\n          <mi>y</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>3</mn>\n          </mrow>\n        </msub>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle y_{1}=y_{2}=y_{3}}</annotation>\n  </semantics></math></span></span>.  Another characteristic is that Metafont is a macro language, where operations such as \"draw a lower case top of stem serif at point 4\" might appear as one macro instruction (with the point as argument) in the program for a letter.  For describing shapes, Metafont has a rich set of path construction operations that mostly relieves the user of having to calculate control points.  Finally, many families of Metafont fonts are set up so that the main source file for a font only defines a small number of design parameters (x-height, em width, slant, vertical stroke width, etc.), then calling a separate source file common for a whole range of fonts to actually draw the individual glyphs; this is the meta aspect of the system.\n</p>",
        "infobox": {
            "logo": "METAFONT logo.svg",
            "logo size": "220px",
            "developer": "Donald Knuth",
            "latest_release_version": "2.7182818",
            "latest_release_date": "start date and age|df|=|yes|2014|1",
            "operating_system": "Cross-platform",
            "genre": "Computer language",
            "license": "Permissive free software license|Permissive"
        }
    },
    {
        "id": 378,
        "name": "MicroScript (programming language)",
        "url": "https://en.wikipedia.org/wiki/TRON_project",
        "summary": "<p><b>TRON</b> (acronym for \"The Real-time Operating system Nucleus\") is an open architecture real-time operating system kernel design. The project was started by Prof. Dr. Ken Sakamura of the University of Tokyo in 1984. The project's goal is to create an ideal computer architecture and network, to provide for all of society's needs.</p><p>The Industrial TRON (ITRON) derivative was one of the world's most used operating systems in 2003, being present in billions of electronic devices such as mobile phones, appliances and even cars. Although mainly used by Japanese companies, it garnered interest worldwide. However, a dearth of quality English documentation was said to hinder its broader adoption.</p><p>The TRON project was integrated into T-Engine Forum in 2010. Today, it is supported by popular SSL/TLS libraries such as wolfSSL.</p>",
        "infobox": "N/A"
    },
    {
        "id": 379,
        "name": "Microassembler",
        "url": "https://en.wikipedia.org/wiki/Microassembler",
        "summary": "<p>A <b>microassembler</b> is a computer program that helps prepare a microprogram, called <i>firmware</i>, to control the low level operation of a computer in much the same way an assembler helps prepare higher level code for a processor. The difference is that the microprogram is usually only developed by the processor manufacturer and works intimately with the computer hardware. On a microprogrammed computer the microprogram implements the operations of the instruction set in which any normal program (including both application programs and operating systems) is written. The use of a microprogram allows the manufacturer to fix certain mistakes, including working around hardware design errors, without modifying the hardware. Another means of employing microassembler-generated microprograms is in allowing the same hardware to run different instruction sets. After it is assembled, the microprogram is then loaded to a control store to become part of the logic of a CPU's control unit. </p><p>Some microassemblers are more generalized and are not targeted at a single computer architecture. For example, through the use of macro-assembler-like capabilities, Digital Equipment Corporation used their <i>MICRO2</i> microassembler for a very wide range of computer architectures and implementations.\n</p><p>If a given computer implementation supports a writeable control store, the microassembler is usually provided to customers as a means of writing customized microcode.\n</p><p>In the process of microcode assembly it is helpful to verify the microprogram with emulation  tools before distribution. Nowadays, microcoding has experienced a revival, since it is possible to correct and optimize the firmware of processing units already manufactured or sold, in order to adapt to specific operating systems or to fix hardware bugs. However, a commonly usable microassembler for today's CPUs is not available to manipulate the microcode. Unfortunately, knowledge of a processor's microcode is usually considered proprietary information so it is difficult to obtain information about how to modify it.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 380,
        "name": "Microsoft Macro Assembler",
        "url": "https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler",
        "summary": "<p>The <b>Microsoft Macro Assembler</b> (<b>MASM</b>) is an x86 assembler that uses the Intel syntax for MS-DOS and Microsoft Windows. Beginning with MASM 8.0, there are two versions of the assembler: One for 16-bit &amp; 32-bit assembly sources, and another (<b>ML64</b>) for 64-bit sources only. </p><p>MASM is maintained by Microsoft, but since version 6.12 it has not been sold as a separate product. It is instead supplied with various Microsoft SDKs and C compilers. Recent versions of MASM are included with Microsoft Visual Studio.\n</p>",
        "infobox": {
            "name": "Microsoft Macro Assembler",
            "developer": "Microsoft",
            "released": "1981",
            "latest_release_version": "14.16.27023.1",
            "latest_release_date": "2017|03|07",
            "operating_system": "Microsoft Windows and MS-DOS",
            "genre": "Assembly language assembler|Assembler",
            "license": "Commercial software|Commercial proprietary software",
            "website": "https://docs.microsoft.com/en-us/cpp/assembler/masm/microsoft-macro-assembler-reference"
        }
    },
    {
        "id": 381,
        "name": "Milk (programming language)",
        "url": "https://en.wikipedia.org/wiki/Milk_(programming_language)",
        "summary": "<p>Milk is a programming language \"that lets application developers manage memory more efficiently in programs that deal with scattered data points in large data sets.\"</p>",
        "infobox": "N/A"
    },
    {
        "id": 382,
        "name": "Mirah (programming language)",
        "url": "https://en.wikipedia.org/wiki/Mirah_(programming_language)",
        "summary": "<p><b>Mirah</b> (formerly <b>Duby</b>) is a programming language based on Ruby language syntax, local type inference, hybrid static–dynamic type system, and a pluggable compiler toolchain. Mirah was created by Charles Oliver Nutter to be \"a 'Ruby-like' language, probably a subset of Ruby syntax, that [could] compile to solid, fast, idiomatic JVM bytecode.\" The word <i><i lang=\"jv\" title=\"Javanese language text\">mirah</i></i> refers to the gemstone ruby in the Javanese language, a play on the concept of Ruby in Java.</p>",
        "infobox": {
            "name": "Mirah",
            "paradigms": [
                "Object-oriented programming language|Object-oriented",
                "Imperative programming|imperative"
            ],
            "designer": "Charles Oliver Nutter",
            "latest release version": "0.2.1",
            "latest release date": "2016|09|26",
            "typing": [
                "Type system|static",
                "with dynamic features",
                "Strong and weak typing|strong",
                "Type inference|inferred"
            ],
            "platform": "Java virtual machine",
            "operating system": "Cross-platform",
            "license": "Apache License 2.0",
            "website": "www.mirah.org",
            "influenced by": [
                "Ruby (programming language)|Ruby",
                "Java (programming language)|Java",
                "Boo (programming language)|Boo"
            ]
        }
    },
    {
        "id": 383,
        "name": "Miranda (programming language)",
        "url": "https://en.wikipedia.org/wiki/Miranda_(programming_language)",
        "summary": "<p><b>Miranda</b> is a lazy, purely functional programming language designed by David Turner as a successor to his earlier programming languages SASL and KRC, using some concepts from ML and Hope.  It was produced by Research Software Ltd. of England (which holds a trademark on the name <i>Miranda</i>) and was the first purely functional language to be commercially supported.</p><p>Miranda was first released in 1985, as a fast interpreter in C for Unix-flavour operating systems, with subsequent releases in 1987 and 1989. Miranda had a strong influence on the later Haskell programming language.</p>",
        "infobox": {
            "name": "Miranda",
            "logo": "File:Miranda logo (programming language).jpg",
            "paradigm": [
                "lazy evaluation|lazy",
                "functional programming|functional",
                "declarative programming|declarative"
            ],
            "released": "1985",
            "designer": "David Turner (computer scientist)|David Turner",
            "developer": "Research Software Ltd",
            "typing": [
                "strong typing|strong",
                "static typing|static"
            ],
            "implementations": "Miranda",
            "influenced by": [
                "Kent Recursive Calculator|KRC",
                "ML (programming language)|ML",
                "SASL programming language|SASL",
                "Hope (programming language)|Hope"
            ],
            "influenced": [
                "Clean (programming language)|Clean",
                "Haskell (programming language)|Haskell",
                "Orwell (programming language)|Orwell"
            ],
            "website": "url|http://miranda.org.uk"
        }
    },
    {
        "id": 384,
        "name": "Model 204",
        "url": "https://en.wikipedia.org/wiki/Model_204",
        "summary": "<p><b>Model 204</b> (<b>M204</b>) is a database management system for IBM and compatible mainframe computers developed and commercialized by Computer Corporation of America. It was announced in 1965, and first deployed in 1972. It incorporates a programming language and an environment for application development.  Implemented in assembly language for IBM System/360 and its successors, M204 can deal with very large databases and transaction loads of 1000 TPS.</p>",
        "infobox": "N/A"
    },
    {
        "id": 385,
        "name": "Modelica",
        "url": "https://en.wikipedia.org/wiki/Modelica",
        "summary": "<p><b>Modelica</b> is an object-oriented, declarative, multi-domain modeling language for component-oriented modeling of complex systems, e.g., systems containing mechanical, electrical, electronic, hydraulic, thermal, control, electric power or process-oriented subcomponents. The free Modelica language\nis developed by the non-profit Modelica Association. The Modelica Association also develops the free Modelica Standard Library that contains about 1360 generic model components and 1280 functions in various domains, as of version 3.2.1.\n</p>",
        "infobox": {
            "name": "Modelica",
            "logo": "Image:Modelica.png|300px",
            "paradigm": "Declarative programming|declarative language",
            "year": "1997",
            "latest_release_version": "3.4",
            "latest_release_date": [
                "April 10",
                "2017"
            ],
            "implementations": [
                "AMESim",
                "CATIA Systems",
                "CyModelica",
                "Dymola",
                "JModelica.org",
                "MapleSim",
                "Wolfram SystemModeler",
                "OpenModelica",
                "Scicos",
                "SimulationX",
                "Vertex",
                "Xcos"
            ],
            "operating_system": "Cross-platform",
            "license": "[http://www.modelica.org/licenses/ModelicaLicense2/ Modelica License Version 2]",
            "website": "[http://www.modelica.org/ www.modelica.org]"
        }
    },
    {
        "id": 386,
        "name": "Modula",
        "url": "https://en.wikipedia.org/wiki/Modula",
        "summary": "<p>The <b>Modula</b> programming language is a descendant of the Pascal language. It was developed in Switzerland, at ETH Zurich, in the mid-1970s by Niklaus Wirth, the same person who designed Pascal. The main innovation of Modula over Pascal is a module system, used for grouping sets of related declarations into program units; hence the name <i>Modula</i>. The language is defined in a report by Wirth called <i>Modula. A language for modular multiprogramming</i> published 1976.</p><p>Modula was first implemented by Wirth on a PDP-11. Very soon, other implementations followed, most importantly, the compilers developed for University of York Modula, and one at Philips Laboratories named PL Modula, which generated code for the LSI-11 microprocessor. </p><p>The development of Modula was discontinued soon after its publication. Wirth then concentrated his efforts on Modula's successor, Modula-2.\n</p>",
        "infobox": {
            "name": "Modula",
            "paradigms": [
                "Imperative programming|Imperative",
                "Structured programming|structured",
                "Modular programming|modular"
            ],
            "family": "Niklaus Wirth|Wirth Modula",
            "designer": "Niklaus Wirth",
            "developer": "Niklaus Wirth",
            "released": "1975",
            "typing": [
                "Static typing|Static",
                "Strong and weak typing|strong",
                "Type system#Type safety and memory safety|safe"
            ],
            "discontinued": "Yes",
            "platform": [
                "PDP-11",
                "LSI-11"
            ],
            "influenced by": "Pascal (programming language)|Pascal",
            "influenced": [
                "Alma-0",
                "Go (programming language)|Go",
                "Modula-2"
            ]
        }
    },
    {
        "id": 387,
        "name": "Modula-2",
        "url": "https://en.wikipedia.org/wiki/Modula-2",
        "summary": "<p><b>Modula-2</b> is a structured, procedural programming language developed between 1977 and 1985 by Niklaus Wirth at ETH Zurich. It was created as the language for the operating system and application software of the Lilith personal workstation. It was later used for programming outside the context of the Lilith. </p><p>Wirth viewed Modula-2 as a successor to his earlier programming languages Pascal and Modula. The principal concepts are:\n</p>\n<ol><li>The module as a compilation unit for separate compilation</li>\n<li>The coroutine as the basic building block for concurrent processes</li>\n<li>Types and procedures that allow access to machine-specific data.</li></ol><p>The language design was influenced by the Mesa language and the Xerox Alto, both from Xerox, that Wirth saw during his 1976 sabbatical year at Xerox PARC. The computer magazine <i>BYTE</i> devoted the August 1984 issue to the language and its surrounding environment.</p><p>Modula-2 was followed by Modula-3 and later the Oberon series of languages.\n</p>",
        "infobox": {
            "name": "Modula-2",
            "paradigm": [
                "Imperative programming|imperative",
                "Structured programming|structured",
                "Modular programming|modular",
                "information hiding|data and procedure hiding",
                "Concurrent computing|concurrent"
            ],
            "year": "1978",
            "designer": "Niklaus Wirth",
            "typing": [
                "strong",
                "static"
            ],
            "dialects": [
                "PIM2",
                "PIM3",
                "PIM4",
                "ISO"
            ],
            "implementations": "[http://www.sysecol2.ethz.ch/RAMSES/MacMETH.html ETH compiler] written by Niklaus Wirth<br>[http://www.nongnu.org/gm2/ GNU Modula-2]<br>[http://www.modula2.org/ ADW Modula-2]",
            "influenced_by": [
                "Modula",
                "Mesa (programming language)|Mesa",
                "Pascal (programming language)|Pascal",
                "Algol-W",
                "Euclid (programming language)|Euclid"
            ],
            "influenced": [
                "Modula-3",
                "Oberon (programming language)|Oberon",
                "Ada (programming language)|Ada",
                "Fortran 90",
                "Lua (programming language)|Lua",
                "Seed7",
                "Zonnon",
                "Modula-GM"
            ],
            "operating_system": "Cross-platform",
            "file_ext": [
                ".mod",
                ".m2",
                ".def",
                ".MOD",
                ".DEF",
                ".mi",
                ".md"
            ]
        }
    },
    {
        "id": 388,
        "name": "Modula-3",
        "url": "https://en.wikipedia.org/wiki/Modula-3",
        "summary": "<p><b>Modula-3</b> is a programming language conceived as a successor to an upgraded version of Modula-2 known as Modula-2+. While it has been influential in research circles (influencing the designs of languages such as Java, C#, and Python) it has not been adopted widely in industry. It was designed by Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan (before at the Olivetti Software Technology Laboratory), Bill Kalsow and Greg Nelson at the Digital Equipment Corporation (DEC) Systems Research Center (SRC) and the Olivetti Research Center (ORC) in the late 1980s. </p><p>Modula-3's main features are simplicity and safety while preserving the power of a systems-programming language. Modula-3 aimed to continue the Pascal tradition of type safety, while introducing new constructs for practical real-world programming. In particular Modula-3 added support for generic programming (similar to templates), multithreading, exception handling, garbage collection, object-oriented programming, partial revelation, and explicit marking of unsafe code. The design goal of Modula-3 was a language that implements the most important features of modern imperative programming languages in quite basic forms. Thus allegedly dangerous and complicating features such as multiple inheritance and operator overloading were omitted.\n</p>",
        "infobox": {
            "name": "Modula-3",
            "logo": "Modula-3.svg",
            "paradigm": [
                "Imperative programming|imperative",
                "Structured programming|structured",
                "Procedural programming|procedural",
                "Modular programming|modular",
                "Concurrent computing|concurrent"
            ],
            "typing": [
                "Strong and weak typing|strong",
                "Static typing|static",
                "Type system#Safely and unsafely typed systems|safe or if Type system#Safely and unsafely typed systems|unsafe explicitly safe isolated"
            ],
            "family": "Niklaus Wirth|Wirth Modula",
            "designers": [
                "Luca Cardelli",
                "James Donahue",
                "Lucille Glassman",
                "Mick Jordan; Bill Kalsow",
                "Greg Nelson (computer scientist)|Greg Nelson"
            ],
            "developers": "Digital Equipment Corporation|DEC<br/>Olivetti<br/> Not a typo|elego Software Solutions GmbH",
            "released": "1988",
            "latest release version": "5.8.6",
            "latest release date": "2010|07|14",
            "latest test version": "5.8.6",
            "latest test date": "2010|07|14",
            "implementations": [
                "DEC Systems Research Center|SRC Modula-3",
                "CM3",
                "PM3",
                "EZM3",
                "M3/PC Klagenfurt"
            ],
            "influenced by": [
                "ALGOL",
                "Euclid (programming language)|Euclid",
                "Mesa (programming language)|Mesa",
                "Modula-2",
                "Modula-2+",
                "Oberon (programming language)|Oberon",
                "Pascal (programming language)|Pascal"
            ],
            "influenced": [
                "C Sharp (programming language)|C#",
                "Java (programming language)|Java",
                "Nim (programming language)|Nim",
                "OCaml",
                "Python (programming language)|Python"
            ],
            "platform": [
                "IA-32",
                "x86-64",
                "PowerPC",
                "SPARC"
            ],
            "operating system": [
                "Cross-platform: FreeBSD",
                "Linux",
                "Darwin (operating system)|Darwin",
                "SunOS"
            ],
            "website": "www.modula3.org"
        }
    },
    {
        "id": 389,
        "name": "Mohol programming languages",
        "url": "https://en.wikipedia.org/wiki/System_programming_language",
        "summary": "<p>A <b>system programming language</b> is a programming language used for system programming; such languages are designed for writing system software, which usually requires different development approaches when compared with application software. Edsger Dijkstra refers to these language as <b>Machine Oriented High Order Languages</b>, or <b>mohol</b>.</p><p>General-purpose programming languages tend to focus on generic features to allow programs written in the language to use the same code on different platforms. Examples of such languages include ALGOL and Pascal. This generic quality typically comes at the cost of denying direct access to the machine's internal workings, and this often has negative effects on performance. </p><p>System languages, in contrast, are designed not for compatibility, but for performance and ease of access to the underlying hardware while still providing high-level programming concepts like structured programming. Examples include Systems Programming Language (SPL or SPL/3000) and Executive Systems Problem Oriented Language (ESPOL), both of which are similar to ALGOL in syntax but tuned to their respective platforms. Others are cross-platform but designed to work close to the hardware, like JOVIAL and BCPL.\n</p><p>Some languages straddle the system and application domains, bridging the gap between these uses. The canonical example is C, which is used widely for both system and application programming. Some modern languages also do this such as Rust and Swift.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 390,
        "name": "Mortran",
        "url": "https://en.wikipedia.org/wiki/Mortran",
        "summary": "<p><b>Mortran</b> (<b>M</b>ore F<b>ortran</b>) is an extension of the Fortran programming language used for scientific computation. It introduces syntax changes, including the use of semicolons to end statements, in order to improve readability and flexibility. Mortran code is macro-processed into Fortran code for compilation. </p><p>Example:\n</p>\n\n<p>Note that Mortran, like many preprocessors, does not make a complete analysis of the Fortran source and, like many preprocessors, may not always make its assumptions/requirements explicit.  Consider, for example, Mortran multiple assignment.  From the Mortran <i>User Guide</i>:\n</p>\n\n<p>produces the following FORTRAN statements:\n</p>\n\n<p>In this example, the produced Fortran implements the multiple assignment correctly only if X is not aliased to I or to A(I,K), assuming the multiple assignment semantics are left to right.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 391,
        "name": "Mouse (programming language)",
        "url": "https://en.wikipedia.org/wiki/Mouse_(programming_language)",
        "summary": "<p>The <b>Mouse programming language</b> is a small computer programming language developed by Dr. Peter Grogono in the late 1970s and early 1980s. It was developed as an extension of an earlier language called MUSYS, which was used to control digital and analog devices in an electronic music studio. </p><p>Mouse was originally intended as a small, efficient language for microcomputers with limited memory.  It is an interpreted, stack-based language and uses Reverse Polish notation.  To make an interpreter as easy as possible to implement, Mouse is designed so that a program is processed as a stream of characters, interpreted one character at a time.\n</p><p>The elements of the Mouse language consist of a set of (mostly) one-character symbols, each of which performs a specific function (see table below).  Since variable names are limited to one character, there are only 26 possible variables in Mouse (named A-Z).  Integers and characters are the only available data types.\n</p><p>Despite these limits, Mouse includes a number of relatively advanced features, including:\n</p>\n<ul><li>Conditional branching</li>\n<li>Loops</li>\n<li>Pointers</li>\n<li>Macros (subroutines (which may be recursive))</li>\n<li>Arrays</li>\n<li>Code tracing</li></ul><p>The design of the Mouse language makes it ideal for teaching the design of a simple interpreter.  Much of the book describing Mouse is devoted to describing the implementation of two interpreters, one in Z80 assembly language, the other in Pascal.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 392,
        "name": "MuPAD",
        "url": "https://en.wikipedia.org/wiki/MuPAD",
        "summary": "<p><b>MuPAD</b> is a computer algebra system (CAS). Originally developed by the MuPAD research group at the University of Paderborn, Germany, development was taken over by the company SciFace Software GmbH &amp; Co. KG in cooperation with the MuPAD research group and partners from some other universities starting in 1997.  MuPAD's graphics package was particularly successful, especially considering the era when it was developed.</p><p>Until autumn 2005, the version \"MuPAD Light\" was offered for free for research and education, but as a result of the closure of the home institute of the MuPAD research group, only the version \"MuPAD Pro\" became available for purchase. </p><p>The MuPAD kernel is bundled with Scientific Notebook and Scientific Workplace. Former versions of <i>MuPAD Pro</i> were bundled with SciLab. In MathCAD's version 14 release Mupad was adopted as the CAS engine.\n</p><p>In September 2008, SciFace was purchased by MathWorks and the MuPAD code was included in the Symbolic Math Toolbox add-on for MATLAB. On 28 September 2008, MuPAD was withdrawn from the market as a software product in its own right. However, it is still available in the Symbolic Math Toolbox in MATLAB and can also be used as a stand-alone program by the command <code>mupad</code> entered into the MATLAB terminal.\n</p><p>The MuPAD notebook feature has been removed in MATLAB R2020a. However, MATLAB's Symbolic Math Toolbox still uses the MuPAD language as part of its underlying computational engine. MATLAB Live Editor is the recommended environment for performing, documenting, and sharing symbolic math computations.</p>",
        "infobox": {
            "name": "MuPAD",
            "logo": "MuPADCube.png",
            "screenshot": "MuPadScreenshot.jpg",
            "caption": "MuPAD running on Windows Vista",
            "developer": "The Mathworks Inc.",
            "latest_release_version": "7.2.0 (R2017a)",
            "operating_system": [
                "Microsoft Windows|Windows",
                "Mac OS X",
                "Linux"
            ],
            "genre": "Computer algebra system",
            "license": "Proprietary software|Proprietary",
            "status": "Active",
            "website": "mathworks.com/discovery/mupad.html"
        }
    },
    {
        "id": 393,
        "name": "Mystic BBS",
        "url": "https://en.wikipedia.org/wiki/Mystic_BBS",
        "summary": "<p><b>Mystic BBS</b> is a bulletin board system software program that began in 1995 and was first released to the public in December 1997 under the MS-DOS platform.  It has since been ported to Microsoft Windows, OS/2, OS X, and Linux (Intel and ARM based systems such as the Raspberry Pi).  Mystic was designed to be a spiritual successor to the Telegard and Renegade bulletin board systems. </p><p>Some of the more notable capabilities of Mystic BBS include:\n</p>\n<ul><li>Integrated Telnet, SSH, RLogin, FTP, BinkP, HTTP, NNTP, POP3, SMTP servers with IPv4 + IPv6 support</li>\n<li>Full 5D compliant BSO mailer and tosser, including BINKP and FTP mailer</li>\n<li>Built in AreaFix and FileFix functionality and full fileecho support</li>\n<li>Integrated QWK and QWKE networking via FTP</li>\n<li>Integrated text and ANSI editors, message editing with on-the-fly spell checking and word suggestions</li>\n<li>Proprietary scripting language called Mystic Programming Language (MPL)</li>\n<li>Embedded PYTHON programming language</li>\n<li>DOS CP437 and UTF8 character translations</li>\n<li>Dynamic menus including menu editor, and fully customizable prompts</li>\n<li>Multiple user-selectable themes</li>\n<li>DOOR32 support in addition to various DOS-type door formats</li>\n<li>Automatic random ANSI display (i.e. <tt>ansi.ans</tt>, <tt>ansi.an1</tt>, <tt>ansi.an2</tt>, etc. would display randomly)</li>\n<li>A fully featured ACS (access control system) and MCI display codes</li>\n<li>Highly integrated with ANSI graphics including full screen editor, lightbar menus, lightbar file listings and message reading</li>\n<li>Advanced, feature-rich JAM message base system with QWK/QWKE offline mail</li>\n<li>Multiple platform distributions available including Windows, OS X, Linux and ARM Linux (Raspberry Pi, ODROID, etc.)</li></ul><p>A more complete list of capabilities can be found at http://www.mysticbbs.com/features.html\n</p><p>Attracted to the flexibility and potential that the scripting language provides, a number groups, such as ACiDic BBS modding, Cyberia, Demonic, DoRE, Vanguard, wOE!mODDING and Wicked formed for the sole purpose of writing BBS mods for SysOps who run Mystic.\n</p>",
        "infobox": {
            "name": "Mystic BBS",
            "author": "James Coyle",
            "latest preview version": "1.12 Alpha 43",
            "latest preview date": "2019|03|01",
            "latest release version": "1.11",
            "latest release date": "2015|11|06",
            "programming language": "FreePascal",
            "operating system": [
                "DOS",
                "Microsoft Windows|Windows",
                "OS/2",
                "OS X",
                "Linux"
            ],
            "platform": [
                "IA_32",
                "x86-64",
                "ARM"
            ],
            "status": "Current",
            "genre": "Bulletin board system|BBS",
            "license": "Proprietary software|Proprietary freeware",
            "website": "www.mysticbbs.com"
        }
    },
    {
        "id": 394,
        "name": "Máni",
        "url": "https://en.wikipedia.org/wiki/M%C3%A1ni",
        "summary": "<p><b>Máni</b> (Old Norse \"Moon\") is the personification of the Moon in Norse mythology. Máni, personified, is attested in the <i>Poetic Edda</i>, compiled in the 13th century from earlier traditional sources, and the <i>Prose Edda</i>, written in the 13th century by Snorri Sturluson. Both sources state that he is the brother of the personified sun, Sól, and the son of Mundilfari, while the <i>Prose Edda</i> adds that he is followed by the children Hjúki and Bil through the heavens. As a proper noun, Máni appears throughout Old Norse literature. Scholars have proposed theories about Máni's potential connection to the Northern European notion of the Man in the Moon, and a potentially otherwise unattested story regarding Máni through skaldic kennings. </p>",
        "infobox": "N/A"
    },
    {
        "id": 395,
        "name": "NESL",
        "url": "https://en.wikipedia.org/wiki/NESL",
        "summary": "<p><b>NESL</b> is a parallel programming language developed at Carnegie Mellon by the SCandAL project and released in 1993. It integrates various ideas from parallel algorithms, and functional programming and array programming languages. </p><p>The most important new ideas behind NESL are\n</p>\n<ul><li><b>Nested data parallelism</b>: this feature offers the benefits of data parallelism, concise code that is easy to understand and debug, while being well suited for irregular algorithms, such as algorithms on trees, graphs or sparse matrices.</li>\n<li><b>A language based performance model</b>: this gives a formal way to calculate the work and depth of a program. These measures can be related to running time on parallel machines.</li></ul><p>The main design guideline for NESL was to make parallel programming easy and portable. Algorithms are typically significantly more concise in NESL than in most other parallel programming languages, and the code closely resembles high-level pseudocode.\n</p><p>NESL supports nested data parallelism by using the flattening transform to convert nested data parallelism to flat data parallelism. This works by storing nested vectors as the nested data and a segment descriptor of vector lengths, separately.\nThis flattening transform, however, can increase the asymptotic work and space complexity of the original program, leading to a much less efficient result.</p>",
        "infobox": {
            "name": "NESL",
            "paradigm": [
                "parallel",
                "functional programming|functional",
                "array programming|array"
            ],
            "year": "1993",
            "developer": "SCandAL project",
            "latest release version": "3.1",
            "latest release date": "November 1995",
            "license": "permissive license similar to the ISC license|ISC and MIT License|X11 licenses"
        }
    },
    {
        "id": 396,
        "name": "NEWP",
        "url": "https://en.wikipedia.org/wiki/NEWP",
        "summary": "<p><b>NEWP</b>, short for <b>New Executive Programming Language</b>, is a high-level programming language used on the Unisys MCP systems. The language is used to write the operating system and other system utilities, although it can also be used to write user software as well. Several constructs separate it from extended ALGOL on which it is based. Language operators such as <code>MEMORY</code> which allows direct memory access are strictly used by programs running as the MCP.</p>",
        "infobox": "N/A"
    },
    {
        "id": 397,
        "name": "NORD Programming Language",
        "url": "https://en.wikipedia.org/wiki/Nord_Programming_Language",
        "summary": "<p><b>Nord Programming Language</b>, commonly abbreviated <b>NPL</b>, was a programming language by the Norwegian minicomputer manufacturer Norsk Data. It shipped as a standard component of the operating system SINTRAN III. </p><p>The language was also used to implement SINTRAN III. I.e. the core and file system of SINTRAN III was written in NPL. The NPL compiler was also written in NPL and some core applications was early on written in NPL until PLANC came and linker and other software was rewritten in PLANC.\n</p><p>The NPL compiler was also special in that it did not produce object code as most compilers do. Instead it produced assembler code which then had to be assembled using the Norsk Data Assembler.\n</p><p>The registers of the CPU were available in NPL as predefined variables. Thus you could write:\n</p>\n<pre>X + T =: A\n</pre>\n<p>and the compiler would generate:\n</p>\n<pre>COPY SX DA\nRADD ST DA\n</pre>\n<p>Functions could be declared with multiple entry points:\n</p>\n<pre>FUNC FUN1, FUN2\n\nFUN1: T := 1\nFUN2:\n\ncode here\n\nEND\n</pre>\n<p>FUN1 could be called to set T to 1 before falling into FUN2 or T could be set to something else and call FUN2. If T register specified which file handle to write to then either FUN1 could be called to always output to terminal or T could be specified to handle a file itself in T and call FUN2 to output to that file.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 398,
        "name": "NWScript",
        "url": "https://en.wikipedia.org/wiki/NWScript",
        "summary": "<p><b>NWScript</b> is the scripting language developed by BioWare for the role-playing video game <i>Neverwinter Nights</i>. It is based on the C programming language and is implemented in the Aurora toolset. Neverscript, an open source 3rd party editor, has been created for the Mac OS X and Linux versions of <i>Neverwinter Nights</i> because the Aurora toolset has not been ported to those platforms. </p><p>NWScript is also used in the video games <i>The Witcher</i>, <i>Star Wars: Knights of the Old Republic</i> and <i>Star Wars: Knights of the Old Republic II The Sith Lords</i>, which use the Odyssey Engine. <i>Neverwinter Nights 2</i>, the sequel to the original <i>NWN</i>, features a modified version of this scripting language.\n</p>",
        "infobox": {
            "name": "NWscript",
            "year": [
                "June 18",
                "2002"
            ],
            "designer": "BioWare",
            "developer": "BioWare",
            "latest_release_version": "1.69.8109 (Neverwinter Nights)",
            "latest_release_date": [
                "July 9",
                "2008"
            ],
            "influenced_by": [
                "C (programming language)|C",
                "Java (programming language)|Java"
            ],
            "operating_system": "Microsoft Windows,<br />Third-party developer|3rd party tools for Mac OS X and Linux",
            "license": "[http://nwn.bioware.com/forums/viewtopic.html?forum=58&topic=46097 BioWare EULA]",
            "website": "[http://nwn.bioware.com/developers/ BioWare Developers Portal]"
        }
    },
    {
        "id": 399,
        "name": "NXT-G",
        "url": "https://en.wikipedia.org/wiki/Lego_Mindstorms_NXT",
        "summary": "<p><b>LEGO Mindstorms NXT</b> is a programmable robotics kit released by Lego in late July 2006. It replaced the first-generation Lego Mindstorms kit, which was called the Robotics Invention System. The base kit ships in two versions: the Retail Version (set #8527) and the Education Base Set (set #9797). It comes with the NXT-G programming software, or optionally LabVIEW for Lego Mindstorms. A variety of unofficial languages exist, such as NXC, NBC, leJOS NXJ, and RobotC. The second generation of the set, the Lego Mindstorms NXT 2.0, was released on August 1, 2009, featuring a color sensor and other upgraded capabilities. The third generation, the EV3, was released in September 2013.\n</p>",
        "infobox": {
            "name": "Lego Mindstorms NXT 2.0",
            "product ID": "#8547",
            "othernames": "Mindstorms NXT<br />Mindstorms NXT 2.0",
            "parentthemes": "Lego Technic|Technic",
            "from": "2009",
            "to": "2013",
            "website": "http://mindstorms.lego.com/"
        }
    },
    {
        "id": 400,
        "name": "Napier88",
        "url": "https://en.wikipedia.org/wiki/Napier88",
        "summary": "<p><b>Napier88</b> is an orthogonally persistent programming language that was designed and implemented at the University of St Andrews, Scotland. The primary designer was Ron Morrison, whose initial designs were extended and implemented by Fred Brown, Richard Connor, and Al Dearle. Napier88 was ahead of its time in many ways, and was the first robustly implemented language to combine a polymorphic type system with orthogonal persistence. The language was robustly implemented and released to users from both industry and academia; up to 1,000 registered users were recorded in due course. The language, however, was only intended to provide a proof of concept for an experiment in persistent programming; some time after 1989 (the year the first implementation was in fact released) the group's interests moved on and the language was no longer maintained. </p><p>Its influence lives on in various other systems however; the CORBA type <code>ANY</code> is distinctly recognisable in Napier88's type <code>ANY</code>; Microsoft's Common Language Runtime (CLR) uses a similar polymorphic architecture, and Java's parametric types solve some of the same problems of uninstantiated types escaping from their static scope.\n</p>",
        "infobox": {
            "name": "Napier88",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Procedural programming|Procedural",
                "Imperative programming|imperative",
                "Structured programming|structured"
            ],
            "family": "ALGOL",
            "designers": [
                "Ron Morrison",
                "Fred Brown",
                "Richard Connor",
                "Al Dearle"
            ],
            "developer": "University of St Andrews",
            "released": "1988",
            "programming language": "S-algol",
            "discontinued": "Yes",
            "influenced by": [
                "ALGOL 60",
                "S-algol",
                "PS-algol"
            ]
        }
    },
    {
        "id": 401,
        "name": "Neko (programming language)",
        "url": "https://en.wikipedia.org/wiki/NekoVM",
        "summary": "<p><b>NekoVM</b> is a virtual machine developed by Nicolas Cannasse as part of research and development (R&amp;D) efforts at two indie video game firms in Bordeaux, France: first at Motion Twin and then at Shiro Games.  NekoVM's native language is the bytecode for a high-level dynamically typed programming language called <b>Neko</b>.  This pairing allows Neko to be used directly as an embedded scripting language or to target NekoVM by compiling some other language (such as Haxe) to NekoVM bytecode. </p>\n\n\n",
        "infobox": {
            "name": "Neko",
            "logo": "NekoLogo.png",
            "paradigm": [
                "Object-oriented programming|Object-oriented",
                "structured programming|structured",
                "prototype-based programming|prototype-based",
                "scripting language|scripting"
            ],
            "designer": "Nicolas Cannasse",
            "developer": [
                "Motion Twin",
                "Shiro Games"
            ],
            "released": "2005",
            "latest release version": "2.3.0",
            "latest release date": "2019|10|24",
            "typing": "Type system|Dynamic",
            "programming language": [
                "C (programming language)|C",
                "OCaml"
            ],
            "platform": [
                "IA-32",
                "x86-64"
            ],
            "operating system": [
                "Microsoft Windows|Windows",
                "macOS",
                "Linux"
            ],
            "license": "MIT License|MIT",
            "file ext": ".neko .n",
            "website": "nekovm.org",
            "implementations": [
                "Neko",
                "Haxe"
            ]
        }
    },
    {
        "id": 402,
        "name": "Nemerle",
        "url": "https://en.wikipedia.org/wiki/Nemerle",
        "summary": "<p><b>Nemerle</b> is a general-purpose, high-level, statically typed programming language designed for platforms using the Common Language Infrastructure (.NET/Mono). It offers functional, object-oriented and imperative features. It has a simple C#-like syntax and a powerful metaprogramming system. In June 2012, the core developers of Nemerle were hired by the Czech software development company JetBrains. The team is focusing on developing Nitra, a framework to implement extant and new programming languages. This framework will likely be used to create future versions of Nemerle.</p><p>Nemerle is named after the Archmage Nemmerle, a character in the fantasy novel <i>A Wizard of Earthsea</i> by Ursula K. Le Guin. </p>",
        "infobox": {
            "name": "Nemerle",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: functional programming|functional",
                "imperative programming|imperative",
                "metaprogramming|meta",
                "object-oriented programming|object-oriented"
            ],
            "designers": [
                "Kamil Skalski",
                "Michał Moskal",
                "Prof. Leszek Pacholski",
                "Paweł Olszta at Wrocław University"
            ],
            "developer": "JetBrains",
            "released": "2003",
            "latest release version": "1.2.507.0",
            "latest release date": "2016|8|6",
            "typing": [
                "Type inference|Inferred",
                "Nominal type system|nominal",
                "type system|static",
                "strong and weak typing|strong"
            ],
            "implementations": "Nemerle",
            "influenced_by": [
                "C Sharp (programming language)|C#",
                "Lisp (programming language)|Lisp",
                "ML (programming language)|ML"
            ],
            "platform": "Common Language Infrastructure|CLI",
            "file ext": ".n",
            "website": "nemerle.org"
        }
    },
    {
        "id": 403,
        "name": "Net.Data",
        "url": "https://en.wikipedia.org/wiki/Net.Data",
        "summary": "<p><b>Net.Data</b> is a programming language by IBM used largely for database-backed web applications.</p>",
        "infobox": {
            "name": "Net.Data",
            "operating_system": [
                "IBM i",
                "z/OS",
                "Microsoft Windows",
                "UNIX"
            ],
            "website": "http://www-306.ibm.com/software/data/net.data/"
        }
    },
    {
        "id": 404,
        "name": "NetLogo",
        "url": "https://en.wikipedia.org/wiki/NetLogo",
        "summary": "<p><b>NetLogo</b> is a programming language and integrated development environment (IDE) for agent-based modeling. </p>",
        "infobox": {
            "name": "NetLogo",
            "logo": "Netlogo.png",
            "screenshot": "Netlogo-ui.png",
            "screenshot caption": "NetLogo graphical user interface",
            "family": "Lisp (programming language)|Lisp",
            "paradigms": [
                "Multi-paradigm programming language|multi-paradigm: List of educational programming languages|educational",
                "Procedural programming|procedural",
                "Computer simulation#Types|agent-based",
                "Simulation language|simulation"
            ],
            "designer": "Uri Wilensky",
            "developer": "Northwestern University Center for Connected Learning and Computer-Based Modeling",
            "released": "1999",
            "latest release version": "6.1.1",
            "latest release date": "2019|09|26",
            "typing": [
                "Dynamic typing|Dynamic",
                "Strong typing|strong"
            ],
            "scope": "Scope (computer science)#Lexical scoping and dynamic scoping|Lexical",
            "programming language": [
                "Scala (programming language)|Scala",
                "Java (programming language)|Java"
            ],
            "platform": [
                "IA-32",
                "x86-64"
            ],
            "operating system": "Cross-platform: Java virtual machine|JVM",
            "license": "GNU General Public License|GPL",
            "file ext": [
                ".nlogo",
                ".nlogo3d",
                ".nls"
            ],
            "website": "ccl.northwestern.edu/netlogo",
            "influenced by": [
                "Logo (programming language)|Logo",
                "StarLogo"
            ]
        }
    },
    {
        "id": 405,
        "name": "NetRexx",
        "url": "https://en.wikipedia.org/wiki/NetRexx",
        "summary": "<p><b>NetRexx</b> is an open source, originally IBM's, variant of the REXX programming language to run on the Java virtual machine.  It supports a classic REXX syntax, with no reserved keywords, along with considerable additions to support object-oriented programming in a manner compatible with Java's object model, yet can be used as both a compiled and an interpreted language, with an option of using only data types native to the JVM or the NetRexx runtime package. The latter offers the standard Rexx data type that combines string processing with unlimited precision decimal arithmetic. </p><p>Integration with the JVM platform is tight, and all existing Java class libraries can be used unchanged and without special setup; at the same time, a Java programmer can opt to just use the Rexx class from the runtime package for improved string handling in Java syntax source programs.</p><p>NetRexx is free to download from the Rexx Language Association. IBM announced the transfer of NetRexx 3.00 source code to the Rexx Language Association (RexxLA) on June 8, 2011.</p>",
        "infobox": {
            "name": "NetRexx",
            "logo": "File:NETREXX.gif",
            "paradigm": [
                "multi-paradigm programming language|multiparadigm: object-oriented programming|object-oriented",
                "procedural programming|procedural",
                "structured programming|structured"
            ],
            "year": "1996",
            "designer": "Mike Cowlishaw",
            "latest release version": "3.08",
            "latest release date": "2019|09|06|df|=|1",
            "frequently updated": "no",
            "file_ext": ".nrx",
            "typing": [
                "type system#Static typing|Static",
                "strong",
                "safe",
                "partly type system#Dynamic typing|dynamic",
                "everything is a string (programming)|string (for the Rexx data type",
                "which handles strings and numbers)"
            ],
            "implementations": "RexxLA NetRexx",
            "influenced_by": [
                "PL/I",
                "REXX",
                "Object REXX|ooREXX",
                "Java (programming language)|Java"
            ],
            "license": "International Components for Unicode|ICU License"
        }
    },
    {
        "id": 406,
        "name": "Netwide Assembler",
        "url": "https://en.wikipedia.org/wiki/Netwide_Assembler",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p>The <b>Netwide Assembler</b> (<b>NASM</b>) is an assembler and disassembler for the Intel x86 architecture. It can be used to write 16-bit, 32-bit (IA-32) and 64-bit (x86-64) programs. NASM is considered to be one of the most popular assemblers for Linux.</p><p>NASM was originally written by Simon Tatham with assistance from Julian Hall. As of 2016, it is maintained by a small team led by H. Peter Anvin. It is open-source software released under the terms of a simplified (2-clause) BSD license.</p>",
        "infobox": {
            "logo": "File:Netwide Assembler.svg|176px|alt=NASM logo|NASM logo",
            "author": [
                "Simon Tatham",
                "Julian Hall"
            ],
            "developer": [
                "H. Peter Anvin",
                "et al."
            ],
            "released": "df|=|yes|1996|10",
            "latest release version": "2.15.02",
            "latest release date": "df|=|yes|2020|07|02",
            "operating system": [
                "Unix-like",
                "Microsoft Windows|Windows",
                "OS/2",
                "MS-DOS"
            ],
            "genre": "x86 assembly language|x86 assembly language|assembler",
            "language": "English language|English",
            "license": "BSD licenses|BSD 2-clause",
            "website": "https://www.nasm.us"
        }
    },
    {
        "id": 407,
        "name": "NewLISP",
        "url": "https://en.wikipedia.org/wiki/NewLISP",
        "summary": "<p><span></span> </p>\n<p><b>newLISP</b> is a scripting language which is a dialect of the Lisp family of programming languages. It was designed and developed by Lutz Mueller. newLISP is free and open-source software released under the GNU General Public License, version 3 or later.\n</p>",
        "infobox": {
            "name": "newLISP",
            "logo": "Nl logo libel side color 240X100.png",
            "logo caption": "The newLISP dragonfly logo",
            "paradigm": "Multi-paradigm",
            "family": "Lisp (programming language)|Lisp",
            "designer": "Lutz Mueller",
            "developer": "Lutz Mueller",
            "released": "1991",
            "latest release version": "10.7.5",
            "latest release date": "2019|05|12",
            "latest preview version": "10.7.4",
            "latest preview date": "2018|09|10",
            "scope": "Dynamic",
            "platform": [
                "IA-32",
                "x86-64"
            ],
            "operating system": [
                "Cross-platform: Unix",
                "Unix-like",
                "Microsoft Windows|Windows"
            ],
            "license": "GNU General Public License|GPLv3+",
            "website": "www.newlisp.org",
            "influenced by": [
                "C (programming language)|C",
                "Common Lisp",
                "Perl",
                "Scheme (programming language)|Scheme"
            ]
        }
    },
    {
        "id": 408,
        "name": "Newspeak (programming language)",
        "url": "https://en.wikipedia.org/wiki/Newspeak_(programming_language)",
        "summary": "<p><b>Newspeak</b> is a programming language and platform in the tradition of Smalltalk and Self being developed by a team led by Gilad Bracha. The platform includes an IDE, a GUI library, and standard libraries. Starting in 2006, Cadence Design Systems funded its development and employed the main contributors, but ceased funding in January 2009.</p><p>Newspeak is a class based language. Classes may be nested, as in BETA. This is one of the key differences between Newspeak and Smalltalk.  All names in Newspeak are late-bound, and are interpreted as message sends, as in Self. </p><p>Newspeak is distinguished by its unusual approach to modularity. The language has no global namespace. Top level classes act as module declarations. Module declarations are first class values (i.e., they may be stored in variables, passed as parameters, returned from methods, etc.) and are stateless.\n</p>",
        "infobox": {
            "name": "Newspeak",
            "paradigm": [
                "object-oriented programming|object-oriented",
                "functional programming|functional"
            ],
            "year": "2006",
            "designer": "Gilad Bracha",
            "developer": [
                "Gilad Bracha",
                "Peter von der Ahé",
                "Vassili Bykov",
                "Yaron Kashai",
                "Ryan Macnak",
                "William Maddox",
                "Eliot Miranda"
            ],
            "latest release version": "Prototype",
            "latest release date": "February 2013",
            "typing": [
                "dynamic typing|dynamic",
                "Type system#Optional type systems|optional"
            ],
            "influenced_by": [
                "Smalltalk",
                "Self (programming language)|Self",
                "BETA (programming language)|BETA",
                "Nineteen Eighty-Four"
            ],
            "license": "Apache License",
            "website": "url|http://newspeaklanguage.org"
        }
    },
    {
        "id": 409,
        "name": "NewtonScript",
        "url": "https://en.wikipedia.org/wiki/NewtonScript",
        "summary": "<p><b>NewtonScript</b> is a prototype-based programming language created to write programs for the Newton platform. It is heavily influenced by the Self programming language, but modified to be more suited to needs of mobile and embedded devices.</p>",
        "infobox": {
            "name": "NewtonScript",
            "paradigm": "prototype-based programming|Prototype object-oriented programming|Object-oriented",
            "designer": "Walter Smith",
            "developer": "Apple Computer",
            "latest release date": "1993",
            "typing": "dynamic typing|Dynamic",
            "influenced": "Io programming language|Io",
            "year": "1993",
            "influenced_by": [
                "Self (programming language)|Self",
                "Dylan programming language|Dylan"
            ]
        }
    },
    {
        "id": 410,
        "name": "Nial",
        "url": "https://en.wikipedia.org/wiki/Nial",
        "summary": "<p><b>Nial</b> (from \"Nested Interactive Array Language\") is a high-level array programming language developed from about 1981 by Mike Jenkins of Queen's University, Kingston, Ontario, Canada.  Jenkins co-created the Jenkins–Traub algorithm. </p><p>Nial combines a functional programming notation for arrays based on an array theory developed by Trenchard More with structured programming concepts for numeric, character and symbolic data.\n</p><p>It is most often used for prototyping and artificial intelligence.\n</p>",
        "infobox": {
            "name": "Nial",
            "paradigm": "array programming|array",
            "year": "1981",
            "designer": "Mike Jenkins",
            "developer": "Nial Systems Ltd",
            "latest release version": "6.3",
            "latest release date": "release date and age|2006|08",
            "typing": "dynamic typing|dynamic",
            "implementations": "Q'Nial",
            "influenced_by": [
                "APL programming language|APL",
                "Lisp programming language|Lisp"
            ],
            "website": "https://github.com/danlm/qnial7"
        }
    },
    {
        "id": 411,
        "name": "Nice (programming language)",
        "url": "https://en.wikipedia.org/wiki/Nice_(programming_language)",
        "summary": "<p><b>Nice</b> is an object-oriented programming language released under the GNU General Public License. </p><p>It features a powerful type system which can help eliminate many common bugs, such as null pointer dereferences and invalid casts, by detecting potential runtime errors at compile-time; the goal of the designers was to provide safety features comparable to those found in languages such as ML and Haskell, but using a more conventional syntax.\n</p><p>Nice aims to be feature-rich, and as such, in addition to the common features of modern object-oriented programming languages, it implements contracts in the style of Eiffel, class extensibility through multimethods, and many concepts drawn from functional programming such as anonymous functions, tuples, pattern matching (“value dispatch”), and parametric polymorphism.\n</p><p>Source programs are compiled to Java bytecode, and can therefore interact with libraries written in Java and other programming languages targeting the Java Virtual Machine.\n</p><p>Work on the Nice language appears to have slowed since early 2006.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 412,
        "name": "Nickle (programming language)",
        "url": "https://en.wikipedia.org/wiki/Nickle_(programming_language)",
        "summary": "<p><b>Nickle</b> is a numeric oriented programming language by Keith Packard and Bart Massey. Originally used for desktop calculation, it has since expanded for prototyping of complicated algorithms. </p>",
        "infobox": {
            "name": "Nickle",
            "paradigm": "Multi-paradigm programming language|multi-paradigm",
            "year": "2001",
            "designer": "Keith Packard and Bart Massey",
            "latest_release_date": [
                "May 21",
                "2006"
            ],
            "typing": "strong",
            "influenced_by": [
                "C (programming language)|C",
                "Lisp (programming language)|Lisp",
                "Modula-3",
                "ML (programming language)|ML",
                "Java (programming language)|Java"
            ],
            "operating_system": "Cross-platform",
            "license": "MIT License",
            "website": "[http://www.nickle.org/ www.nickle.org]"
        }
    },
    {
        "id": 413,
        "name": "Nim (programming language)",
        "url": "https://en.wikipedia.org/wiki/Nim_(programming_language)",
        "summary": "<p><b>Nim</b> is an imperative, general-purpose, multi-paradigm, statically typed, systems, compiled programming language designed and developed by Andreas Rumpf. It is designed to be \"efficient, expressive, and elegant\", supporting metaprogramming, functional, message passing, procedural, and object-oriented programming styles by providing several features such as compile time code generation, algebraic data types, a foreign function interface (FFI) with C and C++, and compiling to C, C++, Objective-C, and JavaScript. </p>",
        "infobox": {
            "name": "Nim",
            "logo": "Nim-logo.png",
            "logo caption": "The Nim crown logo",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Compiled language|compiled",
                "Concurrent programming|concurrent",
                "Procedural programming|Procedural",
                "Imperative programming|Imperative",
                "Functional programming|Functional",
                "Object-oriented programming|Object-oriented"
            ],
            "designer": "Andreas Rumpf",
            "released": "2008",
            "latest release version": "1.2.4",
            "latest release date": "2020|06|27",
            "typing": [
                "static typing|Static",
                "strong typing|strong",
                "type inference|inferred",
                "structural type system|structural"
            ],
            "influenced by": [
                "Ada (programming language)|Ada",
                "Modula-3",
                "Lisp (programming language)|Lisp",
                "C++",
                "Object Pascal",
                "Python (programming language)|Python",
                "Oberon (programming language)|Oberon"
            ],
            "platform": [
                "IA-32",
                "x86-64"
            ],
            "operating system": "Cross-platform",
            "license": "MIT License|MIT",
            "website": "nim-lang.org",
            "file_ext": ".nim"
        }
    },
    {
        "id": 414,
        "name": "Nix package manager",
        "url": "https://en.wikipedia.org/wiki/Nix_package_manager",
        "summary": "<p><b>Nix</b> is a cross-platform package manager that utilizes a purely functional deployment model where software is installed into unique directories generated through cryptographic hashes. Dependencies from each software installation are included within each hash, solving the problem of dependency hell. This novel approach to package management promises to generate more reliable, reproducible, and portable packages.</p><p>Nix packages are defined through a lazy functional programming language specifically designed for package management. Dependencies are tracked directly in this language through special values called \"derivations\" which are installed by Nix lazily. Nix keeps track of these references automatically so that installed packages can be garbage collected when no other package depends on them. At the cost of greater storage requirements, all upgrades in Nix are guaranteed to be both atomic and capable of efficient roll-back. This also enables multiple users to safely install software on the same system without administrator privileges. </p><p>Nix has full support for Linux and macOS and can safely be installed side-by-side with an existing package manager, though some workarounds are required for Catalina.</p>",
        "infobox": {
            "name": "Nix package manager",
            "latest release version": "2.3.1",
            "latest release date": "2019|10|10",
            "programming language": "C++",
            "platform": [
                "Linux",
                "Unix-like"
            ],
            "genre": "Package management system|Package management",
            "license": "GNU Lesser General Public License|LGPL",
            "website": "https://nixos.org/nix"
        }
    },
    {
        "id": 415,
        "name": "Non-English-based programming languages",
        "url": "https://en.wikipedia.org/wiki/Non-English-based_programming_languages",
        "summary": "<p><b>Non-English-based programming languages</b> are programming languages that do not use keywords taken from or inspired by English vocabulary. </p>\n\n\n",
        "infobox": "N/A"
    },
    {
        "id": 416,
        "name": "Not Quite C",
        "url": "https://en.wikipedia.org/wiki/Not_Quite_C",
        "summary": "<p><b>Not Quite C</b> (<b>NQC</b>) is a programming language, application programming interface (API), and native bytecode compiler toolkit for the Lego Mindstorms, Cybermaster and LEGO Spybotics systems. It is based primarily on the C language but has specific limitations, such as the maximum number of subroutines and variables allowed, which differ depending on the version of firmware the RCX has. The language was invented by David Baum. He has released two books on the subject. </p>",
        "infobox": "N/A"
    },
    {
        "id": 417,
        "name": "Not eXactly C",
        "url": "https://en.wikipedia.org/wiki/Not_eXactly_C",
        "summary": "<p><b>Not eXactly C</b>, or <b>NXC</b>, is a high-level programming language for the Lego Mindstorms NXT designed by John Hansen in 2006. NXC, which is short for Not eXactly C, is based on Next Byte Codes, an assembly language. NXC has a syntax like C. The IDE for NXC is the Bricx Command Center. </p><p>The NXC compiler is available under the Mozilla Public License. A sample code is as shown below:\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 418,
        "name": "Nu (programming language)",
        "url": "https://en.wikipedia.org/wiki/Nu_(programming_language)",
        "summary": "<p><b>Nu</b> is an interpreted object-oriented programming language, with a Lisp-like syntax, created by Tim Burks as an alternative scripting language to program OS X through its Cocoa application programming interface (API). Implementations also exist for iPhone and Linux. </p><p>The language was first announced at C4, a conference for indie Mac developers held in August 2007.\n</p>",
        "infobox": {
            "name": "Nu",
            "year": "2007",
            "designer": "Tim Burks",
            "developer": "Tim Burks",
            "latest_release_version": "2.2.2",
            "latest_release_date": "2017|4|17",
            "influenced_by": [
                "Lisp (programming language)|Lisp",
                "Objective-C",
                "Ruby (programming language)|Ruby"
            ],
            "typing": "dynamic",
            "paradigm": [
                "Structured programming|structured",
                "Imperative programming|imperative",
                "functional programming|functional",
                "Object-oriented programming|object-oriented"
            ],
            "platform": "x86",
            "operating system": "OS X",
            "license": [
                "Apache License|Apache",
                "v. 2.0"
            ],
            "website": "programming-nu.github.io"
        }
    },
    {
        "id": 419,
        "name": "Nullsoft Scriptable Install System",
        "url": "https://en.wikipedia.org/wiki/Nullsoft_Scriptable_Install_System",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Nullsoft Scriptable Install System</b> (<b>NSIS</b>) is a script-driven installer authoring tool for Microsoft Windows backed by Nullsoft, the creators of Winamp. NSIS is released under a combination of free software licenses, primarily the zlib license. It has become a widely used alternative to commercial proprietary products like InstallShield, with users including Amazon.com, Dropbox, Google, Ubisoft, FL Studio,  BitTorrent, and McAfee.</p>",
        "infobox": {
            "name": "Nullsoft Scriptable Install System",
            "logo": "Nullsoft Scriptable Install System icon.png",
            "screenshot": "NSIS screenshot.png",
            "caption": "NSIS Installer",
            "author": "Nullsoft",
            "developer": "NSIS Team and NSIS Community",
            "released": "2001|07|31",
            "latest release version": "3.05",
            "latest release date": "2019|12|16",
            "programming language": [
                "C (programming language)|C",
                "C++"
            ],
            "operating system": [
                "Windows",
                "Mac OS X"
            ],
            "genre": "Software development tools",
            "license": "zlib License",
            "website": "nsis.sourceforge.io"
        }
    },
    {
        "id": 420,
        "name": "O:XML",
        "url": "https://en.wikipedia.org/wiki/O:XML",
        "summary": "<p><span></span> </p>\n\n<p><b>o:XML</b> is an open source, dynamically typed, general-purpose object-oriented programming language based on XML-syntax.  It has threads, exception handling, regular expressions and namespaces.  Additionally o:XML has an expression language very similar to XPath that allows functions to be invoked on nodes and node sets.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 421,
        "name": "OBJ2",
        "url": "https://en.wikipedia.org/wiki/OBJ2",
        "summary": "<p><b>OBJ2</b> is a programming language with Clear-like parametrised modules and a functional system based on equations. It is a member of the OBJ family of languages.</p>",
        "infobox": "N/A"
    },
    {
        "id": 422,
        "name": "OCaml",
        "url": "https://en.wikipedia.org/wiki/OCaml",
        "summary": "<p><b>OCaml</b> (<span></span> <i title=\"English pronunciation respelling\">oh-<span>KAM</span>-əl</i>, formerly <b>Objective Caml</b>) is a general-purpose, multi-paradigm programming language which extends the Caml dialect of ML with object-oriented features. OCaml was created in 1996 by Xavier Leroy, Jérôme Vouillon, Damien Doligez, Didier Rémy, Ascánder Suárez, and others. </p><p>The OCaml toolchain includes an interactive top-level interpreter, a bytecode compiler, an optimizing native code compiler, a reversible debugger, and a package manager (OPAM).  OCaml was initially developed in the context of automated theorem proving, and has an outsize presence in static analysis and formal methods software. But it has found serious use beyond these areas, with major applications in systems programming, web development, and financial engineering, among other application domains.\n</p><p>The acronym <i>CAML</i> originally stood for <i>Categorical Abstract Machine Language</i>, but OCaml omits this abstract machine. OCaml is a free and open-source software project managed and principally maintained by the French Institute for Research in Computer Science and Automation (INRIA). In the early 2000s, elements from OCaml were adopted by many languages, notably F# and Scala.\n</p>\n\n\n",
        "infobox": {
            "name": "OCaml",
            "logo": "OCaml Logo.svg",
            "paradigm": [
                "Programming paradigm#Multi-paradigm|Multi-paradigm: functional programming|functional",
                "imperative programming|imperative",
                "modular programming|modular",
                "object-oriented programming|object-oriented"
            ],
            "family": "ML (programming language)|ML",
            "released": "1996",
            "designer": [
                "Xavier Leroy",
                "Jérôme Vouillon",
                "Damien Doligez",
                "Didier Rémy",
                "Ascánder Suárez"
            ],
            "developer": "French Institute for Research in Computer Science and Automation|INRIA",
            "latest release version": "4.10.0",
            "latest release date": "2020|2|21",
            "typing": [
                "type inference|Inferred",
                "static typing|static",
                "strong and weak typing|strong",
                "structural typing|structural"
            ],
            "influenced by": [
                "C (programming language)|C",
                "Caml",
                "Modula-3",
                "Pascal (programming language)|Pascal",
                "Standard ML"
            ],
            "influenced": [
                "ATS (programming language)|ATS",
                "Coq",
                "Elm (programming language)|Elm",
                "F Sharp (programming language)|F#",
                "F* (programming language)|F*",
                "Haxe",
                "Opa (programming language)|Opa",
                "Rust (programming language)|Rust",
                "Scala (programming language)|Scala"
            ],
            "programming language": [
                "OCaml",
                "C (programming language)|C"
            ],
            "platform": [
                "IA-32",
                "x86-64",
                "Power ISA|Power",
                "SPARC",
                "ARM architecture|ARM 32-64"
            ],
            "operating system": [
                "Cross-platform: Unix",
                "macOS",
                "Microsoft Windows|Windows"
            ],
            "license": "GNU Lesser General Public License|LGPLv2.1",
            "file ext": [
                ".ml",
                ".mli"
            ],
            "website": "https://ocaml.org/",
            "wikibooks": "Objective Caml"
        }
    },
    {
        "id": 423,
        "name": "OPS5",
        "url": "https://en.wikipedia.org/wiki/OPS5",
        "summary": "<p><b>OPS5</b> is a rule-based or production system computer language, notable as the first such language to be used in a successful expert system, the R1/XCON system used to configure VAX computers. </p><p>The OPS (said to be short for \"Official Production System\") family was developed in the late 1970s by Charles Forgy while at Carnegie Mellon University. Allen Newell's research group in artificial intelligence had been working on production systems for some time, but Forgy's implementation, based on his Rete algorithm, was especially efficient, sufficiently so that it was possible to scale up to larger problems involving hundreds or thousands of rules.\n</p><p>OPS5 uses a forward chaining inference engine; programs execute by scanning \"working memory elements\" (which are vaguely object-like, with classes and attributes) looking for matches with the rules in \"production memory\". Rules have actions that may modify or remove the matched element, create new ones, perform side effects such as output, and so forth. Execution continues until no more matches can be found.\n</p><p>In this sense, OPS5 is an execution engine for a Petri net extended with inhibitor arcs.\n</p><p>The OPS5 forward chaining process makes it extremely parallelizeable during the matching phase, and several automatic parallelizing compilers were created.\n</p><p><b>OPS4</b> was an early version, while <b>OPS83</b> came later.\n</p><p>The first implementation of OPS5 was written in Lisp, and later rewritten in BLISS for speed.\n</p><p><b>DEC OPS5</b> is an extended implementation of the OPS5 language definition, developed for use with the VMS, RISC ULTRIX, and DEC OSF/1 operating systems.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 424,
        "name": "ORCA/Modula-2",
        "url": "https://en.wikipedia.org/wiki/ORCA/Modula-2",
        "summary": "<p><b>ORCA/Modula-2</b> is a Modula-2 compiler written in the Modula-2 programming language for the Apple IIGS computer. </p><p>It was developed by Peter Easdown during 1993–94 and published by The Byte Works. Whilst originally developed separately, when it was finally published, it was fully integrated with the development platform/environment called the Apple Programmers Workshop or ORCA/M.\n</p><p>The compiler was originally developed using a version of TopSpeed Modula-2 on an Intel 80286 based PC. The output of the compiler at this point was 65816 assembler source for assembly by ORCA/M on the Apple IIGS. Once the compiler was stable enough, the IBM PC was decommissioned, and all development was done on the Apple IIGS.\n</p><p>At publication, the compiler was shipped with comprehensive support for the Apple IIGS's operating system (GS/OS) and toolkit.\n</p><p>Unfortunately, due to the demise of the Apple IIGS, ORCA/Modula-2 never had much impact in the market.\n</p><p>The compiler development was continued however for a short while during 1995, after which it stalled.\n</p>",
        "infobox": {
            "name": "ORCA/Modula-2",
            "author": "Peter Easdown",
            "developer": "The Byte Works",
            "released": "about 1994",
            "programming language": "Modula-2",
            "platform": "Apple IIGS",
            "genre": "compiler"
        }
    },
    {
        "id": 425,
        "name": "Oak (programming language)",
        "url": "https://en.wikipedia.org/wiki/Oak_(programming_language)",
        "summary": "<p> <b>Oak</b> is a discontinued programming language created by James Gosling in 1991, initially for Sun Microsystems' set-top box project. The language later evolved to become Java.\n</p><p>The name <i>Oak</i> was used by Gosling after an oak tree that stood outside his office.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 426,
        "name": "Oberon (programming language)",
        "url": "https://en.wikipedia.org/wiki/Oberon_(programming_language)",
        "summary": "<p><b>Oberon</b> is a general-purpose programming language first published in 1987 by Niklaus Wirth and the latest member of the Wirthian family of ALGOL-like languages (Euler, Algol-W, Pascal, Modula, and Modula-2). Oberon was the result of a concentrated effort to increase the power of Modula-2, the direct successor of Pascal, and simultaneously to reduce its complexity. Its principal new feature is the concept of type extension of record types: It permits the construction of new data types on the basis of existing ones and to relate them, deviating from the dogma of strictly static data typing. Type extension is Wirth's way of inheritance reflecting the viewpoint of the parent site. Oberon was developed as part of the implementation of the Oberon operating system at ETH Zurich in Switzerland. The name is from the moon of Uranus, Oberon. </p><p>Oberon is still maintained by Wirth and the latest Project Oberon compiler update is dated Mar 6, 2020.</p>",
        "infobox": {
            "name": "Oberon",
            "logo": "OberonLogo.svg",
            "paradigm": [
                "imperative programming|Imperative",
                "structured programming|structured",
                "modular programming|modular",
                "object-oriented programming|object-oriented"
            ],
            "year": "1987",
            "designer": "Niklaus Wirth",
            "typing": [
                "strong",
                "hybrid (static and dynamic)"
            ],
            "influenced_by": "Modula-2",
            "influenced": [
                "Oberon-2",
                "#Oberon-07|Oberon-07",
                "Zonnon",
                "Go (programming language)|Go",
                "Nim (programming language)|Nim",
                "Active Oberon",
                "Component Pascal"
            ],
            "website": "http://www.projectoberon.com/"
        }
    },
    {
        "id": 427,
        "name": "ObjectLOGO",
        "url": "https://en.wikipedia.org/wiki/Logo_(programming_language)",
        "summary": "<p><b>Logo</b> is an educational programming language, designed in 1967 by Wally Feurzeig, Seymour Papert, and Cynthia Solomon. <i>Logo</i> is not an acronym: the name was coined by Feurzeig while he was at Bolt, Beranek and Newman, and derives from the Greek <i>logos</i>, meaning <i>word</i> or <i>thought</i>. </p><p>A general-purpose language, Logo is widely known for its use of turtle graphics, in which commands for movement and drawing produced line or vector graphics, either on screen or with a small robot termed a turtle. The language was conceived to teach concepts of programming related to Lisp and only later to enable what Papert called \"body-syntonic reasoning\", where students could understand, predict, and reason about the turtle's motion by imagining what they would do if they were the turtle. There are substantial differences among the many dialects of Logo, and the situation is confused by the regular appearance of turtle graphics programs that are named Logo.\n</p><p>Logo is a multi-paradigm adaptation and dialect of Lisp, a functional programming language. There is no standard Logo, but UCBLogo has the best facilities for handling lists, files, I/O, and recursion in scripts, and can be used to teach all computer science concepts, as UC Berkeley lecturer Brian Harvey did in his <i>Computer Science Logo Style</i> trilogy.</p><p>Logo is usually an interpreted language, although compiled Logo dialects (such as Lhogho and Liogo) have been developed. Logo is not case-sensitive but retains the case used for formatting purposes.\n</p>",
        "infobox": {
            "name": "Logo",
            "logo": "Remi turtlegrafik.png",
            "logo caption": "Example Logo output",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Functional programming|functional",
                "Educational programming language|educational",
                "Procedural programming|procedural",
                "Reflection (computer science)|reflective"
            ],
            "family": "Lisp (programming language)|Lisp",
            "designers": [
                "Wally Feurzeig",
                "Seymour Papert",
                "Cynthia Solomon"
            ],
            "developer": [
                "BBN Technologies|Bolt",
                "Beranek and Newman"
            ],
            "released": "1967",
            "typing": "Dynamic typing|dynamic",
            "implementations": [
                "UCBLogo",
                "many others"
            ],
            "dialects": [
                "StarLogo",
                "NetLogo"
            ],
            "influenced": [
                "AgentSheets",
                "NetLogo",
                "Smalltalk",
                "Etoys (programming language)|Etoys",
                "Scratch (programming language)|Scratch",
                "KTurtle",
                "REBOL",
                "Boxer (programming environment)|Boxer"
            ],
            "influenced by": "Lisp (programming language)|Lisp"
        }
    },
    {
        "id": 428,
        "name": "Object Lisp",
        "url": "https://en.wikipedia.org/wiki/Object_Lisp",
        "summary": "<p><b>Object Lisp</b> was a computer programming language, a dialect of the Lisp language. It was an object-oriented extension for the Lisp dialect Lisp Machine Lisp, designed by Lisp Machines, Inc. Object Lisp was also an early example of prototype-based programming. </p><p>It was seen as a competitor to other object-oriented extensions to Lisp at around the same time such as Flavors, in use by Symbolics, Common Objects developed by Hewlett-Packard, and CommonLoops, in use by Xerox.\n</p><p>Object Lisp was also used in early versions of Macintosh Common Lisp. There, the user interface toolkit was written using Object Lisp.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 429,
        "name": "Object Pascal",
        "url": "https://en.wikipedia.org/wiki/Object_Pascal",
        "summary": "<p><b>Object Pascal</b> is an extension to the programming language Pascal that provides object-oriented programming (OOP) features such as classes and methods. </p><p>The language was originally developed by Apple Computer as <i>Clascal</i> for the Lisa Workshop development system. As Lisa gave way to Macintosh, Apple collaborated with Niklaus Wirth, the author of Pascal, to develop an officially standardized version of Clascal. This was renamed Object Pascal. Through the mid-1980s, Object Pascal was the main programming language for early versions of the MacApp application framework. The language lost its place as the main development language on the Mac in 1991 with the release of the C++-based MacApp 3.0. Official support ended in 1996.\n</p><p>Symantec also developed a compiler for Object Pascal for their THINK Pascal product, which could compile programs much faster than Apple's own Macintosh Programmer's Workshop (MPW). Symantec then developed the THINK Class Library (TCL), based on MacApp concepts, which could be called from both Object Pascal and THINK C. The THINK suite largely displaced MPW as the main development platform on the Mac in the late 1980s.\n</p><p>Symantec ported Object Pascal to the PC, and developed a similar object framework on that platform. In contrast to TCL, which eventually migrated to C++, the PC libraries remained mainly based on Pascal.\n</p><p>Borland added support for object-oriented programming to Turbo Pascal 5.5, which would eventually become the basis for the Object Pascal dialect used in Delphi. Delphi remained mainstream for business applications on the PC into the early 2000s, and was partly displaced in the 2000s with the introduction of the .NET Framework.\n</p>",
        "infobox": {
            "name": "Object Pascal",
            "paradigms": [
                "Imperative programming|Imperative",
                "Structured programming|structured",
                "Object-oriented programming|object-oriented",
                "Functional programming|functional (Delphi dialect only)",
                "Component-based software engineering|component-based",
                "Event-driven programming|event-driven",
                "Generic programming|generic"
            ],
            "family": "Niklaus Wirth|Wirth Pascal (programming language)|Pascal",
            "designers": [
                "Initially Apple Computer with input from Niklaus Wirth",
                "and then by Borland International",
                "led by Anders Hejlsberg"
            ],
            "released": "1986",
            "typing": [
                "Type system|Static and dynamic (dynamic typing through variants",
                "''array of const''",
                "and Run-time type information|RTTI)",
                "Type system#Strong and weak typing|strong",
                "Type system#Safely and unsafely typed systems|safe"
            ],
            "platform": [
                "ARM architecture|ARM",
                "x86",
                "PowerPC",
                "ppc64",
                "SPARC",
                "MIPS architecture|MIPS",
                "Common Language Infrastructure|CLI",
                "Java (software platform)|Java",
                "Cocoa (API)|Cocoa"
            ],
            "file ext": [
                "<code>.p</code>",
                "<code>.pp</code>",
                "<code>.pas</code>"
            ],
            "implementations": [
                "Delphi (software)|Delphi (x86",
                "ARM architecture|ARM)",
                "Free Pascal (x86",
                "PowerPC",
                "ppc64",
                "SPARC",
                "MIPS architecture|MIPS",
                "ARM architecture|ARM)",
                "Oxygene (programming language)|Oxygene (Common Language Infrastructure|CLI",
                "Java (programming language)|Java",
                "Native Cocoa (API)|Cocoa)",
                "Smart Mobile Studio (JavaScript)"
            ],
            "dialects": [
                "Apple",
                "Turbo Pascal",
                "Free Pascal (using '''objfpc''' or '''delphi''' mode)",
                "Delphi (software)|Delphi",
                "Delphi.NET",
                "Delphi Web Script",
                "Oxygene (programming language)|Oxygene"
            ],
            "influenced by": [
                "Pascal (programming language)|Pascal",
                "Simula",
                "Smalltalk"
            ],
            "influenced": [
                "C Sharp (programming language)|C#",
                "Genie (programming language)|Genie",
                "Java (programming language)|Java",
                "Nim (programming language)|Nim",
                "C/AL"
            ]
        }
    },
    {
        "id": 430,
        "name": "Object REXX",
        "url": "https://en.wikipedia.org/wiki/Object_REXX",
        "summary": "<p>The <b>Object REXX</b> programming language is an object-oriented scripting language initially produced by IBM for the operating system OS/2 and later for Microsoft Windows. It is a follow-on to and a significant extension of the \"Classic Rexx\" language originally created for the Conversational Monitor System (CMS) component of the operating system VM/SP and later ported to Multiple Virtual Storage (MVS), OS/2 and PC DOS.  </p><p>The OS/2 version of IBM Object REXX includes classes to support IBM System Object Model (SOM) and Workplace Shell (WPS).\n</p><p>On October 12, 2004, IBM released Object REXX as free and open-source software, giving rise to <i>Open Object Rexx</i> (<b>ooREXX</b>), now available for various operating systems: Linux, Solaris, Windows. This implementation includes a Windows Script Host (WSH) Scripting Engine for Rexx. The released sources however didn't include the classes for SOM and Workplace Shell (WPS) support.</p><p>Object REXX supports multiple inheritance via the use of mixin classes.\n</p>",
        "infobox": {
            "logo": "Rexx3 orig size transparent.gif",
            "name": "Object REXX",
            "paradigm": "Object-oriented programming|Object-oriented (Class-based programming|class-based)",
            "released": "1988",
            "latest release version": "4.2.0",
            "latest release date": "2014|02|24",
            "frequently updated": "no",
            "license": [
                "Common Public License|CPL 1.0",
                "GNU General Public License|GPLv2"
            ],
            "designer": "Simon C. Nash (IBM)",
            "implementations": "ooREXX (since 2004)",
            "influenced by": [
                "Rexx",
                "Smalltalk"
            ],
            "influenced": "NetRexx",
            "operating system": [
                "Cross-platform: IBM AIX|AIX",
                "Linux",
                "OS/2; Microsoft Windows|Windows NT"
            ],
            "file ext": [
                ".rxs",
                ".rex"
            ],
            "website": "www.oorexx.org"
        }
    },
    {
        "id": 431,
        "name": "Objective-C",
        "url": "https://en.wikipedia.org/wiki/Objective-C",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Objective-C</b> is a general-purpose, object-oriented programming language that adds Smalltalk-style messaging to the C programming language. It was the main programming language supported by Apple for macOS, iOS, and their respective application programming interfaces (APIs), Cocoa and Cocoa Touch, until the introduction of Swift in 2014.</p><p>The language was originally developed in the early 1980s. It was later selected as the main language used by NeXT for its NeXTSTEP operating system, from which macOS and iOS are derived. Portable Objective-C programs that do not use Apple libraries, or those using parts that may be ported or reimplemented for other systems, can also be compiled for any system supported by GNU Compiler Collection (GCC) or Clang.\n</p><p>Objective-C source code 'implementation' program files usually have <span>.m</span> filename extensions, while Objective-C 'header/interface' files have <link rel=\"mw-deduplicated-inline-style\" href=\"mw-data:TemplateStyles:r886049734\"><span>.h</span> extensions, the same as C header files. Objective-C++ files are denoted with a <link rel=\"mw-deduplicated-inline-style\" href=\"mw-data:TemplateStyles:r886049734\"><span>.mm</span> file extension.\n</p>",
        "infobox": {
            "name": "Objective-C",
            "file ext": [
                ".h",
                ".m",
                ".mm",
                ".M"
            ],
            "paradigm": [
                "reflection (computer science)|Reflective",
                "class-based programming|class-based object-oriented programming|object-oriented"
            ],
            "family": "C (programming language)|C",
            "released": "1984",
            "designer": "Tom Love and Brad Cox",
            "latest release version": "2.0",
            "typing": [
                "Static typing|static",
                "Dynamic typing|dynamic",
                "Weak typing|weak"
            ],
            "implementations": [
                "Clang",
                "GNU Compiler Collection|GCC"
            ],
            "influenced by": [
                "C (programming language)|C",
                "Smalltalk"
            ],
            "influenced": [
                "Groovy (programming language)|Groovy",
                "Java (programming language)|Java",
                "Nu (programming language)|Nu",
                "Objective-J",
                "TOM (object-oriented programming language)|TOM",
                "Swift (programming language)|Swift"
            ],
            "operating_system": "Cross-platform",
            "website": "[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html  developer.apple.com]",
            "wikibooks": "Objective-C Programming"
        }
    },
    {
        "id": 432,
        "name": "Objective-J",
        "url": "https://en.wikipedia.org/wiki/Objective-J",
        "summary": "<p><b>Objective-J</b> is a programming language developed as part of the Cappuccino web development framework. Its syntax is nearly identical to the Objective-C syntax and it shares with JavaScript the same relationship that Objective-C has with the C programming language: that of being a strict, but small, superset; adding traditional inheritance and Smalltalk/Objective-C style dynamic dispatch. Pure JavaScript, being a prototype-based language, already has a notion of object orientation and inheritance, but Objective-J adds the use of class-based programming to JavaScript. </p><p>Programs written in Objective-J need to be preprocessed before being run by a web browser's JavaScript virtual machine. This step can occur in the web browser at runtime or by a compiler which translates Objective-J programs into pure JavaScript code.  The Objective-J compiler is written in JavaScript; consequently, deploying Objective-J programs does not require a web browser plug-in. Objective-J can be compiled and run on Node.js.\n</p>",
        "infobox": {
            "name": "Objective-J",
            "paradigm": [
                "Multi-paradigm: reflection (computer science)|reflective",
                "Object-oriented programming|object-oriented",
                "functional programming|functional",
                "imperative programming|imperative",
                "scripting language|scripting"
            ],
            "developer": "Cappuccino Core Developers and community.",
            "typing": [
                "dynamic typing|dynamic",
                "weak typing|weak",
                "duck typing|duck"
            ],
            "license": "GNU Lesser General Public License|LGPL",
            "website": "[http://www.cappuccino-project.org/ cappuccino-project.org]",
            "year": "2008",
            "influenced_by": [
                "Objective-C",
                "JavaScript"
            ]
        }
    },
    {
        "id": 433,
        "name": "Obliq",
        "url": "https://en.wikipedia.org/wiki/Obliq",
        "summary": "<p><b>Obliq</b> is an interpreted, object-oriented programming language designed to make distributed, and locally multithreaded, computing simpler and easier to program, while providing program safety and an implicit type system. The interpreter is written in Modula-3, and provides Obliq with full access to Modula-3's network objects abilities. A type inference algorithm for record concatenation, subtyping, and recursive types has been developed for Obliq. Further, it has been proved to be NP-complete and its lowest complexity to be <span><i>Ο</i>(<i>n</i><sup>3</sup>)</span> or if under other modeling up to certain conditions down to <span><i>Ο</i>(<i>n</i><sup>2</sup>)</span>  and its best known implementation runs in <span><i>Ο</i>(<i>n</i><sup>5</sup>)</span>.\nObliq's syntax is very similar to Modula-3, the biggest difference being that Obliq has no need of explicit typed variables (i.e., a variable can hold any data type allowed by the type checker and if does not accepts one, i.e., a given expression execution error will display) although explicit type declarations are allowed and ignored by the interpreter. The basic data types in the language include booleans, integers, reals, characters, strings, and arrays. Obliq supports the usual set of sequential control structures (conditional, iteration, and exception handling forms), and special control forms for concurrency (mutexes and guarded statements). Further, Obliq's objects can be cloned and safely copied remotely by any machine in a distributed network object and it can be done safely and transparently.</p><p>Obliq's large standard library provides strong support for mathematical operations, input/output (I/O), persistence, thread control, graphics, and animation. Distributed computing is object-based: objects hold a state, which is local to one process. Scope of objects and other variables is purely lexical. Objects can call methods of other objects, even if those objects are on another machine on the network. Obliq objects are simply collections of named fields (similar to slots in Self and Smalltalk), and support inheritance by delegation (like Self).\n</p><p>The common uses of Obliq involve programming over networks, 3D animation, and distributed computing, as occurs over a local area network (LAN) such as Ethernet. Obliq is included free with the Digital Equipment Corporation (DEC) Modula-3 distribution, but other free versions exist elsewhere including precompiled binaries for several operating systems.\n</p>",
        "infobox": {
            "name": "Obliq",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Imperative programming|imperative",
                "Structured programming|structured",
                "Modular programming|modular",
                "Object-oriented programming|object-oriented",
                "Prototype-based programming|prototype-based",
                "Parallel computing|parallel"
            ],
            "family": "Niklaus Wirth|Wirth Oberon (programming language)|Oberon",
            "designers": "Krishna Bharat<br/>Marc H. Brown<br/>Luca Cardelli",
            "released": "1993",
            "typing": [
                "Strong and weak typing|Strong",
                "Dynamic typing|dynamic"
            ],
            "scope": "Lexical scope|Lexical pure",
            "programming language": "Modula-3",
            "platform": "IA-32",
            "website": "www.cc.gatech.edu/gvu/people/Phd/Krishna/VO/VOHome.html",
            "implementations": [
                "Obliq",
                "Visual Obliq"
            ],
            "influenced by": [
                "Modula-3",
                "Self (programming language)|Self",
                "Oberon (programming language)|Oberon"
            ]
        }
    },
    {
        "id": 434,
        "name": "Occam-π",
        "url": "https://en.wikipedia.org/wiki/Occam-%CF%80",
        "summary": "<p><span></span> </p>\n<p>In computer science, <b>occam-π</b> (or <b>occam-pi</b>) is the name of a variant of the programming language occam developed by the Kent Retargetable occam Compiler (KRoC) team at the University of Kent. The name reflects the introduction of elements of π-calculus (pi-calculus) into occam, especially concepts involving mobile agents (processes) and data. The language contains several extensions to occam 2.1, including:\n</p>\n<ul><li>Nested protocols</li>\n<li>Run-time process creation</li>\n<li>Mobile channels, data, and processes</li>\n<li>Recursion</li>\n<li>Protocol inheritance</li>\n<li>Array constructors</li>\n<li>Extended rendezvous</li></ul>",
        "infobox": {
            "name": "occam-π",
            "paradigm": [
                "Imperative programming|Imperative",
                "Procedural programming|procedural",
                "Concurrent computing|concurrent"
            ],
            "designers": [
                "Fred Barnes",
                "Peter Welch"
            ],
            "developers": [
                "occam for all",
                "University of Kent"
            ],
            "platform": [
                "IA-32",
                "Arduino"
            ],
            "influenced by": "occam (programming language)|occam"
        }
    },
    {
        "id": 435,
        "name": "Occam (programming language)",
        "url": "https://en.wikipedia.org/wiki/Occam_(programming_language)",
        "summary": "<p><span></span> </p>\n<p><b>occam</b> is a programming language which is concurrent and builds on the communicating sequential processes (CSP) process algebra, and shares many of its features. It is named after philosopher William of Ockham after whom Occam's razor is named.\n</p><p>occam is an imperative procedural language (such as Pascal). It was developed by David May and others at Inmos (trademark INMOS), advised by Tony Hoare, as the native programming language for their transputer microprocessors, but implementations for other platforms are available. The most widely known version is occam 2; its programming manual was written by Steven Ericsson-Zenith and others at Inmos.\n</p>",
        "infobox": {
            "name": "occam",
            "paradigm": [
                "Imperative programming|Imperative",
                "Procedural programming|procedural",
                "Concurrent computing|concurrent"
            ],
            "designer": "David May (computer scientist)|David May",
            "developer": "Inmos",
            "released": "1983",
            "latest release version": [
                "2.1 (official)",
                "2.5 (unofficial)",
                "3 (not fully implemented)"
            ],
            "latest release date": "1994",
            "dialects": "occam-π (pi)",
            "influenced by": "Communicating sequential processes",
            "influenced": [
                "Ease (programming language)|Ease",
                "Go (programming language)|Go",
                "Python (programming language)|Python"
            ]
        }
    },
    {
        "id": 436,
        "name": "OmniMark",
        "url": "https://en.wikipedia.org/wiki/OmniMark",
        "summary": "<p><b>OmniMark</b> is a fourth-generation programming language used mostly in the publishing industry. It is currently a proprietary software product of Stilo International.  As of September 2018 the most recent release of OmniMark was 10.1.2, dated April 2016. </p>",
        "infobox": "N/A"
    },
    {
        "id": 437,
        "name": "Opa (programming language)",
        "url": "https://en.wikipedia.org/wiki/Opa_(programming_language)",
        "summary": "<p><b>Opa</b> is an open-source programming language for developing scalable web applications. </p><p>It can be used for both client-side and server-side scripting, where complete programs are written in Opa and subsequently compiled to Node.js on the server and JavaScript on the client, with the compiler automating all communication between the two. Opa implements strong, static typing, which can be helpful in protecting against security issues such as SQL injections and cross-site scripting attacks.</p><p>The language was first officially presented at the OWASP conference in 2010, and the source code was released on\nGitHub\nin June 2011, under a GNU Affero General Public License. Later, the license changed to the MIT license for the framework part (library) and AGPL for the compiler so that applications written in Opa can be released under any license, proprietary or open source.\n</p>",
        "infobox": {
            "name": "Opa",
            "logo": "File:Opa logo cloud.png|frameless",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: functional programming|functional",
                "imperative programming|imperative"
            ],
            "year": "2011",
            "typing": [
                "static typing|static",
                "strong typing|strong",
                "type inference|inferred"
            ],
            "developer": "[http://www.linkedin.com/company/mlstate MLstate]",
            "latest_release_version": "1.1.0 (stable)",
            "latest_release_date": "Release date and age|2013|02|13",
            "operating_system": [
                "Linux",
                " OS X",
                "Windows"
            ],
            "genre": "Programming language",
            "influenced_by": [
                "OCaml",
                "Erlang (programming language)|Erlang",
                "JavaScript"
            ],
            "license": [
                "MIT License",
                "Affero General Public License|AGPLv3"
            ],
            "website": "opalang.org"
        }
    },
    {
        "id": 438,
        "name": "Opal (programming language)",
        "url": "https://en.wikipedia.org/wiki/Opal_(programming_language)",
        "summary": "<p><b>OPAL</b> (<b>OP</b>timized <b>A</b>pplicative <b>L</b>anguage) is a functional programming language first developed at the Technical University of Berlin. </p>",
        "infobox": "N/A"
    },
    {
        "id": 439,
        "name": "OpenCL",
        "url": "https://en.wikipedia.org/wiki/OpenCL",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n\n<p><b>OpenCL</b> (<b>Open Computing Language</b>) is a framework for writing programs that execute across heterogeneous platforms consisting of central processing units (CPUs), graphics processing units (GPUs), digital signal processors (DSPs), field-programmable gate arrays (FPGAs) and other processors or hardware accelerators. OpenCL specifies programming languages (based on C99 and C++11) for programming these devices and application programming interfaces (APIs) to control the platform and execute programs on the compute devices. OpenCL provides a standard interface for parallel computing using task- and data-based parallelism.\n</p><p>OpenCL is an open standard maintained by the non-profit technology consortium Khronos Group. Conformant implementations are available from Altera, AMD, Apple (OpenCL along with OpenGL is deprecated for Apple hardware, in favor of Metal 2), ARM, Creative, IBM, Imagination, Intel, Nvidia, Qualcomm, Samsung, Vivante, Xilinx, and ZiiLABS.</p>",
        "infobox": {
            "name": "OpenCL API",
            "title": "OpenCL API",
            "logo": "OpenCL Logo.svg",
            "logo size": "200px",
            "logo alt": "OpenCL logo",
            "author": "Apple Inc.",
            "developer": "Khronos Group",
            "released": "2009|08|28",
            "latest release version": "3.0",
            "latest release date": "2020|04|27",
            "programming language": "C (programming language)|C with C++ bindings",
            "operating system": [
                "Android (operating system)|Android (vendor dependent)",
                "FreeBSD",
                "Linux",
                "macOS",
                "Windows"
            ],
            "platform": [
                "ARMv7",
                "ARMv8",
                "Cell (microprocessor)|Cell",
                "IA-32",
                "IBM POWER microprocessors|POWER",
                "x86-64"
            ],
            "genre": "Heterogeneous computing API",
            "license": "OpenCL specification license",
            "website": "https://www.khronos.org/opencl/"
        }
    },
    {
        "id": 440,
        "name": "OpenEdge Advanced Business Language",
        "url": "https://en.wikipedia.org/wiki/OpenEdge_Advanced_Business_Language",
        "summary": "<p><b>OpenEdge Advanced Business Language</b>, or <b>OpenEdge ABL</b> for short, is a business application development language created and maintained by Progress Software Corporation (PSC). The language, typically classified as a fourth-generation programming language, uses an English-like syntax to simplify software development. The language was called <b>PROGRESS</b> or <b>Progress 4GL</b> up until version 9, but in 2006 PSC changed the name to OpenEdge Advanced Business Language (OpenEdge ABL) in order to overcome a presumed industry perception that 4GLs were less capable than other languages. A subset of the language, called <i>SpeedScript</i>, is used in the development of web applications.</p><p>OpenEdge ABL helps developers to develop applications optionally using its own integrated relational database and programming tool. These applications are portable across computing systems and allow access to various popular data sources without having to learn the underlying data access methods. This means that the end-user of these products can be unaware of the underlying architecture. </p><p>By combining a fourth generation language and relational database, OpenEdge ABL allows the use of the Rapid Application Development (RAD) model for developing software. A programmer and even end users can do rapid prototyping using the integrated and GUI tools of the development environment.\n</p>",
        "infobox": {
            "name": "OpenEdge Advanced Business Language (ABL)",
            "developer": "Progress Software Corporation",
            "latest_release_version": "OpenEdge 12.2",
            "latest_release_date": "start date and age|2020|04|02",
            "operating_system": "Cross-platform (see below)",
            "genre": "Relational database management system|RDBMS",
            "license": "Proprietary",
            "website": "https://www.progress.com/openedge",
            "logo": "File:OpenEdge_logo.png"
        }
    },
    {
        "id": 441,
        "name": "OpenVera",
        "url": "https://en.wikipedia.org/wiki/OpenVera",
        "summary": "<p><b>OpenVera</b> is a hardware verification language developed and managed by Synopsys. OpenVera is an interoperable, open hardware verification language for testbench creation. The OpenVera language was used as the basis for the advanced verification features in the IEEE Std. 1800 SystemVerilog standard, for the benefit of the entire verification community including companies in the semiconductor, systems, IP and EDA industries along with verification services. </p><p>The OpenVera language reference manual (LRM) can be obtained at no cost, but modifications to the language must go through Synopsys.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 442,
        "name": "Open Programming Language",
        "url": "https://en.wikipedia.org/wiki/Open_Programming_Language",
        "summary": "<p><b>Open Programming Language</b> (<b>OPL</b>) is an embedded programming language for portable devices that run the Symbian Operating System. </p>",
        "infobox": {
            "name": "Open Programming Language (OPL)",
            "paradigm": [
                "imperative programming|imperative",
                "structured programming|structured",
                "embedded system|embedded"
            ],
            "year": "1984",
            "designer": "Psion (computers)|Psion Ltd",
            "developer": "opl-dev project",
            "latest_release_version": "1.56 / release date|mf|=|yes|2006|6|17",
            "latest release date": "release date|mf|=|yes|2006|6|17",
            "operating_system": [
                "Symbian OS",
                "Psion Organiser"
            ],
            "website": "opl-dev.sourceforge.net"
        }
    },
    {
        "id": 443,
        "name": "OptimJ",
        "url": "https://en.wikipedia.org/wiki/OptimJ",
        "summary": "<p><b>OptimJ</b> is an extension for Java with language support for writing optimization models and abstractions for bulk data processing. The extensions and the proprietary product implementing the extensions were developed by Ateji which went out of business in September 2011. OptimJ aims at providing a clear and concise algebraic notation for optimization modeling, removing compatibility barriers between optimization modeling and application programming tools, and bringing software engineering techniques such as object-orientation and modern IDE support to optimization experts.\n</p><p>OptimJ models are directly compatible with Java source code, existing Java libraries such as database access, Excel connection or graphical interfaces. OptimJ is compatible with development tools such as Eclipse, CVS, JUnit or JavaDoc. OptimJ is available free with the following solvers: lp_solve, glpk, LP or MPS file formats and also supports the following commercial solvers: Gurobi, MOSEK, IBM ILOG CPLEX Optimization Studio.\n</p>",
        "infobox": {
            "name": "OptimJ",
            "paradigm": "object-oriented programming|object-oriented",
            "released": "2006",
            "designer": "Ateji",
            "influenced by": "Java (programming language)|Java",
            "free download": "[http://www.ateji.com/optimj/freeoptimjdownload.html]",
            "website": "[http://www.ateji.com/ www.Ateji.com]"
        }
    },
    {
        "id": 444,
        "name": "Orc (programming language)",
        "url": "https://en.wikipedia.org/wiki/Orc_(programming_language)",
        "summary": "<p><b>Orc</b> is a concurrent, nondeterministic computer programming language created by Jayadev Misra at the University of Texas at Austin. </p><p>Orc  provides uniform access to computational services, including distributed communication and data manipulation, through sites. Using four simple concurrency primitives, the programmer orchestrates the invocation of sites to achieve a goal, while managing timeouts, priorities, and failures.\n</p>",
        "infobox": {
            "name": "Orc",
            "logo": "File:Orc_programming_language_logo.png",
            "paradigm": [
                "concurrent programming|concurrent",
                "nondeterministic programming|nondeterministic"
            ],
            "year": "2004",
            "designer": "Jayadev Misra",
            "developer": [
                "Jayadev Misra",
                "William Cook (computer scientist)|William R. Cook",
                "David Kitchin",
                "Adrian Quark",
                "John Thywissen",
                "Arthur Peters",
                "and others"
            ],
            "influenced_by": [
                "Haskell (programming language)|Haskell",
                "ML (programming language)|ML",
                "Oz (programming language)|Oz",
                "Smalltalk",
                "Pict (programming language)|Pict"
            ],
            "license": "New BSD License",
            "website": "https://orc.csres.utexas.edu/"
        }
    },
    {
        "id": 445,
        "name": "Oriel (scripting language)",
        "url": "https://en.wikipedia.org/wiki/Oriel_(scripting_language)",
        "summary": "<p><b>Oriel</b> is a scripting language released with the <i>Power Tools</i> series of instructional books written by the LeBlond Group. Described in its documentation as a \"graphics-based batch language\", it was originally designed for Microsoft Windows 3.0 and released with the book <i>Windows 3 Power Tools</i> in 1991. However, versions of the language were also bundled with <i>Windows 3.1 Power Tools</i> in 1992 and <i>Windows NT Power Tools</i> in 1994. </p><p>The suggested extension for an Oriel script file was ORL. Oriel was distributed with two executables: ORIEL.EXE, and MKRUNTIM.EXE. The former was the Oriel interpreter, which when invoked would prompt the user to choose a script file for execution. The latter gave the user the ability to create custom executables by bundling a script within a copy of the interpreter. In this way, an Oriel program could be distributed and run in the same way as any other Windows EXE.\n</p><p>The language was named after the oriel style of bay window. A window of that style is depicted in the icon distributed with the runtime.\n</p>",
        "infobox": {
            "name": "Oriel",
            "logo": "File:The Oriel for Windows Logo.png",
            "paradigm": [
                "Imperative programming|Imperative",
                "Procedural programming|Procedural"
            ],
            "year": "1991",
            "designer": [
                "The LeBlond Group",
                "Inc."
            ],
            "operating_system": "Microsoft Windows"
        }
    },
    {
        "id": 446,
        "name": "Orwell (programming language)",
        "url": "https://en.wikipedia.org/wiki/Orwell_(programming_language)",
        "summary": "<p><b>Orwell</b> is a small, lazy-evaluation functional programming language implemented principally by Martin Raskovsky and first released in 1984 by Philip Wadler during his time as a Research Fellow in the Programming Research Group, part of the Oxford University Computing Laboratory. Developed as a free alternative to Miranda, it was a forerunner of Haskell and was one of the first programming languages to support list comprehensions and pattern matching. </p><p>The name is a tribute to George Orwell's novel <i>Nineteen Eighty-Four</i>, the year in which the programming language was released.  In the late 1980s and the 1990s, most of the computing practical assignments for undergraduates studying for a degree in <i>Mathematics and Computation</i> at Oxford University were required to be completed using the language.\n</p>",
        "infobox": {
            "name": "Orwell",
            "paradigm": [
                "Lazy evaluation|Lazy",
                "Functional programming|functional"
            ],
            "year": "1984",
            "designer": "Philip Wadler",
            "developer": "Martin Raskovsky",
            "influenced_by": "Miranda (programming language)|Miranda",
            "influenced": "Haskell (programming language)|Haskell",
            "operating_system": "Unix"
        }
    },
    {
        "id": 447,
        "name": "Oxygene (programming language)",
        "url": "https://en.wikipedia.org/wiki/Oxygene_(programming_language)",
        "summary": "<p><b>Oxygene</b> (formerly known as <b>Chrome</b>) is a programming language developed by RemObjects Software for Microsoft's Common Language Infrastructure, the Java Platform and Cocoa. Oxygene based on Delphi's Object Pascal, but also has influences from  C#, Eiffel, Java, F# and other languages. </p><p>Compared to the now deprecated Delphi.NET, Oxygene does not emphasize total backward compatibility, but is designed to be a \"reinvention\" of the language, be a good citizen on the managed development platforms, and leverage all the features and technologies provided by the .NET and Java runtimes.\n</p><p>Oxygene is a commercial product, and offers full integration into Microsoft's Visual Studio IDE on Windows, as well as its own IDE, Fire for use on macOS. The command line compiler is available free. Oxygene is one of four languages supported by the underlying Elements Compiler toolchain, next to C#, Swift and Java).\n</p><p>From 2008 to 2012, RemObjects Software licensed its compiler and IDE technology to Embarcadero to be used in their Embarcadero Prism product. Starting in the Fall of 2011, Oxygene became available in two separate editions, with the second edition adding support for the Java and Android runtimes.  Starting with the release of XE4, Embarcadero Prism is no longer part of the RAD Studio SKU. Numerous support and upgrade paths for Prism customers exist to migrate to Oxygene. As of 2016, there is only one edition of Oxygene, which allows development on Windows or macOS, and which can create executables for Windows, Linux, WebAssembly .NET, iOS, Android, Java and macOS.\n</p>",
        "infobox": {
            "name": "Oxygene",
            "logo": "Chrome-128.png",
            "year": "start date and age|2005",
            "developer": "RemObjects Software",
            "influenced_by": [
                "Delphi (Programming Language)|Delphi's Object Pascal",
                "C Sharp (programming language)|C#"
            ],
            "platform": [
                "Common Language Infrastructure",
                "Java (software platform)|Java",
                "Cocoa (API)|Cocoa",
                "CPU-Native",
                "Windows 32/64 bit",
                "Linux 32/64 bit",
                "WebAssembly"
            ],
            "license": "Trialware",
            "website": "http://elementscompiler.com/elements/oxygene/"
        }
    },
    {
        "id": 448,
        "name": "Oz (programming language)",
        "url": "https://en.wikipedia.org/wiki/Oz_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p><p><b>Oz</b> is a multiparadigm programming language, developed in the Programming Systems Lab at Université catholique de Louvain, for programming language education.  It has a canonical textbook: Concepts, Techniques, and Models of Computer Programming.\n</p><p>Oz was first designed by Gert Smolka and his students in 1991.  In 1996, development of Oz continued in cooperation with the research group of Seif Haridi and Peter Van Roy at the Swedish Institute of Computer Science.  Since 1999, Oz has been continually developed by an international group, the Mozart Consortium, which originally consisted of Saarland University, the Swedish Institute of Computer Science, and the Université catholique de Louvain.  In 2005, the responsibility for managing Mozart development was transferred to a core group, the Mozart Board, with the express purpose of opening Mozart development to a larger community.\n</p><p>The Mozart Programming System is the primary implementation of Oz. It is released with an open source license by the Mozart Consortium.  Mozart has been ported to Unix, FreeBSD, Linux, Windows, and macOS.\n</p>",
        "infobox": {
            "name": "Oz",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: logic programming|logic",
                "functional programming|functional",
                "imperative programming|imperative",
                "object-oriented programming|object-oriented",
                "constraint programming|constraint",
                "distributed programming|distributed",
                "concurrent programming language|concurrent"
            ],
            "year": "1991",
            "designer": [
                "Gert Smolka",
                "his students"
            ],
            "developer": "Mozart Consortium",
            "released": "1991",
            "latest release version": [
                "Oz 1.4.0 (final)",
                "Mozart 2.0.1"
            ],
            "latest release date": "2018|09|05",
            "typing": "dynamic typing|dynamic",
            "implementations": "Mozart Programming System",
            "license": "MIT License|MIT X11",
            "dialects": [
                "Oz",
                "Mozart"
            ],
            "influenced by": [
                "Erlang (programming language)|Erlang",
                "Lisp (programming language)|Lisp",
                "Prolog"
            ],
            "influenced": [
                "Alice (programming language)|Alice",
                "Scala (programming language)|Scala"
            ],
            "website": "mozart.github.io"
        }
    },
    {
        "id": 449,
        "name": "P4 (programming language)",
        "url": "https://en.wikipedia.org/wiki/P4_(programming_language)",
        "summary": "<p><b>P4</b> is a programming language for controlling packet forwarding planes in networking devices, such as routers and switches. In contrast to a general purpose language such as C or Python, P4 is a domain-specific language with a number of constructs optimized for network data forwarding.  P4 is distributed as open-source, permissively licensed code, and is maintained by the P4 Language Consortium, a not-for-profit organization. </p>",
        "infobox": {
            "name": "P4",
            "paradigm": [
                "compiled language|compiled",
                "Domain-specific language|domain-specific",
                "imperative programming|imperative"
            ],
            "year": "start date and age|2013",
            "developer": "The P4 Language Consortium",
            "latest_release_version": "version 1.2",
            "latest_release_date": "start date and age|df|=|yes|2019|10|23",
            "license": "Apache Licence|Apache-style",
            "website": "http://p4.org",
            "file_ext": ".p4"
        }
    },
    {
        "id": 450,
        "name": "PARI/GP",
        "url": "https://en.wikipedia.org/wiki/PARI/GP",
        "summary": "<p><b>PARI/GP</b> is a computer algebra system with the main aim of facilitating number theory computations. Versions 2.1.0 and higher are distributed under the GNU General Public License. It runs on most common operating systems. </p>",
        "infobox": {
            "name": "PARI/GP",
            "logo": "PARI-GP logo.svg",
            "screenshot": "PARI-GP-Windows-XP.png",
            "screenshot size": "248px",
            "caption": "PARI/GP in use on Windows XP",
            "developer": [
                "Henri Cohen (number theorist)|Henri Cohen",
                "Karim Belabas",
                "et al.",
                "at the University of Bordeaux|Université Bordeaux 1"
            ],
            "latest release version": "2.11.4",
            "latest release date": "2020|04|17",
            "programming language": "C (programming language)|C",
            "operating_system": "Cross-platform",
            "genre": "Computer algebra system",
            "license": "GNU General Public License",
            "website": "http://pari.math.u-bordeaux.fr/"
        }
    },
    {
        "id": 451,
        "name": "PCASTL",
        "url": "https://en.wikipedia.org/wiki/PCASTL",
        "summary": "<p>The <b>PCASTL</b> (an acronym for <i>by Parent and Childset Accessible Syntax Tree Language</i>) is an interpreted high-level programming language.  It was created in 2008 by Philippe Choquette.  The PCASTL is designed to ease the writing of self-modifying code.  The language has reserved words <b>parent</b> and <b>childset</b> to access the nodes of the syntax tree of the currently written code.</p>",
        "infobox": {
            "designer": "Philippe Choquette",
            "developer": "Philippe Choquette",
            "influenced_by": [
                "C (programming language)|C",
                "R (programming language)|R"
            ],
            "latest_release_version": "3.5",
            "latest_release_date": "2018|03|31",
            "license": "GNU Lesser General Public License",
            "operating_system": "Cross-platform",
            "paradigm": [
                "Imperative programming|imperative",
                "Reflective programming|reflective"
            ],
            "year": "2008",
            "website": "www.pcosmos.ca/pcastl/"
        }
    },
    {
        "id": 452,
        "name": "PEARL (programming language)",
        "url": "https://en.wikipedia.org/wiki/PEARL_(programming_language)",
        "summary": "<p><b>PEARL</b>, or <b>Process and experiment automation realtime language</b>, is a computer programming language designed for multitasking and real-time programming. Being a high-level language, it is fairly cross-platform. Since 1977, the language has been going under several standardization steps by the Deutsches Institut für Normung. The current version is PEARL-90, which was standardized in 1998 as DIN 66253-2. </p>",
        "infobox": "N/A"
    },
    {
        "id": 453,
        "name": "PHP",
        "url": "https://en.wikipedia.org/wiki/PHP",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>PHP</b> is a general-purpose scripting language that is especially suited to web development. It was originally created by Danish-Canadian programmer Rasmus Lerdorf in 1994; the PHP reference implementation is now produced by The PHP Group. PHP originally stood for <i>Personal Home Page</i>, but it now stands for the recursive initialism <i>PHP: Hypertext Preprocessor</i>.</p><p>PHP code is usually processed on a web server by a PHP interpreter implemented as a module, a daemon or as a Common Gateway Interface (CGI) executable.  On a web server, the result of the interpreted and executed PHP code –  which may be any type of data, such as generated HTML or binary image data –  would form the whole or part of a HTTP response.  Various web template systems, web content management systems, and web frameworks exist which can be employed to orchestrate or facilitate the generation of that response. Additionally, PHP can be used for many programming tasks outside of the web context, such as standalone graphical applications and robotic drone control. Arbitrary PHP code can also be interpreted and executed via command-line interface (CLI).\n</p><p>The standard PHP interpreter, powered by the Zend Engine, is free software released under the PHP License. PHP has been widely ported and can be deployed on most web servers on almost every operating system and platform, free of charge.</p><p>The PHP language evolved without a written formal specification or standard until 2014, with the original implementation acting as the <i>de facto</i> standard which other implementations aimed to follow. Since 2014, work has gone on to create a formal PHP specification.</p><p>As of July 2020, over half of sites on the web that use PHP are still on discontinued PHP versions, and well over a third of all websites use version 5.6 or older, that not even Debian supports (while Debian 9 still supports version 7.0 and 7.1 which are also discontinued by The PHP Development Team). In addition, PHP version 7.2, the most popular supported PHP version, will stop getting security updates on November 30, 2020, then unless PHP websites are upgraded to version 7.3, 70% of PHP websites will be on discontinued versions.\n</p>",
        "infobox": {
            "logo": "PHP-logo.svg",
            "logo size": "100px",
            "caption": "PHP: PHP Hypertext Preprocessors",
            "file ext": [
                "<code>.php</code>",
                "<code>.phtml</code>",
                "<code>.php3</code>",
                "<code>.php4</code>",
                "<code>.php5</code>",
                "<code>.php7</code>",
                "<code>.phps</code>",
                "<code>.php-s</code>",
                "<code>.pht</code>",
                "<code>.phar</code>"
            ],
            "paradigm": [
                "imperative programming|Imperative",
                "functional programming|functional",
                "object-oriented programming|object-oriented",
                "procedural programming|procedural",
                "reflective programming|reflective"
            ],
            "released": "start date and age|1995",
            "designer": "Rasmus Lerdorf",
            "developer": [
                "The PHP Development Team",
                "Zend Technologies"
            ],
            "Old Name": "Personal Home Page (PHP)",
            "latest release version": "7.4.8",
            "latest release date": "start date and age|2020|07|09",
            "latest preview version": "8.0.0 Alpha 2",
            "latest preview date": "start date and age|2020|07|09",
            "typing": [
                "dynamic typing|Dynamic",
                "weak typing|weak\n'''since version 7.0:'''\ngradual typing|Gradual"
            ],
            "implementations": [
                "Zend Engine",
                "HHVM",
                "Phalanger (compiler)|Phalanger",
                "Quercus (software)|Quercus",
                "Parrot virtual machine|Parrot"
            ],
            "influenced by": [
                "Perl",
                "HTML",
                "C (programming language)|C",
                "C++",
                "Java (programming language)|Java",
                "Tcl",
                "JavaScript",
                "Hack (programming language)|Hack"
            ],
            "influenced": [
                "Hack (programming language)|Hack",
                "Jakarta Server Pages|JSP",
                "Active Server Pages|ASP"
            ],
            "programming language": "C (programming language)|C (primarily; some components C++)",
            "operating system": [
                "Unix-like",
                "Windows"
            ],
            "license": "PHP License (most of Zend engine under Zend Engine License)",
            "website": "https://www.php.net/",
            "wikibooks": "PHP Programming"
        }
    },
    {
        "id": 454,
        "name": "PILOT",
        "url": "https://en.wikipedia.org/wiki/PILOT",
        "summary": "<p><b>Programmed Instruction, Learning, or Teaching</b> (<b>PILOT</b>) is a simple high-level programming language developed in the 1960s. Like its younger sibling LOGO, it was an early foray into the technology of computer-assisted instruction.\n</p><p>PILOT is an imperative language similar in structure to BASIC and FORTRAN in its basic layout and structure. Its keywords are single characters, <code>T</code> for \"type\" to print text, or <code>A</code> for \"accept\", to input values from the user.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 455,
        "name": "PL-11",
        "url": "https://en.wikipedia.org/wiki/PL-11",
        "summary": "<p><b>PL-11</b> is a high-level machine-oriented programming language for the PDP-11, developed by R.D. Russell of CERN in 1971. Written in Fortran IV, it is similar to PL360 and is cross-compiled on other machines. </p><p>PL-11 was originally developed as part of the Omega project, a particle physics facility operational at CERN (Geneva, Switzerland) during the 1970s. The first version was written for the CII 10070, a clone of the XDS Sigma 7 built in France. Towards the end of the 1970s it was ported to the IBM 370/168, then part of CERN's computer centre.\n</p><p>A report describing the language is available from CERN.</p>",
        "infobox": "N/A"
    },
    {
        "id": 456,
        "name": "PL/0",
        "url": "https://en.wikipedia.org/wiki/PL/0",
        "summary": "<p><b>PL/0</b> is a programming language, intended as an educational programming language, that is similar to but much simpler than Pascal, a general-purpose programming language. It serves as an example of how to construct a compiler. It was originally introduced in the book, <i>Algorithms + Data Structures = Programs</i>, by Niklaus Wirth in 1976. It features quite limited language constructs: there are no real numbers, very few basic arithmetic operations and no control-flow constructs other than \"if\" and \"while\" blocks. While these limitations make writing real applications in this language impractical, it helps the compiler remain compact and simple. </p>",
        "infobox": "N/A"
    },
    {
        "id": 457,
        "name": "PL/C",
        "url": "https://en.wikipedia.org/wiki/PL/C",
        "summary": "<p><b>PL/C</b> is an instructional dialect of the PL/I computer programming language, developed at Cornell University in the 1970s. </p>",
        "infobox": {
            "name": "PL/C",
            "paradigm": [
                "Procedural programming|procedural",
                "imperative programming|imperative",
                "structured programming|structured"
            ],
            "released": "1973",
            "developer": "Cornell University",
            "typing": "Strong typing|strong",
            "influenced by": "PL/I"
        }
    },
    {
        "id": 458,
        "name": "PL/I",
        "url": "https://en.wikipedia.org/wiki/PL/I",
        "summary": "<p><b>PL/I</b> (<b>Programming Language One</b>, pronounced <span></span> and sometimes written <b>PL/1</b>) is a procedural, imperative computer programming language developed and published by IBM. It is designed for scientific, engineering, business and system programming.  It has been used by  academic, commercial and industrial organizations since it was introduced in the 1960s, and is still used.</p><p>PL/I's main domains are data processing, numerical computation, scientific computing, and system programming. It supports recursion, structured programming, linked data structure handling, fixed-point, floating-point, complex, character string handling, and bit string handling. The language syntax is English-like and suited for describing complex data formats with a wide set of functions available to verify and manipulate them. </p>",
        "infobox": {
            "name": "PL/I",
            "paradigm": [
                "Procedural programming|Procedural",
                "imperative programming|imperative",
                "structured programming|structured"
            ],
            "year": "1964",
            "designer": "IBM and the SHARE (computing)|SHARE Language Development Committee",
            "developer": "International Business Machines|IBM",
            "latest release version": "IBM Enterprise PL/I for z/OS 5.3",
            "latest release date": "September 2019",
            "dialects": [
                "PL/M",
                "XPL",
                "PL/P",
                "PL/C",
                "IBM PL/S|PL/S",
                "PL/AS",
                "PL/X",
                "PL-6",
                "PL/8",
                "Early PL/I|EPL",
                "SL/1"
            ],
            "influenced_by": [
                "COBOL",
                "Fortran",
                "ALGOL"
            ],
            "influenced": [
                "CMS-2 (programming language)|CMS-2",
                "SP/k",
                "B (programming language)|B",
                "REXX",
                "AS/400 Control Language",
                "C"
            ],
            "wikibooks": "PL/I"
        }
    },
    {
        "id": 459,
        "name": "PL/M",
        "url": "https://en.wikipedia.org/wiki/PL/M",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p>The <b>PL/M programming language</b> \n(an acronym of <i><b>P</b>rogramming <b>L</b>anguage for <b>M</b>icrocomputers</i>)\nis a high-level language conceived and developed by \nGary Kildall in 1973 for Hank Smith at Intel for its microprocessors.\n</p>",
        "infobox": {
            "name": "PL/M",
            "released": "1973",
            "developer": "Gary Kildall at Microcomputer Applications Associates",
            "influenced by": [
                "ALGOL",
                "PL/I",
                "XPL"
            ]
        }
    },
    {
        "id": 460,
        "name": "PL/P",
        "url": "https://en.wikipedia.org/wiki/PL/P",
        "summary": "<p>The <b>PL/P programming language</b> (an acronym of <i><b>P</b>rogramming <b>L</b>anguage for <b>P</b>rime (computers)</i>) is a mid-level programming language developed by Prime Computer to serve as their second primary system programming language after Fortran IV.  PL/P was a subset of PL/I. </p><p>Additions to the PRIMOS operating system for Prime 50 Series computers were written mostly in PL/P in later years.  Certain PRIMOS modules written in Fortran IV during PRIMOS's early years were rewritten in PL/P.  PL/P was the most widespread compiled programming language used for commercial PRIMOS applications, outpacing the use of the Prime C compiler, the CPL (PRIMOS) scripting language, and the Fortran IV compiler in commercial applications.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 461,
        "name": "PL/SQL",
        "url": "https://en.wikipedia.org/wiki/PL/SQL",
        "summary": "<p><b>PL/SQL</b> (<b>Procedural Language for SQL)</b> is Oracle Corporation's procedural extension for SQL and the Oracle relational database.  PL/SQL is available in Oracle Database (since version 6 - stored PL/SQL procedures/functions/packages/triggers since version 7), Times Ten in-memory database (since version 11.2.1), and IBM DB 2 (since version 9.7).  Oracle Corporation usually extends PL/SQL functionality with each successive release of the Oracle Database. </p><p>PL/SQL includes procedural language elements such as conditions and loops. It allows declaration of constants and variables, procedures and functions, types and variables of those types, and triggers.  It can handle exceptions (run-time errors).  Arrays are supported involving the use of PL/SQL collections.  Implementations from version 8 of Oracle Database onwards have included features associated with object-orientation.  One can create PL/SQL units such as procedures, functions, packages, types, and triggers, which are stored in the database for reuse by applications that use any of the Oracle Database programmatic interfaces.\n</p><p>Historically,  the first public version of PL/SQL definition was in 1995, and the Oracle's inception year ~1992. It implements the ISO SQL/PSM standard.</p>\n\n\n",
        "infobox": "N/A"
    },
    {
        "id": 462,
        "name": "PL360",
        "url": "https://en.wikipedia.org/wiki/PL360",
        "summary": "<p><b>PL360</b> (or PL/360) is a system programming language designed by Niklaus Wirth and written by Niklaus Wirth, Joseph  W.  Wells, Jr., and Edwin Satterthwaite, Jr. for the IBM System/360 computer at Stanford University. A description of PL360 was published in early 1968, although the implementation was probably completed before Wirth left Stanford in 1967.</p>",
        "infobox": "N/A"
    },
    {
        "id": 463,
        "name": "PLANC",
        "url": "https://en.wikipedia.org/wiki/PLANC",
        "summary": "<p><b>PLANC</b> (pronounced as \"plank\") is a high level computer programming language. The acronym stands for <i>Programming LAnguage for Nd Computers</i>. </p><p>Compilers were developed by Norsk Data for several architectures, including the Motorola 68000, 88000, x86, and the Norsk Data NORD-10 minicomputer architecture and ND-500 superminicomputer.\n</p><p>The language  was designed to be platform independent. It was mainly used internally at Norsk Data for writing high level systems software such as the upper parts of the operating systems and compilers.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 464,
        "name": "PLEXIL",
        "url": "https://en.wikipedia.org/wiki/PLEXIL",
        "summary": "<p>PLEXIL (<b>Pl</b>an <b>Ex</b>ecution <b>I</b>nterchange <b>L</b>anguage) is an open source technology for automation, created and currently in development by  NASA. </p>",
        "infobox": {
            "name": "PLEXIL",
            "paradigm": "Multi-paradigm programming language|Multi-paradigm",
            "year": "2005",
            "designer": "NASA",
            "typing": [
                "Type system#Static typing|Static",
                "Type system#Safely and unsafely typed systems|unsafe",
                "Nominative type system|nominative"
            ],
            "implementations": [
                "Robotics",
                "Space missions"
            ],
            "operating_system": [
                "Linux",
                "Mac OS"
            ],
            "license": "Open source",
            "website": "http://plexil.sourceforge.net/"
        }
    },
    {
        "id": 465,
        "name": "PLEX (programming language)",
        "url": "https://en.wikipedia.org/wiki/PLEX_(programming_language)",
        "summary": "<p><b>PLEX</b> (Programming Language for EXchanges) is a special-purpose, concurrent, real-time programming language.  The proprietary PLEX language is closely tied to the architecture of Ericsson's AXE telephone exchanges which it was designed to control. PLEX was developed by Göran Hemdahl at Ericsson in the 1970s,  and it has been continuously evolving since then. PLEX was described in 2008 as \"a cross between Fortran and a macro assembler.\"</p><p>The language has two variants: <i>Plex-C</i> used for the AXE Central Processor (CP) and <i>Plex-M</i> used for Extension Module Regional Processors (EMRP).</p><p>Ericsson started a project in the mid-1980s to create a successor language which resulted in Erlang. According to co-creator Joe Armstrong, \"Erlang was heavily influenced by PLEX and the AXE design.\" Erlang did not replace PLEX, but was used alongside it. </p>",
        "infobox": {
            "name": "Plex",
            "paradigm": [
                "procedural programming|procedural",
                "imperative programming|imperative",
                "concurrent"
            ],
            "released": "1970s",
            "developer": "Göran Hemdahl",
            "dialects": [
                "Plex-C",
                "Plex-M"
            ],
            "influenced": "Erlang (programming language)|Erlang",
            "operating system": "Ericsson APZ",
            "license": "Proprietary software|Proprietary"
        }
    },
    {
        "id": 466,
        "name": "POP-11",
        "url": "https://en.wikipedia.org/wiki/POP-11",
        "summary": "<p><b>POP-11</b> is a reflective, incrementally compiled programming language with many of the features of an interpreted language. It is the core language of the Poplog programming environment developed originally by the University of Sussex, and recently in the School of Computer Science at the University of Birmingham, which hosts the main Poplog website. There is now also a [1] Github Poplog] site with the core source files.  </p><p>POP-11 is an evolution of the language POP-2, developed in Edinburgh University, and features an open stack model (like Forth, among others). It is mainly procedural, but supports declarative language constructs, including a pattern matcher, and is mostly used for research and teaching in artificial intelligence, although it has features sufficient for many other classes of problems. It is often used to introduce symbolic programming techniques to programmers of more conventional languages like Pascal, who find POP syntax more familiar than that of Lisp. One of POP-11's features is that it supports first-class functions.\n</p><p>POP-11 is the core language of the Poplog system. The availability of the compiler and compiler subroutines at run-time (a requirement for incremental compilation) gives it the ability to support a far wider range of extensions (including run-time extensions, such as adding new data-types) than would be possible using only a macro facility. This made it possible for (optional) incremental compilers to be added for Prolog, Common Lisp and Standard ML, which could be added as required to support either mixed language development or development in the second language without using any POP-11 constructs. This made it possible for Poplog to be used by teachers, researchers, and developers who were interested in only one of the languages. The most successful product developed in POP-11 was the Clementine Data-mining system, developed by ISL. After SPSS bought ISL they decided to port Clementine to C++ and Java, and eventually succeeded with great effort (and perhaps some loss of the flexibility provided by the use of an AI language).\n</p><p>POP-11 was for a time available only as part of an expensive commercial package (Poplog), but since about 1999 it has been freely available as part of the Open Source version of Poplog, including various additional packages and teaching libraries. An online version of ELIZA using POP-11 is available at Birmingham.\n</p><p>At the University of Sussex, David Young used POP-11 in combination with C and Fortran to develop a suite of teaching and interactive development tools for image processing and vision, and has made them available in the Popvision extension to Poplog.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 467,
        "name": "POP-2",
        "url": "https://en.wikipedia.org/wiki/POP-2",
        "summary": "<p><b>POP-2</b> (also referred to as <b>POP2</b>) is a programming language developed around 1970 from the earlier language POP-1 (developed by Robin Popplestone in 1968, originally named COWSEL) by Robin Popplestone and Rod Burstall at the University of Edinburgh.  It drew roots from many sources: the languages LISP and ALGOL 60, and theoretical ideas from Peter J. Landin. It used an incremental compiler, which gave it some of the flexibility of an interpreted language, including allowing new function definitions at run time and modification of function definitions while a program was running (both of which are features of dynamic compilation), without the overhead of an interpreted language. </p>",
        "infobox": "N/A"
    },
    {
        "id": 468,
        "name": "POV-Ray",
        "url": "https://en.wikipedia.org/wiki/POV-Ray",
        "summary": "<p>The <b>Persistence of Vision Ray Tracer</b>, most commonly acronymed as <b>POV-Ray</b>, is a cross-platform ray-tracing program that generates images from a text-based scene description. It was originally based on DKBTrace, written by David Kirk Buck and Aaron A. Collins for Amiga computers. There are also influences from the earlier Polyray raytracer because of contributions from its author, Alexander Enzmann. POV-Ray is free and open-source software, with the source code available under the AGPLv3. </p>",
        "infobox": {
            "name": "POV-Ray",
            "logo": "Povray logo sphere.png",
            "author": [
                "David Kirk Buck",
                "Aaron A. Collins",
                "Alexander Enzmann"
            ],
            "developer": "The POV-Team",
            "released": "Nowrap|Start date and age|1991|7|29|ref| name=\"History\"|Cite web |url=http://www.povray.org/documentation/view/3.6.1/10/ |title=POV-Ray: Documentation: 1.1.5.3 A Historic 'Version History' |website=povray.org |access-date=2018-12-19|</ref>|ref| name=\"POV-Ray 25\"|Cite web |url=http://www.povray.org/news/index.php#323 |title=POV-Ray: News |website=povray.org |access-date=2018-12-19|</ref> 1991|7|29",
            "programming language": "C++",
            "operating_system": "Cross-platform",
            "genre": "Ray tracing (graphics)|Ray tracer",
            "license": "AGPLv3",
            "website": "www.povray.org"
        }
    },
    {
        "id": 469,
        "name": "PROIV",
        "url": "https://en.wikipedia.org/wiki/PROIV",
        "summary": "<p><b>PROIV</b> (/proʊ,fʊər/) is a low code development platform, developed and sold by NorthgateArinso, part of the Northgate Information Solutions Group. It has an active community of around 2500 developers and end-users worldwide, ranging from consultants to large multinationals, finance institutions, tax authorities, retailers, engineering companies, media operators and software houses. </p><p>PROIV's usual application domain is database-centric business applications. PROIV has some similarities to languages such as ABAP, FOCUS and RPG.\n</p><p>PROIV programs consist of declarative/non-procedural specifications that control the overall structure of the program and database access and that have an implicit sequence of execution (which PROIV programmers refer to as the timing cycle).  Procedural subroutines can be added by the programmer; these are written in a 3GL-like language which PROIV calls \"Logic\".\n</p><p>Note that in PROIV programs are referred to as \"functions\", which can be confusing as it differs from the more usual use of that term in programming languages.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 470,
        "name": "PROMAL",
        "url": "https://en.wikipedia.org/wiki/PROMAL",
        "summary": "<p><b>PROMAL</b> (<b>PROgrammer's Microapplication Language</b>) is a structured programming language from Systems Management Associates for MS-DOS, Commodore 64, and Apple II. PROMAL features simple syntax, no line numbers, long variable names, functions and procedures with argument passing, real number type, arrays, strings, pointer, and a built-in I/O library. Like ABC and Python, indentation is part of the language syntax. </p><p>The language uses a single-pass compiler to generate byte code that is interpreted when the program is run. Since the memory is very limited on these early home computers, the compiler can compile to/from disk and memory. The software package for C64 includes a full-screen editor and command shell.\n</p><p>See also [Computer Language, Mar 1986, pp. 128–134].\n</p>",
        "infobox": {
            "name": "PROMAL",
            "logo": "File:PROMAL logo.png",
            "paradigm": [
                "Imperative programming|Imperative (Procedural programming|procedural)",
                "structured programming|structured"
            ],
            "year": "1984-08-16",
            "developer": "Systems Management Associates",
            "latest release version": "2.1e",
            "latest release date": "1986-10-14",
            "influenced_by": "C",
            "file_ext": ".s"
        }
    },
    {
        "id": 471,
        "name": "PROSE modeling language",
        "url": "https://en.wikipedia.org/wiki/PROSE_modeling_language",
        "summary": "<p>Author Joseph Thames, now deceased (2019), has left us with his latest version of PROSE, called FortranCalculus.  It is freeware that can be downloaded from https://goal-driven.net/apps/fc-compiler.html .  Joe's www.metacalculus.com website is no longer up.  I worked with Joe since ~1975, he will be missed! Thanks, Phil B Brubaker. </p><p>---\n</p><p>PROSE was the mathematical 4GL virtual machine which established the holistic modeling paradigm known as Synthetic Calculus (AKA MetaCalculus). A successor to the SLANG/CUE simulation and optimization language developed at TRW Systems, it was introduced in 1974 on Control Data supercomputers. It was the first commercial language to employ automatic differentiation (AD), which was optimized to loop in the instruction-stack of the CDC 6600 CPU.\n</p><p>Although PROSE was a rich block-structured procedural language, its focus was the blending of simultaneous-variable <i>mathematical systems</i> such as: \n</p>\n<ul><li>implicit non-linear equations systems,</li>\n<li>ordinary differential-equations systems, and</li>\n<li>multidimensional optimization.</li></ul><p>Each of these kinds of system models were distinct and had operator templates to automate and solve them, added to the procedural syntax. These automated system problems were considered \"holistic\" because their unknowns were simultaneous, and they could not be reduced in formulation to solve piecewise, or by algebra manipulation (e.g. substitution), but had to be solved as wholes. And wholeness also pertained to algorithmic determinacy or mathematical \"closure\", which made solution convergence possible and certain in principle, if not corrupted by numerical instability.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 472,
        "name": "P (programming language)",
        "url": "https://en.wikipedia.org/wiki/P_(programming_language)",
        "summary": "<p><b>P</b> is a programming language for asynchronous event-driven programming and the IoT that was developed by Microsoft and University of California, Berkeley.</p><p>P enables programmers to specify systems consisting of a collection of state machines that communicate asynchronously in terms of events.  Code can be run on Microsoft Windows and Windows Phone, and is now open source licensed under MIT License and available on GitHub.</p> \n\n",
        "infobox": {
            "name": "P",
            "developer": [
                "Ankush Desai",
                "Vivek Gupta: not the politician",
                "Ethan Jackson",
                "Shaz Qadeer",
                "Sriram Rajamani",
                "Microsoft"
            ],
            "latest release date": "2012|11",
            "operating system": "Cross-platform",
            "year": "2012",
            "turing-complete": "Yes",
            "file ext": ".p",
            "license": "MIT License",
            "website": "https://github.com/p-org/P"
        }
    },
    {
        "id": 473,
        "name": "ParaSail (programming language)",
        "url": "https://en.wikipedia.org/wiki/ParaSail_(programming_language)",
        "summary": "<p><b>Parallel Specification and Implementation Language</b> (<b>ParaSail</b>) is an object-oriented parallel programming language.  Its design and ongoing implementation is described in a blog and on its official website.</p><p>ParaSail uses a pointer-free programming model, where objects can grow and shrink, and value semantics are used for assignment.  It has no global garbage collected heap.  Instead, region-based memory management is used throughout. Types can be recursive, so long as the recursive components are declared <i>optional</i>. There are no global variables, no parameter aliasing, and all subexpressions of an expression can be evaluated in parallel. Assertions, preconditions, postconditions, class invariants, etc., are part of the standard syntax, using a Hoare-like notation. Any possible race conditions are detected at compile time.  </p><p>Initial design of ParaSail began in September 2009, by S. Tucker Taft.\n</p><p>Both an interpreter using the ParaSail virtual machine, and an LLVM-based ParaSail compiler are available.  Work stealing is used for scheduling ParaSail's light-weight threads. The latest version can be downloaded from the ParaSail website.</p>",
        "infobox": {
            "name": "ParaSail",
            "logo": "Logo_for_ParaSail_Programming_Language.jpg",
            "logo caption": "Logo designed by Abouzar Abbasi",
            "paradigm": [
                "compiled language|compiled",
                "concurrent programming|concurrent",
                "imperative programming|imperative",
                "structured programming|structured",
                "object-oriented programming|object-oriented"
            ],
            "designer": "S. Tucker Taft",
            "developer": "AdaCore",
            "released": "2009",
            "latest release version": "8.4",
            "latest release date": "2019|11|02",
            "typing": [
                "Strong and weak typing|strong",
                "Type system#Static type checking|static"
            ],
            "platform": "x86",
            "operating system": [
                "Linux",
                "macOS",
                "Microsoft Windows|Windows"
            ],
            "license": "GNU General Public License|GPL v3",
            "file ext": [
                ".psi",
                ".psl"
            ],
            "website": "parasail-lang.org",
            "implementations": [
                "psli",
                "pslc"
            ],
            "influenced by": [
                "Modula",
                "Ada (programming language)|Ada",
                "Pascal (programming language)|Pascal",
                "ML (programming language)|ML"
            ]
        }
    },
    {
        "id": 474,
        "name": "Parallax Propeller",
        "url": "https://en.wikipedia.org/wiki/Parallax_Propeller",
        "summary": "<p>The <b>Parallax P8X32A Propeller</b> is a multi-core processor parallel computer architecture microcontroller chip with eight 32-bit reduced instruction set computer (RISC) central processing unit (CPU) cores. Introduced in 2006, it is designed and sold by Parallax, Inc. </p><p>The Propeller microcontroller, Propeller assembly language, and Spin interpreter were designed by Parallax's cofounder and president, Chip Gracey. The Spin programming language and <i>Propeller Tool</i> integrated development environment (IDE) were designed by Chip Gracey and Parallax's software engineer Jeff Martin.\n</p><p>On August 6, 2014, Parallax Inc., released all of the Propeller 1 P8X32A hardware and tools as open-source hardware and software under the GNU General Public License (GPL) 3.0. This included the Verilog code, top-level hardware description language (HDL) files, Spin interpreter, PropellerIDE and SimpleIDE programming tools and compilers.</p>",
        "infobox": "N/A"
    },
    {
        "id": 475,
        "name": "Pascal (programming language)",
        "url": "https://en.wikipedia.org/wiki/Pascal_(programming_language)",
        "summary": "<p><b>Pascal</b> is an imperative and procedural programming language, designed by Niklaus Wirth as a small, efficient language intended to encourage good programming practices using structured programming and data structuring. It is named in honour of the French mathematician, philosopher and physicist Blaise Pascal. </p><p>Based on Wirth's book, <i>Algorithms + Data Structures = Programs</i>, Pascal was developed on the pattern of the ALGOL 60 language. Wirth was involved in the process to improve the language as part of the ALGOL X efforts and proposed a version known as ALGOL W. This was not accepted, and the ALGOL X process bogged down. In 1968, Wirth decided to abandon the ALGOL X process and further improve ALGOL W, releasing this as Pascal in 1970.\n</p><p>On top of ALGOL's scalars and arrays, Pascal enabled defining complex datatypes and building dynamic and recursive data structures such as lists, trees and graphs. Pascal has strong typing on all objects, which means that one type of data cannot be converted or interpreted as another without explicit conversions. Unlike C (and most languages in the C-family), Pascal allows nested procedure definitions to any level of depth, and also allows most kinds of definitions and declarations inside subroutines (procedures and functions). A program is thus syntactically similar to a single procedure or function. This is similar to the block structure of ALGOL 60, but restricted from arbitrary block statements to just procedures and functions.\n</p><p>Pascal became very successful in the 1970s, notably on the burgeoning minicomputer market. Compilers were also available for many microcomputers as the field emerged in the late 1970s. It was widely used as a teaching language in university-level programming courses in the 1980s, and also used in production settings for writing commercial software during the same period. It was displaced by the C programming language during the late 1980s and early 1990s as UNIX-based systems became popular, and especially with the release of C++.\n</p><p>A derivative known as Object Pascal designed for object-oriented programming was developed in 1985; this was used by Apple Computer and Borland in the late 1980s and later developed into Delphi on the Microsoft Windows platform. Extensions to the Pascal concepts led to the languages Modula-2 and Oberon.\n</p>",
        "infobox": {
            "name": "Pascal",
            "screenshot": "LagrangePAS.jpg",
            "paradigm": "hlist |Imperative programming|Imperative |Structured programming|structured",
            "family": "Niklaus Wirth|Wirth Pascal",
            "designer": "Niklaus Wirth",
            "released": "1970",
            "typing": "hlist |Static typing|Static |Strong and weak typing|strong |type system#Type safety and memory safety|safe",
            "implementations": "hlist |CDC 6000 |Delphi (programming language)|Embarcadero Delphi |ICT 1900 series|ICL 1900 |Pascal-P |PDP-11 |PDP-10 |IBM System/370 |VSI Pascal |Free Pascal |GNU Pascal",
            "dialects": "hlist |Delphi (programming language)|Delphi |Turbo Pascal |UCSD Pascal",
            "influenced by": "startflatlist * ALGOL W\n* Simula 67",
            "influenced": "startflatlist * Ada (programming language)|Ada\n* Component Pascal\n* Go (programming language)|Go\n* Java (programming language)|Java * Modula \\ Modula-2|-2 \\ Modula-3|-3\n* Oberon (programming language)|Oberon \\ Oberon-2 (programming language)|-2\n* Object Pascal\n* Oxygene (programming language)|Oxygene\n* Seed7\n* Turbo Rascal Syntax Error\n* VHDL\n* Structured text endflatlist",
            "file ext": [
                "<code>.pp</code>",
                "<code>.pas</code>",
                "<code>.inc</code>,"
            ]
        }
    },
    {
        "id": 476,
        "name": "Pascal Script",
        "url": "https://en.wikipedia.org/wiki/Pascal_Script",
        "summary": "<p><b>Pascal Script</b> is a scripting language based on the programming language Pascal that facilitates automated runtime control over scriptable applications and server software. It is implemented by a free scripting engine that includes a compiler and an interpreter for byte code. </p><p>Pascal Script supports the majority of Object Pascal constructs, making it partly compatible to Delphi, Free Pascal and GNU Pascal.\n</p><p>Initially developed by Carlo Kok as CajScript and renamed to Innerfuse Pascal Script with version 2.23, the software was taken over by RemObjects, renamed again to RemObjects Pascal Script and offered as open source software for the Delphi IDE. Beginning with version 2.07 CajScript has been ported to Free Pascal. Since 2017 Pascal Script is included as a standard component in the Lazarus IDE.\n</p>",
        "infobox": {
            "name": "Pascal Script",
            "developer": [
                "Carlo Kok",
                "Innerfuse",
                "RemObjects Software|RemObjects",
                "Lazarus (IDE)|Lazarus and Free Pascal teams"
            ],
            "screenshot": "Pascal Script 3 Lazarus IDE.png",
            "description": "Screenshot of a simple demonstration script",
            "year": "2000",
            "paradigm": [
                "Procedural programming|Procedural",
                "Object-oriented programming|object-oriented",
                "Scripting language|scripting"
            ],
            "typing": "strong typing|Strong",
            "latest_release_version": "3.0",
            "operating_system": [
                "Linux",
                "macOS",
                "Windows"
            ],
            "genre": "Scripting language",
            "license": "Custom open-source license",
            "influenced_by": [
                "Pascal (programming language)|Pascal",
                "Object Pascal"
            ],
            "file_ext": ".pas"
        }
    },
    {
        "id": 477,
        "name": "PeopleCode",
        "url": "https://en.wikipedia.org/wiki/PeopleCode",
        "summary": "<p><b>PeopleCode</b> is a proprietary object-oriented programming language used to express business logic for PeopleSoft applications. Syntactically, PeopleCode is similar to other programming languages, and can be found in both loosely-typed and strongly-typed forms. PeopleCode and its run-time environment is part of the larger PeopleTools framework. PeopleCode has evolved over time and its implementation through the PeopleSoft applications lack consistency. PeopleCode offers some interoperability with the Java programming language. Definition name references, for example, enable you to refer to PeopleTools definitions, such as record definitions or pages, without using hard-coded string literals. Other language features, such as PeopleCode data types and metastrings, reflect the close interaction of PeopleTools and Structured Query Language (SQL). Dot notation, classes and methods in PeopleCode are similar to other object oriented languages, like Java. Object syntax was an important feature of PeopleTools 8.</p>",
        "infobox": {
            "name": "PeopleCode",
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Object-oriented programming|object-oriented",
                "Imperative programming|imperative"
            ],
            "developer": "Oracle Corporation"
        }
    },
    {
        "id": 478,
        "name": "Perl",
        "url": "https://en.wikipedia.org/wiki/Perl",
        "summary": "<p class=\"mw-empty-elt\"> \n</p>\n<p><b>Perl</b> is a family of two high-level, general-purpose, interpreted, dynamic programming languages. \"Perl\" refers to Perl 5, but from 2000 to 2019 it also referred to its redesigned \"sister language\", Perl 6, before the latter's name was officially changed to Raku in October 2019.</p><p>Though Perl is not officially an acronym, there are various backronyms in use, including \"Practical Extraction and Reporting Language\". Perl was originally developed by Larry Wall in 1987 as a general-purpose Unix scripting language to make report processing easier. Since then, it has undergone many changes and revisions. Raku, which began as a redesign of Perl 5 in 2000, eventually evolved into a separate language. Both languages continue to be developed independently by different development teams and liberally borrow ideas from one another.\n</p><p>The Perl languages borrow features from other programming languages including C, shell script (sh), AWK, and sed; Wall also alludes to BASIC and Lisp in the introduction to <i>Learning Perl</i> (Schwartz &amp; Christiansen) and so on. They provide text processing facilities without the arbitrary data-length limits of many contemporary Unix command line tools, facilitating manipulation of text files. Perl 5 gained widespread popularity in the late 1990s as a CGI scripting language, in part due to its unsurpassed regular expression and string parsing abilities.</p><p>In addition to CGI, Perl 5 is used for system administration, network programming, finance, bioinformatics, and other applications, such as for GUIs. It has been nicknamed \"the Swiss Army chainsaw of scripting languages\" because of its flexibility and power, and also its ugliness. In 1998, it was also referred to as the \"duct tape that holds the Internet together,\" in reference to both its ubiquitous use as a glue language and its perceived inelegance.</p><p>Perl has been rated as the most expressive programming language.</p>",
        "infobox": {
            "name": "Perl",
            "logo": "Programming-republic-of-perl.png",
            "paradigm": [
                "Multi-paradigm: Functional programming|functional",
                "Imperative programming|imperative",
                "Object-oriented programming|object-oriented (Class-based programming|class-based)",
                "Reflective programming|reflective"
            ],
            "designer": "Larry Wall",
            "developer": "Larry Wall",
            "typing": "Dynamic",
            "influenced": [
                "CoffeeScript",
                "January 2016 Groovy (programming language)|Groovy",
                "February 2016 JavaScript",
                "Julia (programming language)|Julia",
                "LPC (programming language)|LPC",
                "PHP",
                "Python (programming language)|Python",
                "Raku (programming language)|Raku",
                "Ruby (programming language)|Ruby",
                "PowerShell"
            ],
            "license": "Artistic License 1.0 or GNU General Public License",
            "website": "url|https://www.perl.org",
            "wikibooks": "Perl Programming",
            "year": "1987|12|18",
            "latest_release_version": "Unbulleted list\n\n|5.32.0|ref|cite web|url = https://www.nntp.perl.org/group/perl.perl5.porters/2020/06/msg257547.html |title = Perl 5.32.0 is now available! |accessdate = 2020-06-20 |publisher = www.nntp.perl.org |</ref>| / |Start date and age|mf|=|yes|2020|06|20|df|=|yes|\n\n|5.30.3|ref|cite web|url = https://www.nntp.perl.org/group/perl.perl5.porters/2020/06/msg257498.html |title = Perl 5.30.3 is now available! |accessdate = 2020-06-02 |publisher = www.nntp.perl.org |</ref>| / |Start date and age|mf|=|yes|2020|06|01|df|=|yes| / mf|=|yes|2020|06|20 / mf|=|yes|2020|06|01",
            "latest_preview_version": "5.33.0",
            "latest_preview_date": "mf|=|yes|2020|07|17",
            "turing-complete": "Yes",
            "influenced_by": [
                "AWK (programming language)|AWK",
                "BASIC",
                "C (programming language)|C",
                "C++",
                "Lisp (programming language)|Lisp",
                "sed",
                "Unix shell"
            ],
            "programming_language": "C (programming language)|C",
            "operating_system": "Cross-platform",
            "file_ext": [
                ".plx",
                ".pl",
                ".pm",
                ".xs",
                ".t",
                ".pod"
            ]
        }
    },
    {
        "id": 479,
        "name": "Perl Data Language",
        "url": "https://en.wikipedia.org/wiki/Perl_Data_Language",
        "summary": "<p><b>Perl Data Language</b> (abbreviated <b>PDL</b>) is a set of free software array programming extensions to the Perl programming language. PDL extends the data structures built into Perl, to include large multidimensional arrays, and adds functionality to manipulate those arrays as vector objects. It also provides tools for image processing, machine learning, computer modeling of physical systems, and graphical plotting and presentation. Simple operations are automatically vectorized across complete arrays, and higher-dimensional operations (such as matrix multiplication) are supported. </p>",
        "infobox": {
            "name": "Perl Data Language (PDL)",
            "paradigm": "Array programming|Array",
            "released": "1996",
            "developer": [
                "Karl Glazebrook",
                "Jarle Brinchmann",
                "Tuomas Lukka",
                "and Christian Soeller"
            ],
            "latest_release_version": "2.020",
            "latest_release_date": "2019|12|12",
            "influenced by": [
                "APL (programming language)|APL",
                "IDL (programming language)|IDL",
                "Perl"
            ],
            "operating_system": "Cross-platform",
            "license": [
                "GNU General Public License",
                "Artistic License"
            ],
            "website": "http://pdl.perl.org/"
        }
    },
    {
        "id": 480,
        "name": "Pharo",
        "url": "https://en.wikipedia.org/wiki/Pharo",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n\n<p><b>Pharo</b> is an open source dynamic and reflective language which is inspired by the programming language Smalltalk. Pharo offers several live programming features such as immediate object manipulation, live update and hot recompiling.\n</p>",
        "infobox": {
            "name": "Pharo",
            "title": "Pharo",
            "screenshot": "Pharo 6.0.jpg",
            "caption": "Screenshot of the Pharo IDE",
            "author": "Pharo board",
            "developer": "Pharo community",
            "released": "2008",
            "latest release version": "8.0",
            "latest release date": "2020|01|20",
            "status": "Active",
            "programming language": "Smalltalk",
            "operating system": [
                "Microsoft Windows|Windows",
                "Linux",
                "macOS",
                "others"
            ],
            "genre": [
                "Object-oriented programming language",
                "Integrated development environment|IDE"
            ],
            "license": [
                "MIT license",
                "partly Apache License 2.0"
            ],
            "website": "https://pharo.org",
            "influenced by": "Smalltalk (Squeak)"
        }
    },
    {
        "id": 481,
        "name": "Pico (programming language)",
        "url": "https://en.wikipedia.org/wiki/Pico_(programming_language)",
        "summary": "<dl><dd><i>See also Pico (disambiguation).</i></dd></dl><p><b>Pico</b> is a programming language developed at the Software Languages Lab at Vrije Universiteit Brussel. The language was created to introduce the essentials of programming to non-computer science students. </p><p>Pico can be seen as an effort to generate a palatable and enjoyable language for people who do not want to study hard for the elegance and power of a language. They have done it by adapting Scheme's semantics.\n</p><p>While designing Pico, the Software Languages Lab was inspired by the Abelson and Sussman's book \"Structure and Interpretation of Computer Programs\". Furthermore, they were influenced by the teaching of programming at high school or academic level.\n</p><p>Pico should be interpreted as 'small', the idea was to create a small language for educational purposes.\n</p>",
        "infobox": {
            "name": "Pico",
            "paradigm": [
                "reflection (computer science)|Reflective",
                "procedural programming|procedural"
            ],
            "released": "1997",
            "developer": "Vrije Universiteit Brussel",
            "influenced by": "Scheme (programming language)|Scheme",
            "website": "pico.vub.ac.be"
        }
    },
    {
        "id": 482,
        "name": "Picolisp",
        "url": "https://en.wikipedia.org/wiki/PicoLisp",
        "summary": "<p><b>PicoLisp</b> is a programming language, a dialect of the language Lisp. It runs on operating systems including Linux and others that are <i>Portable Operating System Interface</i> (POSIX) compliant. Its most prominent features are simplicity and minimalism. It is built on one internal data type: a cell. On the language level, a programmer can use three different data types (numbers, symbols, and lists) being represented by cells and differentiated by bits at the end of the cell. It is free and open-source software released under an MIT License (X11). </p>",
        "infobox": {
            "name": "PicoLisp",
            "logo": "PicoLisp Logo.svg",
            "paradigms": [
                "Functional programming|Functional",
                "Procedural programming|procedural",
                "Object-oriented programming|object-oriented",
                "Declarative programming|declarative",
                "Reflective programming|reflective",
                "Metaprogramming|meta"
            ],
            "family": "Lisp (programming language)|Lisp",
            "designer": "Alexander Burger",
            "released": "1988",
            "latest release version": "20.6",
            "latest release date": "2020|6|20",
            "typing": [
                "Duck typing|duck",
                "Dynamic typing|dynamic",
                "Strong typing|strong"
            ],
            "programming language": [
                "C (programming language)|C",
                "Assembly language|assembly",
                "PicoLisp"
            ],
            "platform": [
                "IA-32",
                "x86-64",
                "Arm64"
            ],
            "operating system": "POSIX",
            "license": "MIT License|MIT",
            "file ext": ".l",
            "website": "picolisp.com",
            "dialects": [
                "Ersatz PicoLisp",
                "miniPicoLisp"
            ]
        }
    },
    {
        "id": 483,
        "name": "Pict (programming language)",
        "url": "https://en.wikipedia.org/wiki/Pict_(programming_language)",
        "summary": "<p><b>Pict</b> is a statically typed programming language, one of the very few based on the π-calculus. Work on the language began at the University of Edinburgh in 1992, and development has been more or less dormant since 1998. The language is still at an experimental stage. </p>",
        "infobox": {
            "name": "Pict",
            "paradigm": "Concurrent Programming|Concurrent",
            "developer": "Benjamin C. Pierce and David N. Turner",
            "typing": "Type system|Static",
            "license": "GNU General Public License",
            "file ext": ".pi",
            "website": "https://www.cis.upenn.edu/~bcpierce/papers/pict/Html/Pict.html",
            "influenced by": "ML (programming language)|ML",
            "influenced": [
                "Orc (programming language)|Orc",
                "Nomadic Pict"
            ]
        }
    },
    {
        "id": 484,
        "name": "Pig (programming tool)",
        "url": "https://en.wikipedia.org/wiki/Apache_Pig",
        "summary": "<p><b>Apache Pig</b> is a high-level platform for creating programs that run on Apache Hadoop. The language for this platform is called <b>Pig Latin</b>.  Pig can execute its Hadoop jobs in MapReduce, Apache Tez, or Apache Spark.  Pig Latin abstracts the programming from the Java MapReduce idiom into a notation which makes MapReduce programming high level, similar to that of SQL for relational database management systems. Pig Latin can be extended using user-defined functions (UDFs) which the user can write in Java, Python, JavaScript, Ruby or Groovy and then call directly from the language.\n</p>",
        "infobox": {
            "name": "Apache Pig",
            "logo": "File:Apache_Pig_Logo.svg|250px|Apache Pig Logo",
            "developer": [
                "Apache Software Foundation",
                "Yahoo!|Yahoo Research"
            ],
            "released": "2008|09|11",
            "latest release version": "0.17.0",
            "latest release date": "2017|06|19",
            "operating system": [
                "Microsoft Windows",
                "OS X",
                "Linux"
            ],
            "genre": "Data analytics",
            "license": "Apache License 2.0",
            "website": "https://pig.apache.org"
        }
    },
    {
        "id": 485,
        "name": "Pike (programming language)",
        "url": "https://en.wikipedia.org/wiki/Pike_(programming_language)",
        "summary": "<p><b>Pike</b> is an interpreted, general-purpose, high-level, cross-platform, dynamic programming language, with a syntax similar to that of C. Unlike many other dynamic languages, Pike is both statically and dynamically typed, and requires explicit type definitions. It features a flexible type system that allows the rapid development and flexible code of dynamically typed languages, while still providing some of the benefits of a statically typed language. </p><p>Pike features garbage collection, advanced data types, and first-class anonymous functions, with support for many programming paradigms, including object-oriented, functional and imperative programming. Pike is free software, released under the GPL, LGPL and MPL licenses.\n</p>",
        "infobox": {
            "name": "Pike",
            "logo": "Pike Programming Language Logo.svg",
            "logo size": "frameless",
            "logo alt": "Logo for the Pike programming language.",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm: Object-oriented programming|object-oriented",
                "functional programming|functional",
                "procedural programming|procedural"
            ],
            "year": "1994",
            "designer": "Fredrik Hübinette",
            "developer": "Pike development team supported by the Software and Systems division of the Department of Computer and Information Science (IDA) at Linköping University",
            "latest_release_version": "8.0.702",
            "latest_release_date": "2018|11|01",
            "typing": [
                "static typing|Static",
                "dynamic typing|dynamic",
                "manifest typing|manifest"
            ],
            "implementations": "Pike",
            "influenced_by": [
                "LPC (programming language)|LPC",
                "C (programming language)|C",
                "C++"
            ],
            "license": "GNU General Public License|GPL/GNU Lesser General Public License|LGPL/Mozilla Public License|MPL",
            "website": "Official URL",
            "operating system": [
                "Any Unix-like",
                "Microsoft Windows|Windows"
            ],
            "status": "Active"
        }
    },
    {
        "id": 486,
        "name": "Pizza (programming language)",
        "url": "https://en.wikipedia.org/wiki/Pizza_(programming_language)",
        "summary": "<p><b>Pizza</b> is an open-source superset of Java 1.4, prior to the introduction of generics for the Java programming language.  In addition to its own solution for adding generics to the language, Pizza also added function pointers and algebraic types with case classes and pattern matching. </p><p>In August 2001, the developers made a compiler capable of working with Java.  Most Pizza applications can run in a Java environment, but certain cases will cause problems.\n</p><p>Work on Pizza more or less stopped in 2002.  Its main developers turned their focus afterwards to the Generic Java project: another attempt to add generics to Java that was officially adopted as of\nversion 5 of the language. The pattern matching and other functional programming-like features have been further developed in the Scala programming language. \nMartin Odersky remarked, \"we wanted to integrate the functional and object-oriented parts in a cleaner way than what we were able to achieve before with the Pizza language. [...] In Pizza we did a clunkier attempt, and in Scala I think we achieved a much smoother integration between the two.\"</p>",
        "infobox": {
            "name": "Pizza",
            "paradigm": [
                "Generic programming|generics",
                "algebraic types"
            ],
            "influenced_by": "Java (programming language)|Java",
            "influenced": [
                "Generic Java",
                "Scala programming language|Scala"
            ],
            "website": "pizzacompiler.sourceforge.net"
        }
    },
    {
        "id": 487,
        "name": "Plankalkül",
        "url": "https://en.wikipedia.org/wiki/Plankalk%C3%BCl",
        "summary": "<p><b>Plankalkül</b> (<small>German pronunciation: </small><span title=\"Representation in the International Phonetic Alphabet (IPA)\">[ˈplaːnkalkyːl]</span>) is a programming language designed for engineering purposes by Konrad Zuse  between 1942 and 1945. It was the first high-level programming language to be designed for a computer. </p><p><i>Kalkül</i> is the German term for a formal system—as in <i>Hilbert-Kalkül</i>, the original name for the Hilbert-style deduction system—so <i>Plankalkül</i> refers to a formal system for planning.</p>",
        "infobox": {
            "name": "Plankalkül",
            "paradigm": "Procedural programming|Procedural",
            "released": "start date and age|1948 – concept first published",
            "designer": "Konrad Zuse",
            "implementations": "''Plankalkül-Compiler'' by the Free University of Berlin|FU Berlin in 2000",
            "influenced_by": "Begriffsschrift",
            "influenced": [
                "Superplan by Heinz Rutishauser",
                "<br> ALGOL 58"
            ]
        }
    },
    {
        "id": 488,
        "name": "Planner (programming language)",
        "url": "https://en.wikipedia.org/wiki/Planner_(programming_language)",
        "summary": "<p><b>Planner</b> (often seen in publications as \"PLANNER\" although it is not an acronym) is a programming language designed by Carl Hewitt at MIT, and first published in 1969.  First, subsets such as Micro-Planner and Pico-Planner were implemented, and then essentially the whole language was implemented as <i>Popler</i> by Julian Davies at the University of Edinburgh in the POP-2 programming language. Derivations such as QA4, Conniver, QLISP and Ether (see scientific community metaphor) were important tools in artificial intelligence research in the 1970s, which influenced commercial developments such as KEE and ART. </p>",
        "infobox": {
            "name": "Planner",
            "released": "1969",
            "designer": "Carl Hewitt"
        }
    },
    {
        "id": 489,
        "name": "Plus (programming language)",
        "url": "https://en.wikipedia.org/wiki/Plus_(programming_language)",
        "summary": "<p><b>Plus</b> is a \"Pascal-like\" system implementation language from the University of British Columbia (UBC), Canada, based on the SUE system language developed at the University of Toronto, c. 1971.</p><p>There is another programming language named PLUS, developed at Sperry Univac in Roseville, Minnesota, but the Univac PLUS is not the subject of this article. </p>",
        "infobox": {
            "name": "Plus",
            "paradigm": [
                "imperative programming|imperative",
                "structured programming|structured"
            ],
            "typing": [
                "Type system#Static typing|static",
                "Type system#Strong and weak typing|strong",
                "Type system#Safely and unsafely typed systems|safe"
            ],
            "implementations": [
                "IBM System/370",
                "Digital Equipment Corporation|DEC PDP-11",
                "and Motorola 68000"
            ],
            "year": "1976",
            "developer": "Alan Ballard and Paul Whaley at University of British Columbia|UBC",
            "influenced_by": [
                "SUE",
                "Pascal"
            ],
            "operating_system": [
                "Michigan Terminal System (MTS)",
                "OS/VS1"
            ]
        }
    },
    {
        "id": 490,
        "name": "Polymorphic Programming Language",
        "url": "https://en.wikipedia.org/wiki/Polymorphic_Programming_Language",
        "summary": "<p>The <b>Polymorphic Programming Language</b> (<b>PPL</b>) was developed in 1969 at Harvard University by Thomas A. Standish. It is an interactive, extensible language with a base language similar to the language APL.</p><p>The assignment operator <code>&lt;-</code> (or <code>←</code>) has influenced the language S.</p>",
        "infobox": "N/A"
    },
    {
        "id": 491,
        "name": "PostScript",
        "url": "https://en.wikipedia.org/wiki/PostScript",
        "summary": "<p><b>PostScript</b> (<b>PS</b>) is a page description language in the electronic publishing and desktop publishing business.  It is a dynamically typed, concatenative programming language and was created at Adobe Systems by John Warnock, Charles Geschke, Doug Brotz, Ed Taft and Bill Paxton from 1982 to 1984. </p>",
        "infobox": {
            "name": "PostScript",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: stack-based",
                "Procedural programming|procedural"
            ],
            "year": "1982",
            "designer": [
                "John Warnock",
                "Chuck Geschke",
                "Doug Brotz",
                "Ed Taft",
                "Bill Paxton (computer scientist)|Bill Paxton"
            ],
            "developer": "Adobe Systems",
            "latest release version": "PostScript 3",
            "latest release date": "1997",
            "turing-complete": "Yes",
            "typing": [
                "Dynamic",
                "strong"
            ],
            "implementations": [
                "Adobe PostScript",
                "TrueImage",
                "Ghostscript"
            ],
            "influenced_by": [
                "Mesa (programming language)|Mesa",
                "Interpress",
                "Lisp (programming language)|Lisp"
            ],
            "influenced": "Portable Document Format|PDF"
        }
    },
    {
        "id": 492,
        "name": "PowerBuilder",
        "url": "https://en.wikipedia.org/wiki/PowerBuilder",
        "summary": "<p><b>PowerBuilder</b> is an integrated development environment owned by SAP since the acquisition of Sybase in 2010.  On July 5, 2016, SAP and Appeon entered into an agreement whereby Appeon would be responsible for developing, selling, and supporting PowerBuilder.</p><p>Over the years, PowerBuilder has been updated with new standards.  In 2010, a major upgrade of PowerBuilder was released to provide support for the Microsoft .NET Framework.  In 2014, support was added for OData, dockable windows, and 64-bit native applications.  In 2017, support was added for iOS and Android app development.</p><p>PowerBuilder 2019 provides new targets to enable developers to rapidly create RESTful Web APIs and non-visual .NET assemblies, in a test-driven manner, using the C# language and the .NET Core framework. And PowerScript client app development was revamped with new UI technologies and cloud architecture.</p>",
        "infobox": {
            "name": "Appeon PowerBuilder",
            "logo": "PowerBuilder 2017 Logo.png",
            "logo size": "75px",
            "caption": [
                "Screenshot of PowerBuilder 2017",
                "editing a REST Web API call"
            ],
            "developer": "SAP AG|SAP/Appeon",
            "released": "July 1992",
            "latest release version": "PowerBuilder 2019 R2",
            "latest release date": [
                "April 3",
                "2020"
            ],
            "latest preview version": "None",
            "programming language": "C++ and C Sharp (programming language)|C#",
            "operating system": "Microsoft Windows",
            "language": [
                "English",
                "Japanese for the IDE (numerous languages supported for deployed applications)"
            ],
            "genre": "Integrated development environment|IDE",
            "license": "Commerce|Commercial"
        }
    },
    {
        "id": 493,
        "name": "PowerShell",
        "url": "https://en.wikipedia.org/wiki/PowerShell",
        "summary": "<p><b>PowerShell</b> is a task automation and configuration management framework from Microsoft, consisting of a command-line shell and associated scripting language. Initially a Windows component only, known as <b>Windows PowerShell</b>, it was made open-source and cross-platform on 18 August 2016 with the introduction of <b>PowerShell Core</b>. The former is built on the .NET Framework, the latter on .NET Core. </p><p>In PowerShell, administrative tasks are generally performed by <i>cmdlets</i> (pronounced <i>command-lets</i>), which are specialized .NET classes implementing a particular operation. These work by accessing data in different data stores, like the file system or registry, which are made available to PowerShell via <i>providers</i>. Third-party developers can add cmdlets and providers to PowerShell. Cmdlets may be used by <i>scripts</i> and scripts may be packaged into <i>modules</i>.\n</p><p>PowerShell provides full access to COM and WMI, enabling administrators to perform administrative tasks on both local and remote Windows systems as well as WS-Management and CIM enabling management of remote Linux systems and network devices. PowerShell also provides a hosting API with which the PowerShell runtime can be embedded inside other applications. These applications can then use PowerShell functionality to implement certain operations, including those exposed via the graphical interface. This capability has been used by Microsoft Exchange Server 2007 to expose its management functionality as PowerShell cmdlets and providers and implement the graphical management tools as PowerShell hosts which invoke the necessary cmdlets. Other Microsoft applications including Microsoft SQL Server 2008 also expose their management interface via PowerShell cmdlets.</p><p>PowerShell includes its own extensive, console-based help (similar to man pages in Unix shells) accessible via the <code>Get-Help</code> cmdlet. Updated local help contents can be retrieved from the Internet via the <code>Update-Help</code> cmdlet. Alternatively, help from the web can be acquired on a case-by-case basis via the <code class=\"nowrap\">-online</code> switch to <code>Get-Help</code>.\n</p>\n\n\n",
        "infobox": {
            "name": "PowerShell",
            "logo": "PowerShell Core 6.0 icon.png",
            "screenshot": "Windows PowerShell 1.0 PD.png",
            "screenshot caption": "Screenshot of a Windows PowerShell session",
            "paradigm": [
                "Imperative programming|Imperative",
                "Pipeline (software)|pipeline",
                "Object-oriented programming|object-oriented",
                "Functional programming|functional and Reflective programming|reflective"
            ],
            "released": "start date and age|2006|11|14",
            "designer": [
                "Jeffrey Snover",
                "Bruce Payette",
                "James Truher (et al.)"
            ],
            "developer": "Microsoft",
            "latest release version": "7.0.3",
            "latest release date": "start date and age|2020|07|16",
            "latest preview version": "v7.1.0-preview.5",
            "latest preview date": "start date and age|2020|07|06",
            "typing": [
                "Strongly-typed programming language|Strong",
                "Type safety|safe",
                "Type inference|implicit and dynamic typing|dynamic"
            ],
            "programming language": "C Sharp (programming language)|C#",
            "operating system": [
                "Plainlist|\n* Windows 7 and later\n* Windows Server 2008 R2 and later\n* macOS 10.12 and later\n* Ubuntu (operating system)|Ubuntu 14.04",
                "16.04",
                "17.04",
                "and 18.04\n* Debian 8.7+",
                "9",
                "and 10\n* CentOS 7 and 8\n* Red Hat Enterprise Linux 7\n* OpenSUSE 42.2",
                "42.3\n* Fedora (operating system)|Fedora 25",
                "26",
                "28\n\n* Docker (software)|Docker"
            ],
            "platform": [
                ".NET Framework",
                ".NET Core"
            ],
            "license": "MIT License (but the Windows component remains proprietary software|proprietary)",
            "influenced_by": [
                "Python (programming language)|Python",
                "Korn shell|Ksh",
                "Perl",
                "C Sharp (programming language)|C#",
                "IBM i Control Language|CL",
                "DIGITAL Command Language|DCL",
                "SQL",
                "Tcl",
                "Tk (software)|Tk",
                "Chef (software)|Chef",
                "Puppet (software)|Puppet"
            ],
            "operating_system": [
                "Windows 7 and later",
                "macOS",
                "CentOS",
                "Debian",
                "Ubuntu (operating system)|Ubuntu",
                "Red Hat Enterprise Linux",
                "OpenSUSE",
                "Fedora (operating system)|Fedora",
                "Docker"
            ],
            "genre": [
                "Shell (computing)|Operating system shell",
                "Configuration management"
            ],
            "file extensions": "Plainlist|\n*.ps1 (Script)\n*.ps1xml (XML Document)\n*.psc1 (Console File)\n*.psd1 (Data File)\n*.psm1 (Script Module)\n*.pssc (Session Configuration File)\n*.psrc (Role Capability File)\n*.cdxml (Cmdlet Definition XML Document)"
        }
    },
    {
        "id": 494,
        "name": "Powerhouse (programming language)",
        "url": "https://en.wikipedia.org/wiki/PowerHouse_(programming_language)",
        "summary": "<p><b>PowerHouse</b> is a trademarked name for a byte-compiled fourth-generation programming language (or 4GL) originally produced by Quasar Corporation (later renamed Cognos Incorporated) for the Hewlett-Packard <i>HP3000</i> mini-computer, as well as Data General and DEC VAX VMS computing products. It was initially composed of five components: </p>\n<ul><li><i>QDD, or Quasar Data Dictionary</i>: for building a central data dictionary used by all other components</li>\n<li><i>QDesign</i>: a character-based screen generator</li>\n<li><i>Quick</i>: an interactive, character-based screen processor (running screens generated by QDesign)</li>\n<li><i>Quiz</i>: a report writer</li>\n<li><i>QTP</i>: a batch transaction processor.</li></ul>",
        "infobox": {
            "name": "UNICOM PowerHouse",
            "logo alt": "Unicom Systems corporate logo",
            "developer": [
                "UNICOM Systems",
                "a division of UNICOM Global"
            ],
            "license": "Proprietary software",
            "website": "https://teamblue.unicomsi.com/products/powerhouse-4gl/"
        }
    },
    {
        "id": 495,
        "name": "Pro*C",
        "url": "https://en.wikipedia.org/wiki/Pro*C",
        "summary": "<p><b>Pro*C</b> (also known as <b>Pro*C/C++</b>) is an embedded SQL programming language used by Oracle Database DBMSes.  Pro*C uses either C or C++ as its host language.  During compilation, the embedded SQL statements are interpreted by a precompiler and replaced by C or C++ function calls to their respective SQL library.  The output from the Pro*C precompiler is standard C or C++ code that is then compiled by any one of several C or C++ compilers into an executable. </p>\n",
        "infobox": "N/A"
    },
    {
        "id": 496,
        "name": "Processing.js",
        "url": "https://en.wikipedia.org/wiki/Processing.js",
        "summary": "<p><b>Processing.js</b> is a JavaScript port of Processing, a programming language designed to write visualisations, images, and interactive content. It allows web browsers to display animations, visual applications, games and other graphical rich content without the need for a Java applet or Flash plugin.  </p><p>Processing.js was originally created to allow existing Processing developers and existing code to work unmodified on web. Processing.js used JavaScript to render 2D and 3D content on the HTML canvas element, and was supported by browsers that have implemented this element (the latest versions of Mozilla Firefox, Opera, Internet Explorer, Safari and Google Chrome).\n</p><p>The development of Processing.js was started by John Resig and then picked up by the CDOT group at Seneca College after its initial release in 2008. A team of students and professors finished the porting work to get Processing.js to parity with the Processing v1.0 API, fixing more than 900 bugs, shipping 12 releases, and creating a vibrant community in the process. The project was run through a partnership between the Mozilla Foundation and Seneca College, led by David Humphrey, Al MacDonald, and Corban Brook.\n</p><p>Processing.js development was moved to GitHub in February of 2010, receiving contributions from 58 individuals, and was kept at parity with Processing up to its API version 2.1 release. The project was discontinued in December of 2018, two years after active development on it had stopped.\n</p><p>Lauren McCarthy created p5.js, a native JavaScript alternative and successor to Processing.js that has the official support of the Processing Foundation. McCarthy also teaches an introductory course to p5.js on Kadenze.\n</p>",
        "infobox": {
            "name": "Processing.js",
            "logo": "File:Processing Logo Clipped.svg|180px|Processing logo",
            "author": "John Resig",
            "developer": "Seneca College | Seneca CDOT",
            "released": "2008",
            "latest release version": "1.6.6",
            "latest release date": "2017|3|5",
            "programming language": "JavaScript",
            "status": "Discontinued",
            "genre": "Web application framework",
            "license": "MIT License|MIT",
            "website": "url|http://processingjs.org",
            "size": "Nowrap|61 Kilobyte|KB (gzipped) / Nowrap|209 KB (production) / Nowrap|754 KB (development)",
            "Successor": "p5.js"
        }
    },
    {
        "id": 497,
        "name": "Processing (programming language)",
        "url": "https://en.wikipedia.org/wiki/Processing_(programming_language)",
        "summary": "<p><b>Processing</b> is an open-source graphical library and integrated development environment (IDE) built for the electronic arts, new media art, and visual design communities with the purpose of teaching non-programmers the fundamentals of computer programming in a visual context. </p><p>Processing uses the Java language, with additional simplifications such as additional classes and aliased mathematical functions and operations. It also provides a graphical user interface for simplifying the compilation and execution stage.\n</p><p>The Processing language and IDE have been the precursor to other projects including Arduino, Wiring and p5.js.\n</p>",
        "infobox": {
            "name": "Processing",
            "logo": "File:Processing 3 logo.png|180px|Processing logo",
            "paradigm": "Object-oriented programming|Object-oriented",
            "latest release version": "3.5.4",
            "latest release date": "2020|01|17",
            "license": [
                "GPL",
                "LGPL"
            ],
            "website": "processing.org",
            "alt": [
                "On a black circle outlined with silver",
                "a serifed number 1 and number 3",
                "with the 3's center at the same horizontal level of the 1's upper bound. This creates a unified \"P3\" letter-number combination."
            ],
            "year": "2001",
            "designers": [
                "Casey Reas",
                "Ben Fry"
            ],
            "file ext": ".pde"
        }
    },
    {
        "id": 498,
        "name": "Programming Language for Business",
        "url": "https://en.wikipedia.org/wiki/Programming_Language_for_Business",
        "summary": "<p><b>Programming Language for Business</b> or <b>PL/B</b> is a business-oriented programming language originally called <b>DATABUS</b> and designed by Datapoint in 1972 as an alternative to COBOL because Datapoint's 8-bit computers could not fit COBOL into their limited memory, and because COBOL did not at the time have facilities to deal with Datapoint's built-in keyboard and screen. </p><p>A version of DATABUS became an ANSI standard, and the name PL/B came about when Datapoint chose not to release its trademark on the DATABUS name.</p>",
        "infobox": {
            "name": "Programming Language for Business",
            "paradigm": [
                "Procedural programming|Procedural",
                "imperative programming|imperative"
            ],
            "year": "1972",
            "typing": [
                "strong typing|Strong",
                "static typing|static"
            ],
            "implementations": [
                "DB/C DX",
                "DATABUS",
                "and PL/B"
            ],
            "influenced_by": "COBOL",
            "file_ext": [
                "<code>.rl</code>",
                "<code>.ps</code>",
                "<code>.cb</code>"
            ],
            "wikibooks": "Programming Language for Business"
        }
    },
    {
        "id": 499,
        "name": "Programming language",
        "url": "https://en.wikipedia.org/wiki/Programming_language",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p class=\"mw-empty-elt\">\n</p>\n\n<p>A <b>programming language</b> is a formal language comprising a set of instructions that produce various kinds of output. Programming languages are used in computer programming to implement algorithms.\n</p><p>Most programming languages consist of instructions for computers. There are programmable machines that use a set of specific instructions, rather than general programming languages. Early ones preceded the invention of the digital computer, the first probably being the automatic flute player described in the 9th century by the brothers Musa in Baghdad, during the Islamic Golden Age. Since the early 1800s, programs have been used to direct the behavior of machines such as Jacquard looms, music boxes and player pianos. The programs for these machines (such as a player piano's scrolls) did not produce different behavior in response to different inputs or conditions.\n</p><p>Thousands of different programming languages have been created, and more are being created every year. Many programming languages are written in an imperative form (i.e., as a sequence of operations to perform) while other languages use the declarative form (i.e. the desired result is specified, not how to achieve it).\n</p><p>The description of a programming language is usually split into the two components of syntax (form) and semantics (meaning). Some languages are defined by a specification document (for example, the C programming language is specified by an ISO Standard) while other languages (such as Perl) have a dominant implementation that is treated as a reference. Some languages have both, with the basic language defined by a standard and extensions taken from the dominant implementation being common.\n</p>\n\n\n",
        "infobox": "N/A"
    },
    {
        "id": 500,
        "name": "Programming language for Computable Functions",
        "url": "https://en.wikipedia.org/wiki/Programming_Computable_Functions",
        "summary": "<p>In computer science, <b>Programming Computable Functions'<i> (</i>PCF</b>) is a typed functional language introduced by Gordon Plotkin in 1977, based on previous unpublished material by Dana Scott. It can be considered to be an extended version of the typed lambda calculus or a simplified version of modern typed functional languages such as ML or Haskell. </p><p>A fully abstract model for PCF was first given by Milner (1977). However, since Milner's model was essentially based on the syntax of PCF it was considered less than satisfactory (Ong, 1995). The first two fully abstract models not employing syntax were formulated during the 1990s. These models are based on game semantics (Hyland and Ong, 2000; Abramsky, Jagadeesan, and Malacaria, 2000) and Kripke logical relations (O'Hearn and Riecke, 1995). For a time it was felt that neither of these models was completely satisfactory, since they were not effectively presentable. However, Ralph Loader demonstrated that no effectively presentable fully abstract model could exist, since the question of program equivalence in the finitary fragment of PCF is not decidable.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 501,
        "name": "Prograph",
        "url": "https://en.wikipedia.org/wiki/Prograph",
        "summary": "<p><b>Prograph</b> is a visual, object-oriented, dataflow, multiparadigm programming language that uses iconic symbols to represent actions to be taken on data. Commercial Prograph software development environments such as Prograph Classic and Prograph CPX were available for the Apple Macintosh and Windows platforms for many years but were eventually withdrawn from the market in the late 1990s. Support for the Prograph language on macOS has recently reappeared with the release of the Marten software development environment.</p>",
        "infobox": {
            "name": "Prograph",
            "logo": "File:Prograph cpx logo.PNG|150px",
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Object-oriented programming|object-oriented",
                "Visual programming language|visual",
                "dataflow programming|dataflow"
            ],
            "year": "1983",
            "designer": "Acadia University",
            "developer": "Various",
            "implementations": [
                "Prograph CPX",
                "[http://www.andescotia.com/ Marten]"
            ],
            "influenced_by": [
                "functional programming",
                "dataflow diagrams"
            ],
            "operating_system": [
                "Cross-platform: Classic MacOS",
                "Microsoft Windows",
                "macOS"
            ],
            "license": "Proprietary"
        }
    },
    {
        "id": 502,
        "name": "Prolog",
        "url": "https://en.wikipedia.org/wiki/Prolog",
        "summary": "<p><b>Prolog</b> is a  logic programming language associated with artificial intelligence and computational linguistics.</p><p>Prolog has its roots in first-order logic, a formal logic, and unlike many other programming languages, Prolog is intended primarily as a declarative programming language: the program logic is expressed in terms of relations, represented as facts and rules.  A computation is initiated by running a <i>query</i> over these relations.</p><p>The language was developed and implemented in Marseille, France, in 1972 by Alain Colmerauer with Philippe Roussel, based on Robert Kowalski's procedural interpretation of Horn clauses.</p><p>Prolog was one of the first logic programming languages and remains the most popular such language today, with several free and commercial implementations available. The language has been used for theorem proving, expert systems, term rewriting, type systems, and automated planning, as well as its original intended field of use, natural language processing.  Modern Prolog environments support the creation of graphical user interfaces, as well as administrative and networked applications. </p><p>Prolog is well-suited for specific tasks that benefit from rule-based logical queries such as searching databases, voice control systems, and filling templates.\n</p>",
        "infobox": {
            "paradigm": "Logic programming",
            "year": "1972",
            "designers": [
                "Alain Colmerauer",
                "Robert Kowalski"
            ],
            "implementations": [
                "B-Prolog",
                "Ciao (programming language)|Ciao",
                "ECLiPSe",
                "GNU Prolog",
                "[http://www.jekejeke.ch/ Jekejeke Prolog]",
                "Poplog Prolog",
                "P Sharp|P#",
                "[https://quintus.sics.se/ Quintus Prolog]",
                "SICStus",
                "Strawberry Prolog|Strawberry",
                "SWI-Prolog",
                "[http://tau-prolog.org/ Tau Prolog]",
                "tuProlog",
                "Logic Programming Associates|WIN-PROLOG",
                "XSB",
                "YAP (Prolog)|YAP."
            ],
            "dialects": [
                "ISO Prolog",
                "Edinburgh Prolog"
            ],
            "influenced by": "Planner (programming language)|Planner",
            "influenced": [
                "Constraint Handling Rules|CHR",
                "Clojure",
                "Datalog",
                "Erlang (programming language)|Erlang",
                "KL0",
                "KL1",
                "Mercury (programming language)|Mercury",
                "Oz (programming language)|Oz",
                "Strand (programming language)|Strand",
                "Visual Prolog",
                "XSB"
            ],
            "file_ext": [
                "<code>.pl</code>",
                "<code>.pro</code>",
                "<code>.P</code>"
            ],
            "wikibooks": "Prolog"
        }
    },
    {
        "id": 503,
        "name": "Promela",
        "url": "https://en.wikipedia.org/wiki/Promela",
        "summary": "<p><b>PROMELA</b> (<b>Process</b> or <b>Protocol Meta Language</b>) is a verification modeling language introduced by Gerard J. Holzmann. The language allows for the dynamic creation of concurrent processes to model, for example, distributed systems. In PROMELA models, communication via message channels can be defined to be synchronous (i.e., rendezvous), or asynchronous (i.e., buffered). PROMELA models can be analyzed with the SPIN model checker, to verify that the modeled system produces the desired behavior. An implementation verified with Isabelle/HOL is also available, as part of the Computer Aided Verification of Automata project. Files written in Promela traditionally have a <code>.pml</code> file extension. </p>",
        "infobox": "N/A"
    },
    {
        "id": 504,
        "name": "Protel",
        "url": "https://en.wikipedia.org/wiki/Protel",
        "summary": "<p><b>Protel</b> stands for \"Procedure Oriented Type Enforcing Language\". It is a programming language created by Nortel Networks and used on telecommunications switching systems such as the DMS-100. Protel-2 is the object-oriented version of Protel.</p><p>PROTEL languages were designed to meet the needs of digital telephony and is the basis of the DMS-100 line of switching systems  PROTEL is a strongly typed, block-structured language which is based heavily on PASCAL and ALGOL 68 with left-to-right style of variable assignment, variable-sized arrays, and extensible structures.  The designers of PROTEL significantly extended PASCAL of the day by adding external compilation and extending the data structures available in the language.</p>",
        "infobox": "N/A"
    },
    {
        "id": 505,
        "name": "ProvideX",
        "url": "https://en.wikipedia.org/wiki/ProvideX",
        "summary": "<p><b>ProvideX</b> is a computer language and development environment derived from Business Basic (a business oriented derivative of BASIC) in the mid-1980s. </p><p>ProvideX is available on several operating systems (Unix/Linux/Windows/Mac OS X) and includes not only the programming language but also file system, presentation layer interface, and other components.  The language is primarily designed for use in the development of business applications.\n</p><p>Over the years since its inception and as the computer industry has changed, ProvideX has added functionality such as a graphical interface, client-server capabilities, access to external databases, web services, and, more recently, object-oriented programming capabilities.\n</p><p>On October 8, 2010, PVX Plus Technologies announced that it has assumed all ongoing sales, development, and support of the ProvideX product line for Independent Software Vendors.  This brings the development of the language back under control of the original creator, Mike King and is the end result of almost 2 years of negotiations between Sage, EDIAS, and PVX Plus Technologies.</p>",
        "infobox": {
            "name": "ProvideX",
            "year": "1992",
            "designer": "Michael F. King",
            "developer": "Sage Software Canada",
            "latest_release_version": "9.10",
            "latest_release_date": "2010|07|15",
            "typing": "strong",
            "dialects": "PVX Plus|PxPlus",
            "influenced_by": "Business Basic",
            "operating_system": "Microsoft Windows|Windows / Unix / Linux / Mac OS X",
            "file_ext": [
                ".pvx",
                ".pvc",
                ".pvk",
                ".pvt"
            ],
            "website": "url|www.pvxplus.com"
        }
    },
    {
        "id": 506,
        "name": "PureScript",
        "url": "https://en.wikipedia.org/wiki/PureScript",
        "summary": "<p><b>PureScript</b> is a strongly-typed, purely-functional programming language that compiles to JavaScript. It can be used to develop web applications, server side apps, and also desktop applications with use of Electron. Its syntax is mostly comparable to that of Haskell. In addition, it introduces row polymorphism and extensible records. Also, contrary to Haskell, PureScript adheres to a strict evaluation strategy. </p>",
        "infobox": {
            "name": "PureScript",
            "logo": "PureScript Logo.png",
            "paradigm": "Functional programming|Functional",
            "year": "2013",
            "latest release version": "0.13.8",
            "latest release date": "2020|05|23",
            "influenced_by": [
                "Haskell (programming language)|Haskell",
                "JavaScript"
            ],
            "typing": [
                "Type inference|Inferred",
                "static typing|static",
                "strong typing|strong"
            ],
            "designer": "Phil Freeman",
            "website": "[http://www.purescript.org www.purescript.org]",
            "license": "Modified BSD License|BSD",
            "file_ext": ".purs"
        }
    },
    {
        "id": 507,
        "name": "Pure (programming language)",
        "url": "https://en.wikipedia.org/wiki/Pure_(programming_language)",
        "summary": "<p><b>Pure</b>, successor to the equational language <b>Q</b>, is a dynamically typed, functional programming language based on term rewriting. It has facilities for user-defined operator syntax, macros, arbitrary-precision arithmetic (multiple-precision numbers), and compiling to native code through the LLVM. Pure is free and open-source software distributed (mostly) under the GNU Lesser General Public License version 3 or later. </p><p>Pure comes with an interpreter and debugger, provides automatic memory management, has powerful functional and symbolic programming abilities, and interfaces to libraries in C (e.g., for numerics, low-level protocols, and other such tasks). At the same time, Pure is a <i>small</i> language designed from scratch; its interpreter is not large, and the library modules are written in Pure. The syntax of Pure resembles that of Miranda and Haskell, but it is a free-format language and thus uses explicit delimiters (rather than off-side rule indents) to denote program structure.\n</p><p>The Pure language is a successor of the equational programming language Q, previously created by the same author, Albert Gräf at the University of Mainz, Germany. Relative to Q, it offers some important new features (such as local functions with lexical scoping, efficient vector and matrix support, and the built-in C interface) and programs run much faster as they are compiled just-in-time to native code on the fly. Pure is mostly aimed at mathematical applications and scientific computing currently, but its interactive interpreter environment, the C interface and the growing set of addon modules make it suitable for a variety of other applications, such as artificial intelligence, symbolic computation, and real-time multimedia processing.\n</p><p>Pure plug-ins are available for the Gnumeric spreadsheet and Miller Puckette's Pure Data graphical multimedia software, which make it possible to extend these programs with functions written in the Pure language. Interfaces are also provided as library modules to GNU Octave, OpenCV, OpenGL, the GNU Scientific Library, FAUST, SuperCollider, and liblo (for Open Sound Control (OSC)).\n</p>",
        "infobox": {
            "name": "Pure",
            "logo": "Pure lang logo.png",
            "paradigm": [
                "Functional programming|Functional",
                "Declarative programming|declarative",
                "term rewriting"
            ],
            "designer": "Albert Gräf",
            "developer": "Albert Gräf",
            "released": "2008",
            "latest release version": "0.68",
            "latest release date": "2018|04|11",
            "typing": [
                "Strong and weak typing|Strong",
                "Type system#DYNAMIC|dynamic"
            ],
            "operating system": [
                "Cross-platform: FreeBSD",
                "GNU/Linux",
                "macOS",
                "Microsoft Windows|Windows"
            ],
            "license": "GNU Lesser General Public License",
            "influenced by": [
                "Q",
                "Haskell (programming language)|Haskell",
                "Lisp (programming language)|Lisp",
                "Alice (programming language)|Alice",
                "MATLAB"
            ],
            "website": "https://agraef.github.io/pure-lang/"
        }
    },
    {
        "id": 508,
        "name": "Pure Data",
        "url": "https://en.wikipedia.org/wiki/Pure_Data",
        "summary": "<p><b>Pure Data</b> (<b>Pd</b>) is a visual programming language developed by Miller Puckette in the 1990s for creating interactive computer music and multimedia works. While Puckette is the main author of the program, Pd is an open-source project with a large developer base working on new extensions. It is released under a license similar to the BSD license. It runs on GNU/Linux, <span>Mac OS X</span>, iOS, Android and Windows.  Ports exist for FreeBSD and IRIX. </p><p>Pd is very similar in scope and design to Puckette's original Max program, developed while he was at IRCAM, and is to some degree interoperable with Max/MSP, the commercial predecessor to the Max language. They may be collectively discussed as members of the Patcher family of languages.\n</p><p>With the addition of the Graphics Environment for Multimedia (GEM) external, and externals designed to work with it (like Pure Data Packet / PiDiP for Linux, <span>Mac OS X</span>), framestein for Windows, GridFlow (as n-dimensional matrix processing, for Linux, <span>Mac OS X</span>, Windows), it is possible to create and manipulate video, OpenGL graphics, images, etc., in realtime with extensive possibilities for interactivity with audio, external sensors, etc.\n</p><p>Pd is natively designed to enable live collaboration across networks or the Internet, allowing musicians connected via LAN or even in disparate parts of the globe to create music together in real time. Pd uses FUDI as a networking protocol.\n</p>",
        "infobox": {
            "name": "Pure Data",
            "screenshot": "Pure Data with many patches open (showing netpd project).png",
            "caption": "Pure Data with many patches open (netpd project)",
            "author": "Miller Puckette",
            "latest_release_version": "0.50-2",
            "latest_release_date": "2019|10|06",
            "genre": "Visual programming language",
            "license": "BSD licenses|Modified BSD",
            "website": "puredata.info"
        }
    },
    {
        "id": 509,
        "name": "Python (programming language)",
        "url": "https://en.wikipedia.org/wiki/Python_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Python</b> is an interpreted, high-level, general-purpose programming language. Created by Guido van Rossum and first released in 1991, Python's design philosophy emphasizes code readability with its notable use of significant whitespace. Its language constructs and object-oriented approach aim to help programmers write clear, logical code for small and large-scale projects.</p><p>Python is dynamically typed and garbage-collected. It supports multiple programming paradigms, including structured (particularly, procedural), object-oriented, and functional programming. Python is often described as a \"batteries included\" language due to its comprehensive standard library.</p><p>Python was conceived in the late 1980s as a successor to the ABC language. Python 2.0, released in 2000, introduced features like list comprehensions and a garbage collection system with reference counting.\n</p><p>Python 3.0, released in 2008, was a major revision of the language that is not completely backward-compatible, and much Python 2 code does not run unmodified on Python 3.\n</p><p>The Python 2 language was officially discontinued in 2020 (first planned for 2015), and \"Python 2.7.18 is the last Python 2.7 release and therefore the last Python 2 release.\" No more security patches or other improvements will be released for it. With Python 2's end-of-life, only  Python 3.5.x and later are supported.\n</p><p>Python interpreters are available for many operating systems. A global community of programmers develops and maintains CPython, a free and open-source reference implementation. A non-profit organization, the Python Software Foundation, manages and directs resources for Python and CPython development.\n</p>",
        "infobox": {
            "logo": "Python logo and wordmark.svg",
            "logo size": "250px",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: functional programming|functional",
                "imperative programming|imperative",
                "object-oriented programming|object-oriented",
                "structured programming|structured",
                "reflective programming|reflective"
            ],
            "released": "start date and age|1990",
            "designer": "Guido van Rossum",
            "developer": "Python Software Foundation",
            "latest release version": "3.8.5",
            "latest release date": "2020|7|20",
            "latest preview version": "3.9.0b5",
            "latest preview date": "2020|7|20",
            "typing": [
                "duck typing|Duck",
                "dynamic typing|dynamic",
                "gradual typing|gradual (since 3.5)"
            ],
            "implementations": [
                "CPython",
                "PyPy",
                "Stackless Python",
                "MicroPython",
                "CircuitPython",
                "IronPython",
                "Jython",
                "RustPython"
            ],
            "dialects": [
                "Cython",
                "PyPy#RPython|RPython",
                "Bazel (software)|Starlark"
            ],
            "influenced": [
                "Apache Groovy",
                "Boo (programming language)|Boo",
                "Cobra (programming language)|Cobra",
                "CoffeeScript",
                "D (programming language)|D",
                "F Sharp (programming language)|F#",
                "Genie (programming language)|Genie",
                "Go (programming language)|Go",
                "JavaScript",
                "Julia (programming language)|Julia",
                "Nim (programming language)|Nim",
                "Ring",
                "Ruby (programming language)|Ruby",
                "Swift (programming language)|Swift"
            ],
            "license": "Python Software Foundation License",
            "website": "https://www.python.org/",
            "wikibooks": "Python Programming",
            "influenced_by": [
                "ABC (programming language)|ABC",
                "Ada (programming language)|Ada",
                "ALGOL 68",
                "APL (programming language)|APL",
                "C (programming language)|C",
                "C++",
                "CLU (programming language)|CLU",
                "Dylan (programming language)|Dylan",
                "Haskell (programming language)|Haskell",
                "Icon (programming language)|Icon",
                "Java (programming language)|Java",
                "Lisp (programming language)|Lisp",
                "Modula-3",
                "Perl",
                "Standard ML"
            ],
            "operating system": [
                "Linux",
                "macOS",
                "Microsoft Windows|Windows Vista (and newer) and more"
            ],
            "file ext": [
                ".py",
                ".pyi",
                ".pyc",
                ".pyd",
                ".pyo (prior to 3.5)",
                "notatypo|.pyw ",
                ".pyz (since 3.5)"
            ]
        }
    },
    {
        "id": 510,
        "name": "P′′",
        "url": "https://en.wikipedia.org/wiki/P%E2%80%B2%E2%80%B2",
        "summary": "<p><b>P′′</b> (P double prime) is a primitive computer programming language created by Corrado Böhm in 1964 to describe a family of Turing machines. </p>\n\n\n",
        "infobox": {
            "name": "P′′",
            "paradigm": [
                "Imperative programming|Imperative",
                "Structured programming|structured"
            ],
            "released": "1964",
            "designer": "Corrado Böhm",
            "typing": "untyped",
            "dialects": "Brainfuck",
            "influenced": "Brainfuck"
        }
    },
    {
        "id": 511,
        "name": "Q (programming language from Kx Systems)",
        "url": "https://en.wikipedia.org/wiki/Q_(programming_language_from_Kx_Systems)",
        "summary": "<p><b>Q</b> is a programming language for array processing, developed by Arthur Whitney. It is proprietary software, commercialized by Kx Systems. Q serves as the query language for kdb+, a disk based and in-memory, column-based database. Kdb+ is based on the language k, a terse variant of the language APL. Q is a thin wrapper around k, providing a more readable, English-like interface.</p>",
        "infobox": {
            "name": "q",
            "paradigm": [
                "Array programming|Array",
                "Functional programming|functional"
            ],
            "year": "2003",
            "designer": "Arthur Whitney (computer scientist)|Arthur Whitney",
            "developer": "Kx Systems",
            "latest release version": "4.0",
            "latest release date": "2020|03|17",
            "typing": [
                "Type system|Dynamic",
                "Strong and weak typing|strong"
            ],
            "website": "code.kx.com",
            "influenced by": [
                "A+ (programming language)|A+",
                "APL (programming language)|APL",
                "Scheme (programming language)|Scheme",
                "k (programming language)|k"
            ]
        }
    },
    {
        "id": 512,
        "name": "Q Sharp",
        "url": "https://en.wikipedia.org/wiki/Q_Sharp",
        "summary": "<p><b>Q#</b> (pronounced as <i>Q sharp</i>) is a domain-specific programming language used for expressing quantum algorithms. It was initially released to the public by Microsoft as part of the Quantum Development Kit.</p>",
        "infobox": {
            "title": "Q#",
            "released": [
                "December 11th",
                "2017"
            ],
            "developer": "Microsoft",
            "designer": "Microsoft Research (quantum architectures and computation group; QuArC)",
            "influenced by": [
                "C Sharp (programming language)|C#",
                "F Sharp (programming language)|F#"
            ],
            "File extensions": ".qs",
            "platform": "Common Language Infrastructure",
            "paradigm": [
                "Programming paradigm#Multi-paradigm|multi-paradigm: quantum programming|quantum",
                "functional programming|functional",
                "imperative programming|imperative"
            ],
            "typing": [
                "static typing|static",
                "Strong and weak typing|strong"
            ],
            "license": "MIT License",
            "website": "[https://docs.microsoft.com/en-us/quantum Microsoft Quantum] ([https://github.com/Microsoft/Quantum GitHub])"
        }
    },
    {
        "id": 513,
        "name": "Qalb (programming language)",
        "url": "https://en.wikipedia.org/wiki/Qalb_(programming_language)",
        "summary": "<p><b>قلب</b> (<small>Levantine Arabic: </small><span title=\"Representation in the International Phonetic Alphabet (IPA)\">[ʔalb]</span>), transliterated <i><b>Qalb</b></i>, <i><b>Qlb</b></i> and <i><b>Alb</b></i>, is a functional programming language allowing a programmer to write programs completely in Arabic. Its name means <i>heart</i> and is a recursive acronym in Arabic meaning <i>Qlb: a programming language</i> (قلب: لغة برمجة, <i><i lang=\"ar-Latn\" title=\"Arabic-language romanization\">Qlb: Lughat Barmajah</i></i>). It was developed in 2012 by Ramsey Nasser, a computer scientist at the Eyebeam Art + Technology Center in New York City, as both an artistic endeavor and as a response to the Anglophone bias in the vast majority of programming languages, which express their fundamental concepts using English words. </p><p>The syntax is like that of Lisp or Scheme, consisting of parenthesized lists. All keywords are appropriate Arabic terms, and program text is laid out right-to-left, like all Arabic text. The language provides a minimal set of primitives for defining functions, conditionals, looping, list manipulation, and basic arithmetic expressions. It is Turing-complete, and the Fibonacci sequence and Conway's Game of Life have been implemented.\n</p><p>Because all program text is written in Arabic, and the connecting strokes between characters in the Arabic script can be extended to any length, it is possible to align the source code in artistic patterns, in the tradition of Arabic calligraphy.\n</p><p>A JavaScript-based interpreter is currently hosted on herokuapp and the project can be forked on GitHub.</p>",
        "infobox": {
            "name": "قلب",
            "paradigm": "Functional programming|Functional",
            "year": "2012",
            "designer": "Ramsey Nasser",
            "latest release date": "2013",
            "influenced by": "Scheme (programming language)|Scheme",
            "website": "http://qlb-repl.herokuapp.com/"
        }
    },
    {
        "id": 514,
        "name": "QtScript",
        "url": "https://en.wikipedia.org/wiki/QtScript",
        "summary": "<p><b>QtScript</b> is a scripting engine that has been part of the Qt cross-platform application framework since version 4.3.0. </p><p>The scripting language is based on the ECMAScript standard with a few extensions, such as QObject-style signal and slot connections. The library contains the engine, and a C++ API for evaluating QtScript code and exposing custom QObject-derived C++ classes to QtScript.\n</p><p>The QtScript Binding Generator provides bindings for the Qt API to access directly from ECMAScript. QtScript and the binding generator are used for Amarok 2's scripting system.\n</p><p>The current (as of Qt 4.7) implementation uses JavaScriptCore and will not be further developed. The module is deprecated as of Qt 5.5.</p>",
        "infobox": "N/A"
    },
    {
        "id": 515,
        "name": "QuakeC",
        "url": "https://en.wikipedia.org/wiki/QuakeC",
        "summary": "<p><b>QuakeC</b> is a compiled language developed in 1996 by John Carmack of id Software to program parts of the video game <i>Quake</i>. Using QuakeC, a programmer is able to customize <i>Quake</i> to great extents by adding weapons, changing game logic and physics, and programming complex scenarios. It can be used to control many aspects of the game itself, such as parts of the AI, triggers, or changes in the level. The <i>Quake</i> engine was the only game engine to use QuakeC. Following engines used DLL game modules for customization written in C, and C++ from id Tech 4 on. </p>",
        "infobox": {
            "name": "QuakeC",
            "paradigm": [
                "imperative programming|imperative (Procedural programming|procedural)",
                "structured programming|structured"
            ],
            "designer": "John Carmack",
            "developer": "id Software",
            "typing": [
                "Type system|static",
                "Strong typing|strong"
            ],
            "implementations": [
                "Quake C Compiler",
                "FastQCC",
                "FTEQCC",
                "QCCx",
                "GMQCC"
            ],
            "year": "1996",
            "turing-complete": "No",
            "influenced_by": "C (programming language)|C"
        }
    },
    {
        "id": 516,
        "name": "Quantum Computation Language",
        "url": "https://en.wikipedia.org/wiki/Quantum_Computation_Language",
        "summary": "<p><b>Quantum Computation Language</b> (<b>QCL</b>) is one of the first implemented quantum programming languages. The most important feature of QCL is the   support for user-defined operators and functions. Its syntax resembles the syntax of the C programming language and its classical data types are similar to primitive data types in C. One can combine classical code and quantum code in the same program.  </p><p>The QCL standard library provides standard quantum operators used in quantum algorithms such as:\n</p>\n<ul><li>Controlled-not with many target qubits,</li>\n<li>Hadamard operation on many qubits,</li>\n<li>Phase and controlled phase.</li>\n<li>Quantum algorithms for addition, multiplication and exponentiation (all modulus n)</li>\n<li>The quantum fourier transform</li></ul>",
        "infobox": "N/A"
    },
    {
        "id": 517,
        "name": "Quantum programming",
        "url": "https://en.wikipedia.org/wiki/Quantum_programming",
        "summary": "<p><b>Quantum programming</b> is the process of assembling sequences of instructions, called quantum programs, that are capable of running on a quantum computer. Quantum programming languages help express quantum algorithms using high-level constructs.</p>",
        "infobox": "N/A"
    },
    {
        "id": 518,
        "name": "R++",
        "url": "https://en.wikipedia.org/wiki/R%2B%2B",
        "summary": "<p><b>R++</b> is a rule-based programming language based on C++. The United States patent describes R++ as follows: </p>\n<blockquote><p>The R++ extension permits rules to be defined as members of C++ classes. The programming system of the invention takes the classes with rules defined using R++ and generates C++ code from them in which the machinery required for the rules is implemented completely as C++ data members and functions of the classes involved in the rules.</p></blockquote>\n<p>R++ was developed by Bell Labs in the 1990s, but due to the Bell System divestiture that split the legal rights to the work developed at the Laboratories between AT&amp;T and Lucent, did not see immediate commercial development while the two companies disputed ownership.</p>",
        "infobox": "N/A"
    },
    {
        "id": 519,
        "name": "RAPID",
        "url": "https://en.wikipedia.org/wiki/RAPID",
        "summary": "<p><b>RAPID</b> is a high-level programming language used to control ABB industrial robots. RAPID was introduced along with S4 Control System in 1994 by ABB, superseding the ARLA programming language. </p><p>Features in the language include:\n</p>\n<ul><li>Routine parameters:\n<ul><li>Procedures - used as a subprogram.</li>\n<li>Functions - return a value of a specific type and are used as an argument of an instruction.</li>\n<li>Trap routines - a means of responding to interrupts.</li></ul></li>\n<li>Arithmetic and logical expressions</li>\n<li>Automatic error handling</li>\n<li>Modular programs</li>\n<li>Multi tasking</li></ul>",
        "infobox": {
            "name": "RAPID",
            "year": "1994",
            "designer": "ABB Group",
            "developer": "ABB Group",
            "influenced_by": [
                "ARLA (programming language)|ARLA",
                "C (programming language)|C"
            ]
        }
    },
    {
        "id": 520,
        "name": "REBOL",
        "url": "https://en.wikipedia.org/wiki/Rebol",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Rebol</b> (<span></span> <i title=\"English pronunciation respelling\"><span>REB</span>-əl</i>; historically <b>REBOL</b>) is a cross-platform data exchange language and a multi-paradigm dynamic programming language designed by Carl Sassenrath for network communications and distributed computing.  It introduces the concept of dialecting: small, optimized, domain-specific languages for code and data, which is also the most notable property of the language according to its designer Carl Sassenrath:\n</p>\n<blockquote class=\"templatequote\"><p>Although it can be used for programming, writing functions, and performing processes, its greatest strength is the ability to easily create domain-specific languages or dialects</p></blockquote>\n<p>Douglas Crockford, known for his involvement in the development of JavaScript, has described Rebol as \"a more modern language, but with some very similar ideas to Lisp, in that it's all built upon a representation of data which is then executable as programs\" and as one of JSON's influences.</p><p>Originally, the language and its official implementation were proprietary and closed source, developed by REBOL Technologies. Following discussion with Lawrence Rosen, the Rebol version 3 interpreter was released under the Apache 2.0 license on December 12, 2012. Older versions are only available in binary form, and no source release for them is planned.\n</p><p>Rebol has been used to program Internet applications (both client- and server-side), database applications, utilities, and multimedia applications.</p>",
        "infobox": {
            "name": "Rebol",
            "logo": "File:Rebol logo.png",
            "paradigm": [
                "language oriented programming",
                "Data exchange language|data exchange",
                "functional programming|functional",
                "prototype-based programming|prototype-based",
                "imperative programming|imperative"
            ],
            "year": "1997",
            "designer": "Carl Sassenrath",
            "developer": "REBOL Technologies",
            "latest_release_version": "2.7.8",
            "latest_release_date": "2011|01",
            "latest_test_version": "2.101.0",
            "latest_test_date": "2012|12",
            "typing": [
                "dynamic typing|dynamic",
                "strong typing|strong"
            ],
            "license": [
                "2.7.8 is Freely redistributable software",
                "2.101.0 has Apache License|Apache 2.0 license"
            ],
            "file ext": [
                ".r",
                ".reb"
            ],
            "influenced_by": [
                "Self (programming language)|Self",
                "Forth (programming language)|Forth",
                "Lisp (programming language)|Lisp",
                "Logo (programming language)|Logo"
            ],
            "influenced": [
                "JSON",
                "Red (programming language)|Red"
            ],
            "operating_system": "cross-platform",
            "website": "www.rebol.com",
            "wikibooks": "Rebol Programming"
        }
    },
    {
        "id": 521,
        "name": "REFAL",
        "url": "https://en.wikipedia.org/wiki/Refal",
        "summary": "<p><b>Refal</b> (<b>\"Recursive functions algorithmic language\"</b>) \"is a functional programming language oriented toward symbolic computations\", including \"string processing, language translation, [and] artificial intelligence\". It is one of the oldest members of this family, first conceived of in 1966 as a theoretical tool, with the first implementation appearing in 1968. Refal was intended to combine mathematical simplicity with practicality for writing large and sophisticated programs. </p><p>One of the first functional programming languages to do so, and unlike Lisp of its time, Refal is based on pattern matching. Its pattern matching works in conjunction with term rewriting.\n</p><p>The basic data structure of Lisp and Prolog is a linear list built by cons operation in a sequential manner, thus with <i>O(n)</i> access to list's <i>n</i>th element. Refal's lists are built and scanned from both ends, with pattern matching working for nested lists as well as the top-level one. In effect, the basic data structure of Refal is a tree rather than a list. This gives freedom and convenience in creating data structures while using only mathematically simple control mechanisms of pattern matching and substitution.\n</p><p>Refal also includes a feature called the <i>freezer</i> to support efficient partial evaluation.\n</p><p>Refal can be applied to the processing and transformation of tree structures, similarly to XSLT.</p>",
        "infobox": {
            "name": "Refal",
            "released": "1968",
            "paradigm": "Pattern-matching and Term-rewriting",
            "designer": "Valentin Turchin",
            "developer": [
                "Valentin Turchin",
                "S. Florentsev",
                "V. Olyunin",
                "et al."
            ],
            "website": "http://www.refal.net",
            "typing": [
                "strong typing|strong",
                "dynamic typing|dynamic"
            ],
            "implementations": [
                "Refal-2",
                "Refal-5",
                "Refal-6",
                "Refal+"
            ]
        }
    },
    {
        "id": 522,
        "name": "REXX",
        "url": "https://en.wikipedia.org/wiki/Rexx",
        "summary": "<p><b>Rexx</b> (<b>Restructured Extended Executor</b>) is an interpreted programming language developed at IBM by Mike Cowlishaw. It is a structured, high-level programming language designed for ease of learning and reading. Proprietary and open source Rexx interpreters exist for a wide range of computing platforms; compilers exist for IBM mainframe computers.</p><p>Rexx is used as a scripting and macro language, and is often used for processing data and text and generating reports; these similarities with Perl mean that Rexx works well in Common Gateway Interface (CGI) programming and it is indeed used for this purpose. Rexx is the primary scripting language in some operating systems, e.g. OS/2, MVS, VM, AmigaOS, and is also used as an internal macro language in some other software, such as SPFPC, KEDIT, THE and the ZOC terminal emulator. Additionally, the Rexx language can be used for scripting and macros in any program that uses Windows Scripting Host ActiveX scripting engines languages (e.g. VBScript and JScript) if one of the Rexx engines is installed. </p><p>Rexx is supplied with VM/SP Release 3 on up, TSO/E Version 2 on up, OS/2 (1.3 and later, where it is officially named <i>Procedures Language/2</i>), AmigaOS Version 2 on up, PC DOS (7.0 or 2000), and Windows NT 4.0 (Resource Kit: Regina). REXX scripts for OS/2 share the filename extension .cmd with other scripting languages, and the first line of the script specifies the interpreter to be used. REXX macros for REXX-aware applications use extensions determined by the application. In the late 1980s, Rexx became the common scripting language for IBM Systems Application Architecture, where it was renamed \"SAA Procedure Language REXX\".\n</p><p>A Rexx script or command is sometimes referred to as an <i>EXEC</i> in a nod to the CMS file type used for EXEC, EXEC 2 and REXX scripts on CP/CMS and VM/370 through z/VM.\n</p>",
        "infobox": {
            "logo": "File:Rexx-img-lg.png|frameless",
            "paradigm": [
                "multi-paradigm programming language|multiparadigm: procedural programming|procedural",
                "structured programming|structured"
            ],
            "year": "1979",
            "designer": "Mike Cowlishaw",
            "developer": [
                "Mike Cowlishaw",
                "IBM"
            ],
            "latest release version": "ANSI X3.274",
            "latest release date": "1996",
            "typing": "Dynamic",
            "implementations": [
                "VM/SP R3",
                "TSO/E V2",
                "SAAREXX",
                "ARexx",
                "BREXX",
                "Regina",
                "Personal REXX",
                "REXX/imc"
            ],
            "dialects": [
                "NetRexx",
                "Object REXX",
                "now ooREXX",
                "XEDIT#PC and Unix adaptations|KEXX"
            ],
            "influenced_by": [
                "PL/I",
                "ALGOL",
                "CMS EXEC|EXEC",
                "EXEC 2"
            ],
            "influenced": [
                "NetRexx",
                "Object REXX"
            ],
            "file_ext": [
                ".cmd",
                ".bat",
                ".exec",
                ".rexx",
                ".rex",
                "EXEC"
            ],
            "wikibooks": "Rexx Programming"
        }
    },
    {
        "id": 523,
        "name": "ROOP (programming language)",
        "url": "https://en.wikipedia.org/wiki/ROOP_(programming_language)",
        "summary": "<p><b>ROOP</b> is a multiparadigm programming language targeted at AI applications created at the Chengdu University of China. It combines rule-based, procedural, logical and object-oriented programming techniques. </p>",
        "infobox": "N/A"
    },
    {
        "id": 524,
        "name": "RPL (programming language)",
        "url": "https://en.wikipedia.org/wiki/RPL_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>RPL</b><sup class=\"reference plainlinks nourlexpansion\" id=\"ref_rpl_acronym_note_1\">[1]</sup> is a handheld calculator operating system and application programming language used on Hewlett-Packard's scientific graphing RPN (Reverse Polish Notation) calculators of the HP 28, 48, 49 and 50 series, but it is also usable on non-RPN calculators, such as the 38, 39 and 40 series.\n</p><p>RPL is a structured programming language based on RPN, but equally capable of processing algebraic expressions and formulae, implemented as a threaded interpreter. RPL has many similarities to Forth, both languages being stack-based, as well as the list-based LISP. Contrary to previous HP RPN calculators, which had a fixed four-level stack, the stack used by RPL is only limited by available calculator RAM.\n</p><p>RPL originated from HP's Corvallis, Oregon development facility in 1984 as a replacement for the previous practice of implementing the operating systems of calculators in assembly language. The last pocket calculator supporting RPL, the HP 50g, was discontinued in 2015.  However,  multiple emulators that can emulate HP's RPL calculators exist that run on a range of operating systems, and devices, including iOS and Android smartphones.\n</p>",
        "infobox": {
            "name": "RPL",
            "paradigm": [
                "stack-oriented programming language|stack",
                "structured programming|structured",
                "object-oriented"
            ],
            "year": "1984 (1986)",
            "designer": "Hewlett-Packard",
            "latest_release_date": "2012-04-26",
            "discontinued": "2015",
            "dialects": [
                "System RPL",
                "User RPL"
            ],
            "influenced_by": [
                "Reverse Polish Notation|RPN",
                "Forth (programming language)|Forth",
                "Lisp (programming language)|Lisp"
            ],
            "operating_system": "Hewlett-Packard|HP calculators"
        }
    },
    {
        "id": 525,
        "name": "RTL/2",
        "url": "https://en.wikipedia.org/wiki/RTL/2",
        "summary": "<p><b>RTL/2</b> is a discontinued high-level programming language developed at Imperial Chemical Industries Ltd by J.G.P. Barnes. It was originally used internally within ICI but was distributed by SPL International in 1974 It was designed for use in real-time computing (hence the initials RTL = real-time language). Based on concepts from Algol 68, it was intended to be a small, simple language. RTL/2 was standardised in 1980 by the British Standards Institution.</p>",
        "infobox": {
            "name": "RTL/2",
            "paradigm": [
                "Structured programming|structured",
                "Imperative programming|imperative"
            ],
            "year": "1972",
            "designer": "Imperial Chemical Industries",
            "developer": "John Barnes (computer scientist)|J.G.P. Barnes",
            "influenced_by": "Algol 68",
            "dialects": "none",
            "operating_system": "Cross-platform|Cross-platform (multi-platform)"
        }
    },
    {
        "id": 526,
        "name": "R (programming language)",
        "url": "https://en.wikipedia.org/wiki/R_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>R</b> is a programming language and free software environment for statistical computing and graphics supported by the R Foundation for Statistical Computing. The R language is widely used among statisticians and data miners for developing statistical software and data analysis. Polls, data mining surveys, and studies of scholarly literature databases show substantial increases in popularity; as of July 2020, R ranks 8th in the TIOBE index, a measure of popularity of programming languages.</p><p>A GNU package, the official R software environment is written primarily in C, Fortran, and R itself (thus, it is partially self-hosting) and is freely available under the GNU General Public License. Pre-compiled executables are provided for various operating systems. Although R has a command line interface, there are several third-party graphical user interfaces, such as RStudio, an integrated development environment, and Jupyter, a notebook interface.</p>\n\n\n",
        "infobox": {
            "name": "R",
            "logo": "R logo.svg",
            "screenshot": "R terminal.jpg",
            "screenshot caption": "R terminal",
            "released": "1993|08",
            "designer": "Ross Ihaka and Robert Gentleman (statistician)|Robert Gentleman",
            "developer": "R Core Team",
            "typing": "dynamic typing|Dynamic",
            "influenced": "Julia (programming language)|Julia",
            "license": "GNU GPL#Version 2|GNU GPL v2",
            "website": "Official URL",
            "wikibooks": "R Programming",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Array programming|Array",
                "Object-oriented programming|object-oriented",
                "Imperative programming|imperative",
                "Functional programming|functional",
                "Procedural programming|procedural",
                "Reflective programming|reflective"
            ],
            "latest_release_version": "4.0.2 (\"Taking Off Again\")",
            "latest_release_date": "2020|06|22",
            "influenced_by": "startflatlist * Common Lisp\n* S (programming language)|S\n* Scheme (programming language)|Scheme * XLispStat endflatlist",
            "file_ext": "Unbulleted list|.r|.rdata|.rds|.rda"
        }
    },
    {
        "id": 527,
        "name": "Racket (programming language)",
        "url": "https://en.wikipedia.org/wiki/Racket_(programming_language)",
        "summary": "<p><b>Racket</b> is a general-purpose, multi-paradigm programming language based on the Scheme dialect of Lisp. It is designed to be a platform for programming language design and implementation. In addition to the core Racket language, <i>Racket</i> is also used to refer to the family of programming languages and set of tools supporting development on and with Racket. Racket is also used for scripting, computer science education, and research.  </p><p>The Racket platform provides an implementation of the Racket language (including a runtime system, libraries, and JIT compiler) along with the DrRacket integrated development environment (IDE) written in Racket. Racket is used by the ProgramByDesign outreach program, which aims to turn computer science into \"an indispensable part of the liberal arts curriculum\".</p><p>The core Racket language is known for its extensive macro system which enables creating embedded and domain-specific languages, language constructs such as classes or modules, and separate dialects of Racket with different semantics.</p><p>The platform distribution is free and open-source software distributed under the Apache 2.0 and MIT licenses. Extensions and packages written by the community may be uploaded to Racket's package catalog.\n</p>",
        "infobox": {
            "name": "Racket",
            "logo": "Racket-logo.svg",
            "screenshot": "Drracket.png",
            "screenshot caption": "DrRacket on Ubuntu",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm: functional programming|functional",
                "imperative programming|imperative",
                "logic programming|logic",
                "metaprogramming|meta",
                "modular programming|modular",
                "object-oriented programming|object-oriented",
                "reflection (computer science)|reflective"
            ],
            "family": "Lisp (programming language)|Lisp",
            "year": "1995",
            "designer": "PLT Inc.",
            "developer": "PLT Inc.",
            "latest release version": "7.7",
            "latest release date": "2020|05|02",
            "typing": [
                "dynamic typing|Dynamic",
                "static typing|static",
                "strong typing|strong"
            ],
            "dialects": [
                "FrTime",
                "Lazy Racket",
                "Scribble",
                "Typed Racket"
            ],
            "influenced by": [
                "Eiffel (programming language)|Eiffel",
                "Scheme (programming language)|Scheme"
            ],
            "influenced": [
                "Clojure",
                "Rust (programming language)|Rust",
                "Scheme (programming language)|Scheme"
            ],
            "platform": [
                "x86",
                "PowerPC",
                "SPARC",
                "MIPS architecture|MIPS",
                "ARM architecture|ARM"
            ],
            "operating system": "Cross-platform",
            "license": "MIT License|MIT or Apache License 2.0|Apache 2.0",
            "file ext": ".rkt",
            "website": "https://racket-lang.org/",
            "frequently updated": "yes",
            "standard": [
                "R5RS",
                "R6RS"
            ]
        }
    },
    {
        "id": 528,
        "name": "Raku (programming language)",
        "url": "https://en.wikipedia.org/wiki/Raku_(programming_language)",
        "summary": "<p><b>Raku</b> is a member of the Perl family of programming languages. Formerly known as <b>Perl 6</b>, it was renamed in October 2019. Raku introduces elements of many modern and historical languages. Compatibility with Perl was not a goal, though a compatibility mode is part of the specification. The design process for Raku began in 2000. </p>",
        "infobox": {
            "name": "Raku",
            "logo": "File:Camelia.svg|250px",
            "logo size": "250px",
            "logo alt": [
                "Camelia",
                "the Raku mascot"
            ],
            "logo caption": [
                "Camelia",
                "the Raku mascot"
            ],
            "paradigm": "Multi-paradigm",
            "family": "Perl",
            "designer": "Larry Wall",
            "developer": "Raku community",
            "latest release version": "v6.d \"Diwali\"",
            "latest release date": "df|=|yes|2019|07|17",
            "year": "df|=|yes|2015|12|25",
            "typing": [
                "dynamic typing|Dynamic",
                "gradual typing|gradual"
            ],
            "implementations": "Rakudo",
            "influenced by": [
                "Perl",
                "Ruby (programming language)|Ruby",
                "Smalltalk",
                "Haskell (programming language)|Haskell ",
                "JavaScript"
            ],
            "influenced": [
                "Perl",
                "Haskell (programming language)|Haskell",
                "AntLang"
            ],
            "operating system": "Cross-platform",
            "license": "GNU General Public License or Artistic License | Artistic License 2",
            "file extensions": [
                ".p6",
                ".pm6",
                ".pod6",
                ".t6",
                ".raku",
                ".rakumod",
                ".rakudoc",
                ".rakutest"
            ],
            "website": "raku.org"
        }
    },
    {
        "id": 529,
        "name": "Rapira",
        "url": "https://en.wikipedia.org/wiki/Rapira",
        "summary": "<dl><dd><i>Rapira is also a name for the T-12 antitank gun.</i></dd></dl><p><b>Rapira</b> (Russian: <span lang=\"ru\">Рапира</span>, rapier) is an educational procedural programming language developed in the Soviet Union and implemented on Agat computer, PDP-11 clones (Electronika, DVK, BK series) and Intel-8080/Z80 clones (Korvet).  It was an interpreted language with dynamic type system and high level constructions.  The language originally had a Russian-based set of keywords, but English and Moldovan were added later.  Also, it was more elegant and easier to use than existing Pascal implementations of the time. </p><p>Rapira was used in teaching computer programming in Soviet schools.  The programming environment included a text editor and an integrated debugger.\n</p><p>Sample program:\n</p>\n<pre>ПРОЦ СТАРТ()\n    ВЫВОД: 'Привет, мир!!!'\nКОН ПРОЦ\n</pre>\n<p>The same, but using the English lexics [sic, from the article referenced below]:\n</p>\n<pre>proc start()\n     output: 'Hello, world!!!';\nend proc\n</pre>\n<p>Rapira's ideology was based on such languages as POP-2 and SETL, with strong influences from ALGOL.\n</p><p>Consequently, for example, Rapira implements a very strong, flexible and interesting data structure, so-named 'tuples'. Actually, tuples in Rapira are heterogeneous lists with such allowed operations as indexing, joining, length count, getting of sublist, easy comparison, etc.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 530,
        "name": "Ratfiv",
        "url": "https://en.wikipedia.org/wiki/Ratfiv",
        "summary": "<p><b>Ratfiv</b> is an enhanced version of the Ratfor programming language, a preprocessor for Fortran designed to give it C-like capabilities. Fortran was widely used for scientific programming but had very basic control-flow primitives (\"do\" and \"goto\") and no \"macro\" facility which limited its expressiveness. </p><p>The name of the language is a pun (<i>Ratfor</i> (RATional FORtran) -&gt; \"Rat Four\" -&gt; \"Rat Five\" -&gt; <i>RatFiv</i>).\n</p><p>Ratfiv was developed by Bill Wood at the Institute for Cancer Research, Philadelphia, PA in the early 1980s and released on several DECUS (Digital Equipment Users Group) SIG (Special Interest Group) tapes.  It is based on the original Ratfor by B. Kernighan and P. J. Plauger, with rewrites and enhancements by David Hanson and friends (U. of Arizona), Joe Sventek and Debbie Scherrer (Lawrence Berkeley National Laboratory).\n</p><p>Ratfiv V2.1 was distributed on the DECUS RSX82a SIG tape.</p>",
        "infobox": "N/A"
    },
    {
        "id": 531,
        "name": "Ratfor",
        "url": "https://en.wikipedia.org/wiki/Ratfor",
        "summary": "<p><b>Ratfor</b> (short for <i>Rational Fortran</i>) is a programming language implemented as a preprocessor for Fortran 66. It provided modern control structures, unavailable in Fortran 66, to replace GOTOs and statement numbers. </p>",
        "infobox": {
            "name": "Ratfor",
            "released": "1976",
            "developer": "Brian Kernighan",
            "influenced by": [
                "Fortran",
                "C (programming language)|C"
            ],
            "website": "[http://sepwww.stanford.edu/doku.php?id=sep:software:ratfor sepwww.stanford.edu]"
        }
    },
    {
        "id": 532,
        "name": "Rc",
        "url": "https://en.wikipedia.org/wiki/Rc",
        "summary": "<p><span></span> </p>\n\n<p><b>rc</b> (for \"run commands\") is the command line interpreter for Version 10 Unix and Plan 9 from Bell Labs operating systems. It resembles the Bourne shell, but its syntax is somewhat simpler. It was created by Tom Duff, who is better known for an unusual C programming language construct (\"Duff's device\").</p><p>A port of the original rc to Unix is part of Plan 9 from User Space.  A rewrite of rc for Unix-like operating systems by Byron Rakitzis is also available but includes some incompatible changes.\n</p><p>Rc uses C-like control structures instead of the original Bourne shell's ALGOL-like structures, except that it uses an <code>if not</code> construct instead of <code>else</code>, and has a Bourne-like <code>for</code> loop to iterate over lists. In rc, all variables are lists of strings, which eliminates the need for constructs like \"<code>$@</code>\". Variables are not re-split when expanded. The language is described in Duff's paper.</p>\n\n\n",
        "infobox": {
            "name": "rc",
            "paradigm": [
                "Imperative programming|imperative",
                "Pipeline programming|pipeline"
            ],
            "year": "1989",
            "designer": "Tom Duff",
            "developer": "Bell Labs",
            "source_model": "Open source",
            "typing": "weak typing|weak",
            "dialects": "Byron's rc",
            "influenced_by": "Bourne shell",
            "influenced": [
                "es (Unix shell)|es",
                "The Inferno (operating system)|Inferno shell."
            ],
            "operating_system": [
                "Cross-platform (Version 10 Unix",
                "Plan 9 from Bell Labs|Plan 9",
                "Plan 9 from User Space)"
            ]
        }
    },
    {
        "id": 533,
        "name": "Reason (programming language)",
        "url": "https://en.wikipedia.org/wiki/Reason_(syntax_extension_for_OCaml)",
        "summary": "<p><b>Reason</b>, also known as <b>ReasonML</b>, is a syntax extension and toolchain for OCaml created by Jordan Walke at Facebook. Reason offers a syntax familiar to JavaScript programmers, and transpiles to OCaml. Statically typed Reason (or OCaml) code may be compiled to dynamically typed JavaScript using the <i>BuckleScript</i> compiler.</p><p>The Reason community officially provides ReasonReact as a solution for React based web applications.</p>",
        "infobox": {
            "name": "Reason",
            "released": "2016|5|16",
            "latest release version": "3.6.0",
            "latest release date": [
                "March 5",
                "2020"
            ],
            "designer": "Jordan Walke",
            "website": "https://reasonml.github.io/",
            "license": "MIT License",
            "file_ext": [
                ".re",
                ".rei"
            ]
        }
    },
    {
        "id": 534,
        "name": "Red (programming language)",
        "url": "https://en.wikipedia.org/wiki/Red_(programming_language)",
        "summary": "<p><b>Red</b> is a programming language designed to overcome the limitations of the programming language Rebol. Red was introduced in 2011 by Nenad Rakocevic, and is both an imperative and functional programming language. Its syntax and general usage overlaps that of the interpreted Rebol language. </p><p>The implementation choices of Red intend to create a full stack programming language: Red can be used for extremely high-level programming (DSLs and GUIs) as well as low-level programming (operating systems and device drivers). Key to the approach is that the language has two parts: <i>Red/System</i> and <i>Red</i>.\n</p>\n<ul><li><i>Red/System</i> is similar to C, but packaged into a Rebol lexical structure –  for example, one would write <code class=\"mw-highlight mw-highlight-lang-smalltalk\" dir=\"ltr\"><span>if</span> <span>x</span> <span>&gt;</span> <span>y</span> [<span>print</span> <span>\"Hello\"</span>]</code> instead of <code class=\"mw-highlight mw-highlight-lang-c\" dir=\"ltr\"><span>if</span> <span>(</span><span>x</span> <span>&gt;</span> <span>y</span><span>)</span> <span>{</span><span>printf</span><span>(</span><span>\"Hello</span><span>\\n</span><span>\"</span><span>);}</span></code>.</li>\n<li><i>Red</i> is a homoiconic language capable of meta-programming, with semantics similar to Rebol's. Red's runtime library is written in Red/System, and uses a hybrid approach: it compiles what it can deduce statically and uses an embedded interpreter otherwise. The project roadmap includes a just-in-time compiler for cases in between, but this has not yet been implemented.</li></ul><p>Red seeks to remain independent of any other toolchain; it does its own code generation. It is therefore possible to cross-compile Red programs from any platform it supports to any other, via a command-line switch. Both Red and Red/System are distributed as open-source software under the modified BSD license. The runtime library is distributed under the more permissive Boost Software License.\n</p><p>By version 0.6.4 Red includes a garbage collector \"the Simple GC\".</p>",
        "infobox": {
            "name": "Red",
            "logo": "Red Language Tower Logo.png",
            "paradigm": [
                "Imperative programming|imperative",
                "functional programming|functional",
                "symbolic programming|symbolic"
            ],
            "designer": "Nenad Rakocevic",
            "developer": "Nenad Rakocevic",
            "latest release date": [
                "December 7",
                "2018"
            ],
            "license": "modified BSD license|modified BSD and Boost Software License|Boost",
            "website": "Official URL",
            "logo_size": "150px",
            "logo_alt": "Red Logo (stylized Tower of Hanoi)",
            "year": "2011",
            "latest_release_version": "0.6.4 (Alpha software|Alpha)",
            "influenced_by": [
                "Rebol",
                "Scala (programming language)|Scala",
                "Lua (programming language)|Lua"
            ],
            "operating_system": [
                "Linux",
                "Windows",
                "OS X",
                "Syllable Desktop (operating system)|Syllable"
            ],
            "file_ext": [
                ".red",
                ".reds"
            ],
            "working state": "Red Alpha software|Alpha Red/System Beta Software|Beta"
        }
    },
    {
        "id": 535,
        "name": "Rlab",
        "url": "https://en.wikipedia.org/wiki/Rlab",
        "summary": "<p><b>Rlab</b> is an interactive, interpreted numerical computation program and its core programming language, written by Ian Searle. Rlab (the language) is very high level and is intended to provide fast prototyping and program development, as well as easy data-visualization, and processing. </p><p>Rlab was not designed as a clone of MATLAB. However, as Rlab (the program) is intended to provide a good experimental environment (or laboratory) in which to do matrix math, the programming language possesses similar operators and concepts and could be called <i>MATLAB-like</i>.\n</p><p>Rlab borrows some of the best features of the MATLAB language but provides them through a different syntax that has been modified in order to be more expressive while reducing ambiguity. The variable scoping rules facilitate the creation of larger programs and re-usable program libraries. A heterogeneous associative array datatype has been added to allow users to create and operate on arbitrary data structures. The fundamental data type is the dense floating point matrix (either real or complex), though string and sparse numerical matrices (both real and complex) are also provided.\n</p><p>Rlab 2.1 is no longer under active development. Binary versions are available for Linux and for Windows, and source code is available under the GPL.\n</p><p>Rlab 2.2 has been released as a part of the project <i><b>rlabplus</b></i> by Marijan Koštrun.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 536,
        "name": "Robot Battle",
        "url": "https://en.wikipedia.org/wiki/Robot_Battle",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p><i><b>Robot Battle</b></i> is a programming game for Microsoft Windows where players design and code adaptable battling robots. Robot Battle takes strategy rather than reflexes, accuracy, or timing to succeed. What differentiates one robot from the next is its programming, for which the player is responsible. The game is inspired by the similar game <i>RobotWar</i>.\n</p>\n\n\n",
        "infobox": {
            "image": "Image:Image-Robot Battle Logo.png|''Robot Battle'' Logo.",
            "developer": "Brad Schick",
            "publisher": "GarageGames",
            "released": "2002",
            "genre": "Programming game",
            "modes": "Single-player",
            "platforms": "Microsoft Windows|Windows"
        }
    },
    {
        "id": 537,
        "name": "Ruby (programming language)",
        "url": "https://en.wikipedia.org/wiki/Ruby_(programming_language)",
        "summary": "<p><b>Ruby</b> is an interpreted, high-level, general-purpose programming language. It was designed and developed in the mid-1990s by Yukihiro \"Matz\" Matsumoto in Japan. </p><p>Ruby is dynamically typed and uses garbage collection. It supports multiple programming paradigms, including procedural, object-oriented, and functional programming. According to the creator, Ruby was influenced by Perl, Smalltalk, Eiffel, Ada, Basic, and Lisp.</p>",
        "infobox": {
            "title": "Ruby",
            "logo": "File:Ruby logo.svg|frameless|100px",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: functional programming|functional",
                "imperative programming|imperative",
                "object-oriented programming|object-oriented",
                "reflective programming|reflective"
            ],
            "designer": "Yukihiro Matsumoto",
            "developer": [
                "Yukihiro Matsumoto",
                "et al."
            ],
            "typing": [
                "Duck typing|Duck",
                "Dynamic typing|dynamic",
                "Strong typing|strong"
            ],
            "scope": [
                "Lexical",
                "sometimes dynamic"
            ],
            "implementations": [
                "Ruby MRI",
                "YARV",
                "Rubinius",
                "MagLev (software)|MagLev",
                "JRuby",
                "MacRuby",
                "RubyMotion",
                "Mruby",
                "IronRuby"
            ],
            "influenced": [
                "Clojure",
                "CoffeeScript",
                "Crystal (programming language)|Crystal",
                "D (programming language)|D",
                "Elixir (programming language)|Elixir",
                "Groovy (programming language)|Groovy",
                "Ioke (programming language)|Ioke",
                "Julia (programming language)|Julia",
                "Mirah (programming language)|Mirah",
                "Nu (programming language)|Nu",
                "Ring",
                "Rust (programming language)|Rust",
                "Swift (programming language)|Swift"
            ],
            "license": [
                "Ruby License",
                "GNU General Public License|GPLv2",
                "or 2-clause BSD license"
            ],
            "website": "url|https://www.ruby-lang.org/",
            "wikibooks": "Ruby Programming",
            "slogan": "''A programmer's best friend''",
            "year": "start date and age|1995",
            "programming_language": "C (programming language)|C",
            "influenced_by": [
                "Ada (programming language)|Ada",
                "BASIC|Basic",
                "C++",
                "CLU (programming language)|CLU",
                "Dylan (programming language)|Dylan",
                "Eiffel (programming language)|Eiffel",
                "Lisp (programming language)|Lisp",
                "Lua (programming language)|Lua",
                "Perl",
                "Python (programming language)|Python",
                "Smalltalk"
            ],
            "operating_system": "Cross-platform",
            "file_ext": ".rb"
        }
    },
    {
        "id": 538,
        "name": "Rust (programming language)",
        "url": "https://en.wikipedia.org/wiki/Rust_(programming_language)",
        "summary": "<p><b>Rust</b> is a multi-paradigm programming language focused on performance and safety, especially safe concurrency. Rust is syntactically similar to C++, and provides memory safety without using garbage collection. </p><p>Rust was originally designed by Graydon Hoare at Mozilla Research, with contributions from Dave Herman, Brendan Eich, and others. The designers refined the language while writing the Servo layout or browser engine, and the Rust compiler. The compiler is free and open-source software dual-licensed under the MIT License and Apache License 2.0.\n</p><p>Rust has been the \"most loved programming language\" in the Stack Overflow Developer Survey every year since 2016.</p>\n\n\n",
        "infobox": {
            "name": "Rust",
            "logo": "Rust programming language black logo.svg",
            "logo caption": "Official Rust logo",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Concurrent programming|concurrent",
                "Functional programming|functional",
                "Generic programming|generic",
                "Imperative programming|imperative",
                "Structured programming|structured"
            ],
            "year": "2010|07|07",
            "designer": "Graydon Hoare",
            "latest release version": "1.45.0",
            "latest release date": "2020|7|16",
            "typing": [
                "Type inference|Inferred",
                "Affine type system|affine",
                "Nominal type system|nominal",
                "Static typing|static",
                "Strong and weak typing|strong"
            ],
            "programming language": "Rust",
            "platform": [
                "ARM architecture|ARM",
                "IA-32",
                "x86-64",
                "MIPS architecture|MIPS",
                "PowerPC",
                "SPARC",
                "RISC-V"
            ],
            "operating system": [
                "Linux",
                "macOS",
                "Microsoft Windows|Windows",
                "FreeBSD",
                "OpenBSD",
                "Redox (operating system)|Redox",
                "Android (operating system)|Android",
                "iOS"
            ],
            "license": "MIT License|MIT or Apache License 2.0|Apache 2.0",
            "file ext": [
                ".rs",
                ".rlib"
            ],
            "website": "www.rust-lang.org",
            "influenced by": [
                "Alef (programming language)|Alef",
                "C Sharp (programming language)|C#",
                "C++",
                "Cyclone (programming language)|Cyclone",
                "Erlang (programming language)|Erlang",
                "Haskell (programming language)|Haskell",
                "Limbo (programming language)|Limbo",
                "Newsqueak",
                "OCaml",
                "Ruby (programming language)|Ruby",
                "Scheme (programming language)|Scheme",
                "Standard ML",
                "Swift (programming language)|Swift"
            ],
            "influenced": [
                "Crystal (programming language)|Crystal",
                "Zig",
                "Elm (programming language)|Elm",
                "Idris (programming language)|Idris",
                "SPARK (programming language)|Spark",
                "Swift (programming language)|Swift",
                "Project Verona"
            ]
        }
    },
    {
        "id": 539,
        "name": "S-Lang (programming language)",
        "url": "https://en.wikipedia.org/wiki/S-Lang",
        "summary": "<p>The <b>S-Lang programming library</b> is a software library for Unix, Windows, VMS, OS/2, and Mac OS X.  It provides routines for embedding an interpreter for the S-Lang scripting language, and components to facilitate the creation of text-based applications.  The latter class of functions include routines for constructing and manipulating keymaps, an interactive line-editing facility, and both low and high-level screen/terminal management functions.  It is distributed under the terms of the GNU General Public License. </p>",
        "infobox": {
            "name": "S-Lang",
            "screenshot": "JED-editor-slang-source.png",
            "caption": [
                "S-Lang based editor",
                "JED_(text_editor)|JED"
            ],
            "developer": "John E. Davis",
            "latest release version": "2.3.2",
            "latest release date": "4 March 2018",
            "programming language": "S-Lang scripting language",
            "operating system": "POSIX",
            "genre": "Widget toolkit",
            "license": "GPL",
            "website": "Official URL"
        }
    },
    {
        "id": 540,
        "name": "S-PLUS",
        "url": "https://en.wikipedia.org/wiki/S-PLUS",
        "summary": "<p><b>S-PLUS</b> is a commercial implementation of the S programming language sold by TIBCO Software Inc. </p><p>It features object-oriented programming capabilities and advanced analytical algorithms.\n</p><p>Due to the increasing popularity of the open source S successor R, TIBCO Software released the TIBCO Enterprise Runtime for R (TERR) as an alternative R interpreter.</p>",
        "infobox": {
            "name": "S-PLUS",
            "developer": "TIBCO Software Inc.",
            "latest_release_version": "8.2",
            "latest_release_date": "release_date_and_age|2010|11",
            "operating_system": [
                "Microsoft Windows|Windows",
                "Unix/Linux"
            ],
            "genre": "Statistical package",
            "license": "Proprietary software|Proprietary"
        }
    },
    {
        "id": 541,
        "name": "S/SL programming language",
        "url": "https://en.wikipedia.org/wiki/S/SL_programming_language",
        "summary": "<p>The <b>Syntax/Semantic Language</b> (<b>S/SL</b>) is an executable high level specification language for recursive descent parsers, semantic analyzers and code generators developed by James Cordy, Ric Holt and David Wortman at the University of Toronto in 1980.</p><p>S/SL is a small programming language that supports cheap recursion and defines input, output, and error token names (&amp; values), semantic mechanisms (class interfaces whose methods are really escapes to routines in a host programming language but allow good abstraction in the pseudocode) and a pseudocode program that defines the syntax of the input language by the token stream the program accepts. Alternation, control flow and one-symbol look-ahead constructs are part of the language. </p><p>The S/SL processor compiles this pseudocode into a table (byte-codes) that is interpreted by the S/SL table-walker (interpreter). The pseudocode language processes the input language in LL(1) recursive descent style but extensions allow it to process any LR(k) language relatively easily.  S/SL is designed to provide excellent syntax error recovery and repair. It is more powerful and transparent than Yacc but can be slower.\n</p><p>S/SL's \"semantic mechanisms\" extend its capabilities to all phases of compiling, and it has been used to implement all phases of compilation, including scanners, parsers, semantic analyzers, code generators and virtual machine interpreters in multi-pass language processors.</p><p>S/SL has been used to implement production commercial compilers for languages such as PL/I, Euclid, Turing, Ada, and COBOL, as well as interpreters, command processors, and domain specific languages of many kinds.  It is the primary technology used in IBM's ILE/400 COBOL compiler, and the ZMailer mail transfer agent uses S/SL for defining both its mail router processing language and its RFC 822 email address validation.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 542,
        "name": "S2 (programming language)",
        "url": "https://en.wikipedia.org/wiki/S2_(programming_language)",
        "summary": "<p><b>S2 (Style System 2)</b> is an object-oriented programming language developed in the late 1990s by Brad Fitzpatrick, Martin \"Mart\" Atkins, and others for the online journaling service LiveJournal in order to allow users full control over the appearance of their pages. S2 source code is compiled into Perl, which the webserver can then execute directly for individual web page requests. </p><p>The S2 system is, at its heart, completely general and can be used for almost any web application; however there exists no documentation for the implementation of S2 within other applications, which ties it relatively closely to LiveJournal.\n</p><p>This article will make use of LiveJournal's implementation of S2 for examples. A link to detailed documentation about this implementation can be found at the bottom.\n</p>",
        "infobox": {
            "name": "S2",
            "paradigm": "object-oriented programming|Object-oriented",
            "year": "1999",
            "developer": [
                "Brad Fitzpatrick",
                "Martin Atkins"
            ],
            "latest release date": "2008",
            "website": "http://www.livejournal.com/doc/s2"
        }
    },
    {
        "id": 543,
        "name": "S3 (programming language)",
        "url": "https://en.wikipedia.org/wiki/S3_(programming_language)",
        "summary": "<p><b>S3</b> is a structured, imperative high-level computer programming language.  It was developed by the UK company International Computers Limited (ICL) for its 2900 Series mainframes. It is a system programming language with syntax influenced by ALGOL 68 but with data types and operators aligned to those offered by the 2900 Series.  It was the implementation language of the operating system VME. </p>",
        "infobox": {
            "name": "S3",
            "paradigm": [
                "Structured programming|Structured",
                "Imperative programming|imperative"
            ],
            "developer": "International Computers Limited",
            "influenced_by": "ALGOL 68"
        }
    },
    {
        "id": 544,
        "name": "SA-C (programming language)",
        "url": "https://en.wikipedia.org/wiki/SA-C_(programming_language)",
        "summary": "<p><b>Single Assignment C</b> (<b>SA-C</b>) (pronounced \"sassy\") is a member of the C programming language family designed to be directly and intuitively translatable into circuits, including FPGAs. To ease translation, SA-C does not include pointers and arithmetics thereon. To retain most of the expressiveness of C, SA-C instead features true n-dimensional arrays as first-class objects of the language. </p>",
        "infobox": "N/A"
    },
    {
        "id": 545,
        "name": "SAIL (programming language)",
        "url": "https://en.wikipedia.org/wiki/SAIL_(programming_language)",
        "summary": "<p><b>SAIL</b>, the <b>Stanford Artificial Intelligence Language</b>, was developed by Dan Swinehart and Bob Sproull of the Stanford AI Lab in 1970.  It was originally a large ALGOL 60-like language for the PDP-10 and DECSYSTEM-20. </p><p>SAIL's main feature is a symbolic data system based upon an associative store (based on the LEAP system of Jerry Feldman and Paul Rovner). Items may be stored as unordered sets or as associations (triples).  Other features include processes, events and interrupts, contexts, backtracking and record garbage collection.  It also has block-structured macros, a coroutining facility and some new data types intended for building search trees and association lists.\n</p><p>A number of interesting software systems were coded in SAIL, including some early versions of FTP and TeX, a document formatting system called PUB, and BRIGHT, a clinical database project sponsored by the National Institutes of Health.</p><p>In 1978, there were half a dozen different operating systems for the PDP-10: ITS (MIT), WAITS (Stanford), TOPS-10 (DEC), CMU TOPS-10 (Carnegie Mellon), TENEX (BBN), Tymcom-X (Tymshare), and TOPS-20 (DEC, based on TENEX).\n</p><p>SAIL was ported from WAITS to ITS so that MIT researchers could make use of software developed at Stanford University. Every port usually required the rewriting of I/O code in each application.\n</p><p><span id=\"MAINSAIL\"></span>A machine-independent version of SAIL called MAINSAIL was developed in the late 1970s and was used to develop many eCAD design tools during the 1980s.  MAINSAIL was easily portable to new processors and operating systems, and was still in limited use as of 2005.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 546,
        "name": "SAM76",
        "Error": "SAM76"
    },
    {
        "id": 547,
        "name": "SASL (programming language)",
        "url": "https://en.wikipedia.org/wiki/SASL_(programming_language)",
        "summary": "<p><b>SASL</b> (from <b>S</b>t <b>A</b>ndrews <b>S</b>tatic <b>L</b>anguage, alternatively  <b>S</b>t <b>A</b>ndrews <b>S</b>tandard <b>L</b>anguage) is a purely functional programming language developed by David Turner at the University of St Andrews in 1972, based on the applicative subset of ISWIM.  In 1976 Turner redesigned and reimplemented it as a non-strict (lazy) language.  In this form it was the foundation of Turner's later languages KRC and Miranda, but SASL appears to be untyped whereas Miranda has polymorphic types. </p><p>Burroughs Corporation used SASL to write a compiler and operating system.</p>",
        "infobox": {
            "name": "SASL",
            "paradigm": "Functional programming|functional",
            "year": "1972",
            "designer": "David Turner (computer scientist)|David Turner",
            "influenced_by": "ISWIM",
            "influenced": [
                "Kent Recursive Calculator|KRC",
                "Miranda programming language|Miranda",
                "Haskell (programming language)|Haskell"
            ]
        }
    },
    {
        "id": 548,
        "name": "SAS System",
        "url": "https://en.wikipedia.org/wiki/SAS_(software)",
        "summary": "<p><b>SAS</b> (previously \"<b>Statistical Analysis System</b>\") is a statistical software suite developed by SAS Institute for  data management, advanced analytics, multivariate analysis, business intelligence, criminal investigation, and predictive analytics. </p><p>SAS was developed at North Carolina State University from 1966 until 1976, when SAS Institute was incorporated. SAS was further in the 1980s and 1990s with the addition of new statistical procedures, additional components and the introduction of JMP. A point-and-click interface was added in version 9 in 2004. A social media analytics product was added in 2010.\n</p>",
        "infobox": {
            "name": "SAS",
            "logo": "স্যাস লোগো.png",
            "screenshot": "SAS 9 on Microsoft Windows.png",
            "caption": "SAS 9 on Microsoft Windows",
            "developer": "SAS Institute",
            "programming language": "C (programming language)|C",
            "released": "start date and age|1976",
            "latest release version": "9.4",
            "latest release date": "2013|07|10",
            "operating system": [
                "Microsoft Windows|Windows",
                "IBM mainframe",
                "Unix/Linux",
                "OpenVMS|OpenVMS Alpha"
            ],
            "genre": "Numerical analysis",
            "license": "Proprietary software|Proprietary",
            "website": "https://www.sas.com/en_us/home.html"
        }
    },
    {
        "id": 549,
        "name": "SETL",
        "url": "https://en.wikipedia.org/wiki/SETL",
        "summary": "<p><b>SETL</b> (SET Language) is a very high-level programming language based on the mathematical theory of sets.  It was originally developed by (Jack) Jacob T. Schwartz at the New York University (NYU) Courant Institute of Mathematical Sciences in the late 1960s. </p>",
        "infobox": {
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Imperative programming|imperative",
                "Procedural programming|procedural",
                "Structured programming|structured",
                "Object-oriented programming|object-oriented"
            ],
            "released": "1969",
            "designer": "(Jack) Jacob T. Schwartz",
            "developer": "Courant Institute of Mathematical Sciences",
            "latest release version": "1.1",
            "latest release date": "2005|01|07",
            "typing": "Type system#DYNAMIC|Dynamic",
            "website": "setl.org",
            "influenced_by": "ALGOL 60",
            "influenced": [
                "SETL2",
                "ISETL",
                "SETLX",
                "ABC (programming language)|ABC"
            ]
        }
    },
    {
        "id": 550,
        "name": "SIGNAL (programming language)",
        "url": "https://en.wikipedia.org/wiki/SIGNAL_(programming_language)",
        "summary": "<p><b>SIGNAL</b> is a programming language based on synchronized data-flow (flows + synchronization): a process is a set of equations on elementary flows describing both data and control.</p><p>The SIGNAL formal model provides the capability to describe systems with several clocks  (polychronous systems) as relational specifications. Relations are useful as partial specifications and as specifications of non-deterministic devices (for instance a non-deterministic bus) or external processes (for instance an unsafe car driver). </p><p>Using SIGNAL allows one to specify an application, to design an architecture, to refine detailed components down to RTOS or hardware description. The SIGNAL model supports a design methodology which goes from specification to implementation, from abstraction to concretization, from synchrony to asynchrony.\n</p><p>SIGNAL has been mainly developed in INRIAEspresso team since the 1980s, at the same time as similar programming languages, Esterel and Lustre.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 551,
        "name": "SIMSCRIPT",
        "url": "https://en.wikipedia.org/wiki/SIMSCRIPT",
        "summary": "<p><b>SIMSCRIPT</b> is a free-form, English-like general-purpose simulation language conceived by Harry Markowitz and Bernard Hausner at the RAND Corporation in 1962. It was implemented as a Fortran preprocessor on the IBM 7090 and was designed for large discrete event simulations. It influenced Simula.</p><p>Though earlier versions were released into the public domain, SIMSCRIPT was commercialized by Markowitz's company, California Analysis Center, Inc. (CACI), which produced proprietary versions SIMSCRIPT I.5 and SIMSCRIPT II.5. </p>",
        "infobox": "N/A"
    },
    {
        "id": 552,
        "name": "SISAL",
        "url": "https://en.wikipedia.org/wiki/SISAL",
        "summary": "<p><b>SISAL</b> (\"<b>Streams and Iteration in a Single Assignment Language</b>\") is a general-purpose single assignment functional programming language with strict semantics, implicit parallelism, and efficient array handling.  SISAL outputs a dataflow graph in Intermediary Form 1 (IF1). It was derived from VAL (Value-oriented Algorithmic Language, designed by Jack Dennis), and adds recursion and finite streams. It has a Pascal-like syntax and was designed to be a common high-level language for numerical programs on a variety of multiprocessors.\n</p>",
        "infobox": {
            "name": "SISAL",
            "paradigm": [
                "functional programming|functional",
                "dataflow"
            ],
            "year": "1983",
            "designer": "James McGraw",
            "developer": [
                "James McGraw et al.",
                "at University of Manchester",
                "Lawrence Livermore National Laboratory|LLNL",
                "Colorado State University",
                "and Digital Equipment Corporation|DEC"
            ],
            "typing": [
                "Static typing|static",
                "Strongly-typed programming language|strong"
            ],
            "implementations": [
                "osc",
                "sisalc"
            ],
            "influenced_by": [
                "VAL",
                "Pascal (programming language)|Pascal",
                "C (programming language)|C",
                "Fortran"
            ],
            "influenced": [
                "Haskell (programming language)|Haskell",
                "April 2016 SAC programming language|SAC"
            ]
        }
    },
    {
        "id": 553,
        "name": "SLIP (programming language)",
        "url": "https://en.wikipedia.org/wiki/SLIP_(programming_language)",
        "summary": "<p><b>SLIP</b> is a list processing computer programming language, invented by Joseph Weizenbaum in the 1960s.  The name <i>SLIP</i> stands for <b>S</b>ymmetric <b>LI</b>st <b>P</b>rocessor.  It was first implemented as an extension to the Fortran programming language, and later embedded into MAD and ALGOL. The best known program written in the language is ELIZA, an early natural language processing computer program created by Weizenbaum  at the MIT Artificial Intelligence Laboratory.</p>",
        "infobox": "N/A"
    },
    {
        "id": 554,
        "name": "SMALL",
        "url": "https://en.wikipedia.org/wiki/SMALL",
        "summary": "<p><b>Small Machine Algol Like Language</b> (<b>SMALL</b>), is a computer programming language developed by Dr. Nevil Brownlee of the University of Auckland. </p>",
        "infobox": {
            "name": "Small Machine Algol Like Language",
            "paradigms": [
                "Procedural programming|Procedural",
                "Imperative programming|imperative",
                "Structured programming|structured",
                "Object-oriented programming|object-oriented"
            ],
            "family": "ALGOL",
            "designer": "Nevil Brownlee",
            "developer": "University of Auckland",
            "released": "1980",
            "latest release version": "Final",
            "latest release date": "1985",
            "programming language": [
                "Fortran IV",
                "SMALL"
            ],
            "discontinued": "Yes",
            "platform": [
                "Mainframe computer|Mainframes: Burroughs Corporation|Burroughs B6700",
                "Digital Equipment Corporation|DEC PDP-10"
            ],
            "operating system": [
                "TOPS-10",
                "VM/Conversational Monitor System|CMS"
            ],
            "influenced by": "ALGOL"
        }
    },
    {
        "id": 555,
        "name": "SNOBOL",
        "url": "https://en.wikipedia.org/wiki/SNOBOL",
        "summary": "<p><b>SNOBOL</b> (\"StriNg Oriented and symBOlic Language\") is a series of programming languages developed between 1962 and 1967 at AT&amp;T Bell Laboratories by David J. Farber, Ralph E. Griswold and Ivan P. Polonsky, culminating in SNOBOL4.  It was one of a number of text-string-oriented languages developed during the 1950s and 1960s; others included COMIT and TRAC. </p><p>SNOBOL4 stands apart from most programming languages of its era by having patterns as a first-class data type (<i>i.e.</i> a data type whose values can be manipulated in all ways permitted to any other data type in the programming language) and by providing operators for pattern concatenation and alternation. SNOBOL4 patterns are a type of object and admit various manipulations, much like later object-oriented languages such as JavaScript whose patterns are known as regular expressions. In addition SNOBOL4 strings generated during execution can be treated as programs and either interpreted or compiled and executed (as in the eval function of other languages).\n</p><p>SNOBOL4 was quite widely taught in larger US universities in the late 1960s and early 1970s and was widely used in the 1970s and 1980s as a text manipulation language in the humanities.\n</p><p>In the 1980s and 1990s its use faded as newer languages such as AWK and Perl made string manipulation by means of regular expressions fashionable. SNOBOL4 patterns subsume BNF grammars, which are equivalent to context-free grammars and more powerful than regular expressions. \nThe \"regular expressions\" in current versions of AWK and Perl are in fact extensions of regular expressions in the traditional sense, but regular expressions, unlike SNOBOL4 patterns, are not recursive, which gives a distinct computational advantage to SNOBOL4 patterns. (Recursive expressions did appear in Perl 5.10, though, released in December 2007.)\n</p><p>One of the designers of SNOBOL, Ralph Griswold, designed successors to SNOBOL4 called SL5 and Icon, which combined the backtracking of SNOBOL4 pattern matching with more standard ALGOL-like structuring, as well as adding some features of their own.\n</p>",
        "infobox": {
            "name": "SNOBOL",
            "paradigm": [
                "imperative programming|Imperative",
                "unstructured programming|unstructured"
            ],
            "year": "1962",
            "designer": [
                "David J. Farber",
                "Ralph E. Griswold and Ivan P. Polonsky"
            ],
            "developer": [
                "David J. Farber",
                "Ralph E. Griswold",
                "Ivan P. Polonsky",
                "and Bell Labs"
            ],
            "latest release version": "SNOBOL4",
            "latest release date": "1967",
            "implementations": [
                "SNOBOL",
                "SPITBOL"
            ],
            "influenced by": "COMIT",
            "influenced": [
                "AWK",
                "bs (programming language)|bs",
                "Icon (programming language)|Icon",
                "Lua (programming language)|Lua",
                "SL5"
            ]
        }
    },
    {
        "id": 556,
        "name": "SOPHAEROS",
        "url": "https://en.wikipedia.org/wiki/SOPHAEROS",
        "summary": "<p><b>SOPHAEROS</b> is a computer code, used by the AECL and French Nuclear program to simulate the transfer of fission products in the reactor chamber.  It models fission product behaviour using a set of aerosol dynamic rules, and is used by AECL in fuel channel safety analyses. </p>",
        "infobox": "N/A"
    },
    {
        "id": 557,
        "name": "SP/k",
        "url": "https://en.wikipedia.org/wiki/SP/k",
        "summary": "<p><b>SP/k</b> is a programming language developed circa 1974 by R.C. Holt, D.B. Wortman, D.T. Barnard and J.R. Cordy as a subset of the PL/I programming language designed for teaching programming. It was used for about a decade at over 40 universities, schools, and research laboratories in Canada and the United States. </p><p>SP/k was one of the first languages specifically designed to encourage structured programming. The features of SP/k were chosen to encourage structured problem solving by computers, to make the language easy to learn and use, to eliminate confusing and redundant constructs, and to make the language easy to compile. The resulting language was suitable for introducing programming concepts used in various applications, including business data processing, scientific calculations and non-numeric computation.\n</p><p>SP/k is actually a sequence of language subsets called SP/1, SP/2, ... SP/8. Each subset introduces new programming language constructs while retaining all the constructs of preceding subsets, forming a stepwise system for teaching computer programming. Each subset is precisely defined and self-contained, and can be learned or implemented without the following subsets. This allows for various levels of programming education. The design and philosophy of SP/k was a strong influence on the Turing programming language.\n</p>",
        "infobox": {
            "name": "SP/k",
            "paradigm": [
                "structured programming|structured",
                "imperative programming|imperative"
            ],
            "year": "1974",
            "designer": [
                "Ric Holt|R.C. Holt",
                "D.B. Wortman",
                "D.T. Barnard",
                "James Cordy|J.R. Cordy"
            ],
            "developer": [
                "Ric Holt|R.C. Holt",
                "D.B. Wortman",
                "D.T. Barnard",
                "James Cordy|J.R. Cordy"
            ],
            "latest_release_version": "SP/8",
            "typing": [
                "static typing|static",
                "strong typing|strong"
            ],
            "influenced_by": "PL/I",
            "influenced": "Turing (programming language)|Turing"
        }
    },
    {
        "id": 558,
        "name": "SPARK (programming language)",
        "url": "https://en.wikipedia.org/wiki/SPARK_(programming_language)",
        "summary": "<p><b>SPARK</b> is a formally defined computer programming language based on the Ada programming language, intended for the development of high integrity software used in systems where predictable and highly reliable operation is essential. It facilitates the development of applications that demand safety, security, or business integrity. </p><p>Originally, there were three versions of the SPARK language (SPARK83, SPARK95, SPARK2005) based on Ada 83, Ada 95 and Ada 2005 respectively.\n</p><p>A fourth version of the SPARK language, SPARK 2014, based on Ada 2012, was released on April 30, 2014. SPARK 2014 is a complete re-design of the language and supporting verification tools.\n</p><p>The SPARK language consists of a well-defined subset of the Ada language that uses contracts to describe the specification of components in a form that is suitable for both static and dynamic verification.\n</p><p>In SPARK83/95/2005, the contracts are encoded in Ada comments (and so are ignored by any standard Ada compiler), but are processed by the SPARK \"Examiner\" and its associated tools.\n</p><p>SPARK 2014, in contrast, uses Ada 2012's built-in \"aspect\" syntax to express contracts, bringing them into the core of the language. The main tool for SPARK 2014 (GNATprove) is based on the GNAT/GCC infrastructure, and re-uses almost the entirety of the GNAT Ada 2012 front-end.\n</p>",
        "infobox": {
            "name": "SPARK",
            "logo": "File:Sparkada.jpg|250px",
            "paradigm": "Multi-paradigm programming language|Multi-paradigm",
            "developer": "Altran and AdaCore",
            "latest_release_version": "17.1",
            "latest_release_date": "2017|03|14",
            "typing": [
                "static typing|static",
                "Strongly typed programming language|strong",
                "type safety|safe",
                "nominative type system|nominative"
            ],
            "implementations": [
                "SPARK Pro",
                "SPARK GPL Edition"
            ],
            "influenced_by": [
                "Ada (programming language)|Ada",
                "Eiffel (programming language)|Eiffel"
            ],
            "operating_system": [
                "Cross-platform: Linux",
                "Microsoft Windows",
                "Mac OS X"
            ],
            "license": "GNU General Public License|GPLv3",
            "website": "[http://www.adacore.com/sparkpro/ SPARK Pro Toolset] [http://libre.adacore.com/ \"Libre\" SPARK GPL Edition]"
        }
    },
    {
        "id": 559,
        "name": "SPITBOL compiler",
        "url": "https://en.wikipedia.org/wiki/SPITBOL",
        "summary": "<p><b>SPITBOL</b> (<b>Sp</b>eedy <b>I</b>mplemen<b>t</b>ation of SNO<b>BOL</b>) is a compiled implementation of the SNOBOL4 programming language. Originally targeted for the IBM System/360 and System/370 family of computers, it has now been ported to most major microprocessors including the SPARC. It was created by Robert Dewar and Ken Belcher, who were then at the Illinois Institute of Technology. </p><p>Prior to the development of SPITBOL, SNOBOL4 was thought to be slow, memory-intensive, and impossible to compile due to its dynamic nature. While delayed binding prevents everything from being determined at compile time, SPITBOL adopts various strategies for making decisions as early as possible. Recent versions of the SPITBOL compiler are available. Since 2001 the source code for the original SPITBOL 360 compiler has been made available under the GNU General Public License.</p><p>MACRO SPITBOL is an implementation of SPITBOL written in the 1970s by Robert Dewar and Anthony P. McCann. MACRO SPITBOL is coded in MINIMAL, an assembly language for an abstract machine. The instruction set is carefully defined to allow some latitude in its implementation, so that hardware operations favorable to string processing can be exploited.</p><p>An implementation of MINIMAL that was designed for interpretation on microcomputers was done by translating MINIMAL into MICRAL using a translator that was itself implemented in SPITBOL. The MICRAL version of MACRO SPITBOL, together with the MICRAL interpreter ran in under 40K bytes. This extreme object code compression of MICRAL is achieved using a set of machine code macro substitutions that minimizes the space required for the object code and macro table. The complexity of known algorithms for an optimal solution to this problem are high, but efficient heuristics attain near-optimal results.</p><p>The source code for MACRO SPITBOL was released under the GNU General Public License on April 17, 2009.</p>",
        "infobox": "N/A"
    },
    {
        "id": 560,
        "name": "SQL",
        "url": "https://en.wikipedia.org/wiki/SQL",
        "summary": "<p><b>SQL</b> (<span> <span>(<span><span><span></span>listen</span></span>)</span></span> <i>S-Q-L</i>, <span></span> \"sequel\"; <b>Structured Query Language</b>) is a domain-specific language used in programming and designed for managing data held in a relational database management system (RDBMS), or for stream processing in a relational data stream management system (RDSMS). It is particularly useful in handling structured data, i.e. data incorporating relations among entities and variables. </p><p>SQL offers three main advantages over older read–write APIs such as ISAM or VSAM. Firstly, it introduced the concept of accessing many records with one single command. Secondly, it eliminates the need to specify <i>how</i> to reach a record, e.g. with or without an index. Finally, SQL uses a human-readable syntax that allows users to be quickly productive without a requirement for long-term, technical training.\n</p><p>Originally based upon relational algebra and tuple relational calculus, SQL consists of many types of statements, which may be informally classed as sublanguages, commonly: a data query language (DQL), a data definition language (DDL), a data control language (DCL), and a data manipulation language (DML). The scope of SQL includes data query, data manipulation (insert, update and delete), data definition (schema creation and modification), and data access control. Although SQL is essentially a declarative language (4GL), it also includes procedural elements.\n</p><p>SQL was one of the first commercial languages to utilize Edgar F. Codd’s relational model. The model was described in his influential 1970 paper, \"A Relational Model of Data for Large Shared Data Banks\".  Despite not entirely adhering to the relational model as described by Codd, it became the most widely used database language.</p><p>SQL became a standard of the American National Standards Institute (ANSI) in 1986, and of the International Organization for Standardization (ISO) in 1987. Since then the standard has been revised to include a larger set of features. Despite the existence of standards, most SQL code requires at least some changes before being ported to different database systems.\n</p>",
        "infobox": {
            "name": "SQL (Structured Query Language)",
            "paradigm": "Declarative programming|Declarative",
            "family": "Query language",
            "released": "1974",
            "designer": "Donald D. Chamberlin<br />Raymond F. Boyce",
            "developer": "International Organization for Standardization|ISO/International Electrotechnical Commission|IEC",
            "typing": [
                "Static typing|Static",
                "strong typing|strong"
            ],
            "implementations": "List of relational database management systems|Many",
            "dialects": "flatlist|\n* SQL-86\n* SQL-89\n* SQL-92\n* SQL:1999\n* SQL:2003\n* SQL:2006\n* SQL:2008\n* SQL:2011\n* SQL:2016",
            "influenced": [
                "Contextual Query Language|CQL",
                "Language Integrated Query|LINQ",
                "SPARQL",
                "SOQL",
                "PowerShell",
                "Java Persistence Query Language|JPQL",
                "Java Object Oriented Querying|jOOQ",
                "N1QL"
            ],
            "website": "https://www.iso.org/standard/63555.html",
            "latest_release_version": "SQL:2016",
            "latest_release_date": "2016|12",
            "influenced_by": "Datalog",
            "operating_system": "Cross-platform",
            "wikibooks": "Structured Query Language"
        }
    },
    {
        "id": 561,
        "name": "SQR",
        "url": "https://en.wikipedia.org/wiki/SQR",
        "summary": "<p>SQR (Hyperion SQR Production Reporting, Part of OBIEE) is a programming language designed for generating reports from database management system management systems. The name is an abbreviation of Structured Query Reporter, which suggests its relationship to SQL (Structured Query Language). Any SQL statement can be embedded in an SQR program. </p>",
        "infobox": "N/A"
    },
    {
        "id": 562,
        "name": "SR (programming language)",
        "url": "https://en.wikipedia.org/wiki/SR_(programming_language)",
        "summary": "<p><b>SR</b> (short for <b>Synchronizing Resources</b>) is a programming language designed for concurrent programming. </p><p><i>Resources</i> encapsulate processes and the variables they share, and can be separately compiled. <i>Operations</i> provide the primary mechanism for process interaction.\n</p><p>SR provides a novel integration of the mechanisms for invoking and servicing operations. Consequently, it supports local and remote procedure call, rendezvous, message passing, dynamic process creation, multicast, semaphores and shared memory.\n</p><p>Version 2.2 has been ported to the Apollo, DECstation, Data General AViiON, HP 9000 Series 300, Multimax, NeXT, PA-RISC, RS/6000, Sequent Symmetry, SGI IRIS, Sun-3, Sun-4 and others.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 563,
        "name": "SYMPL",
        "url": "https://en.wikipedia.org/wiki/SYMPL",
        "summary": "<p><b>SYMPL</b> is an obsolete programming language developed by the Control Data Corporation (CDC) for use on the CDC 6000 series computer systems in the 1970s and 1980s.  It was based on a subset of CDCs version of JOVIAL, as an alternative to assembly language.  A number of important CDC software products were implemented in SYMPL, including compilers, libraries, a full-screen editor, and major subsystems. </p><p>SYMPL is a compiled, imperative, and procedural language.  Compared to the Fortran of the day, SYMPL supports:\n</p>\n<ul><li>Stronger data typing - All variables must be declared prior to use,</li>\n<li>Data structures - Including \"based\" dynamically allocated structures,</li>\n<li>Structured programming constructs,</li>\n<li>Nested procedures,</li>\n<li>In-fix \"bead\" (bit) and character manipulation</li>\n<li>A simple macro facility</li></ul><p>Simplifications compared to JOVIAL include: fewer built-in data types, no recursive calls to procedures, and no <code>COMPOOL</code> concept.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 564,
        "name": "S (programming language)",
        "url": "https://en.wikipedia.org/wiki/S_(programming_language)",
        "summary": "<p><b>S</b> is a statistical programming language developed primarily by John Chambers and (in earlier versions) Rick Becker and Allan Wilks of Bell Laboratories.  The aim of the language, as expressed by John Chambers, is \"to turn ideas into software, quickly and faithfully\".</p><p>The modern implementation of S is R, a part of the GNU free software project. S-PLUS, a commercial product, was formerly sold by TIBCO Software.</p> \n\n",
        "infobox": {
            "name": "S",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: imperative programming|imperative",
                "object oriented programming|object oriented"
            ],
            "year": "start date and age|1976",
            "developer": [
                "Rick Becker",
                "Allan Wilks",
                "John Chambers (statistician)|John Chambers"
            ],
            "typing": [
                "type system|dynamic",
                "strong typing|strong"
            ],
            "implementations": [
                "R (programming language)|R",
                "S-PLUS"
            ],
            "influenced_by": [
                "C (programming language)|C",
                "APL (programming language)|APL",
                "Polymorphic Programming Language|PPL",
                "Fortran"
            ],
            "license": "depends on implementation",
            "[[Garbage Collected|garbage collection]]": "yes",
            "website": "webarchive |url|=|https://web.archive.org/web/20181014111802/http://ect.bell-labs.com/sl/S/ |date|=|2018-10-14 |title|=|ect.bell-labs.com/sl/S/"
        }
    },
    {
        "id": 565,
        "name": "SabreTalk",
        "url": "https://en.wikipedia.org/wiki/SabreTalk",
        "summary": "<p><b>SabreTalk</b> is a discontinued dialect of PL/I for the S/360 IBM mainframes running the TPF platform. SabreTalk was developed jointly by American Airlines, Eastern Air Lines and IBM. SabreTalk is known as PL/TPF (Programming Language for TPF).</p><p>SabreTalk programs still run in the British Airways Flight Operations system (FICO) under ALCS, using a commercially available automatic converter to translate SabreTalk programs to C programs.  Both the Reservations and Operations Support System (OSS) of Delta Air Lines were developed using both SabreTalk and IBM 360 Assembler.  Although development is currently restricted to C++, the majority of Delta's programming platform remained in Sabretalk until recently in the 2010s. </p><p>Because of the translator\nfrom SabreTalk to C and because it is no longer supported by the original developers, several companies are beginning the move away from SabreTalk to purely C-based programs.\n</p><p>Code Sample:\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 566,
        "name": "Sather",
        "url": "https://en.wikipedia.org/wiki/Sather",
        "summary": "<p><i>For people with the surname, see Sather (surname).</i> </p>\n<p><b>Sather</b> is an object-oriented programming language. It originated circa 1990 at the International Computer Science Institute (ICSI) at the University of California, Berkeley, developed by an international team led by Steve Omohundro. It supports garbage collection and generics by subtypes.\n</p><p>Originally, it was based on Eiffel, but it has diverged, and now includes several functional programming features.\n</p><p>The name is inspired by Eiffel; the Sather Tower is a recognizable landmark at Berkeley, named after Jane Krom Sather, the widow of Peder Sather, who donated large sums to the foundation of the university.\n</p><p>Sather also takes inspiration from other programming languages and paradigms: iterators, design by contract, abstract classes, multiple inheritance, anonymous functions, operator overloading, contravariant type system.\n</p><p>The original Berkeley implementation (last stable version 1.1 was released in 1995, no longer maintained) has been adopted by the Free Software Foundation therefore becoming GNU Sather. Last stable GNU version (1.2.3) was released in July 2007 and the software is currently not maintained. There were several other variants: Sather-K from the University of Karlsruhe; Sather-W from the University of Waikato (implementation of Sather version 1.3); Peter Naulls' port of ICSI Sather 1.1 to RISC OS; and pSather, a parallel version of ICSI Sather addressing non-uniform memory access multiprocessor architectures but presenting a shared memory model to the programmer.\n</p><p>The former ICSI Sather compiler (now GNU Sather) is implemented as a compiler to C, i.e., the compiler does not output object or machine code, but takes Sather source code and generates C source code as an intermediate language. Optimizing is left to the C compiler.\n</p><p>The GNU Sather compiler, written in Sather itself, is dual licensed under the GNU GPL &amp; LGPL.\n</p>",
        "infobox": {
            "name": "Sather",
            "paradigm": [
                "object-oriented programming|object-oriented",
                "functional programming|functional"
            ],
            "year": "1990",
            "designer": "Steve Omohundro",
            "developer": [
                "University of California",
                "Berkeley",
                "University of Waikato",
                "GNU project"
            ],
            "typing": [
                "static typing|static",
                "strong typing|strong"
            ],
            "implementations": [
                "ICSI Sather",
                "GNU Sather"
            ],
            "influenced_by": [
                "Eiffel (programming language)|Eiffel",
                "CLU (programming language)|CLU",
                "Common Lisp",
                "Scheme (programming language)|Scheme"
            ],
            "influenced": "Cool (programming language)|Cool"
        }
    },
    {
        "id": 567,
        "name": "Sawzall (programming language)",
        "url": "https://en.wikipedia.org/wiki/Sawzall_(programming_language)",
        "summary": "<p><b>Sawzall</b> is a procedural domain-specific programming language, used by Google to process large numbers of individual log records. Sawzall was first described in 2003, and the szl runtime was open-sourced in August 2010. However, since the MapReduce table aggregators have not been released, the open-sourced runtime is not useful for large-scale data analysis of multiple log files off the shelf. Sawzall has been replaced by Lingo (logs in Go) for most purposes within Google.</p>",
        "infobox": "N/A"
    },
    {
        "id": 568,
        "name": "Scala (programming language)",
        "url": "https://en.wikipedia.org/wiki/Scala_(programming_language)",
        "summary": "<p><b>Scala</b> (<span></span> <i title=\"English pronunciation respelling\"><span>SKAH</span>-lah</i>) is a general-purpose programming language providing support for both object-oriented programming and functional programming. The language has a strong static type system. Designed to be concise, many of Scala's design decisions are aimed to address criticisms of Java.</p><p>Scala source code is intended to be compiled to Java bytecode, so that the resulting executable code runs on a Java virtual machine. Scala provides language interoperability with Java, so that libraries written in either language may be referenced directly in Scala or Java code. Like Java, Scala is object-oriented, and uses a curly-brace syntax reminiscent of the C programming language. Unlike Java, Scala has many features of functional programming languages like Scheme, Standard ML and Haskell, including currying, immutability, lazy evaluation, and pattern matching. It also has an advanced type system supporting algebraic data types, covariance and contravariance, higher-order types (but not higher-rank types), and anonymous types. Other features of Scala not present in Java include operator overloading, optional parameters, named parameters, and raw strings. Conversely, a feature of Java not in Scala is checked exceptions, which has proved controversial.</p><p>The name Scala is a portmanteau of <i>scalable</i> and <i>language</i>, signifying that it is designed to grow with the demands of its users.</p>",
        "infobox": {
            "name": "Scala",
            "logo": "File:Scala logo.png|200px",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: Concurrent programming|concurrent",
                "Functional programming|functional",
                "Imperative programming|imperative",
                "Object-oriented programming|object-oriented"
            ],
            "designer": "Martin Odersky",
            "developer": "Programming Methods Laboratory of École polytechnique fédérale de Lausanne",
            "typing": [
                "Type inference|Inferred",
                "Static typing|static",
                "Strong and weak typing|strong",
                "Structural type system|structural"
            ],
            "influenced": [
                "Ceylon (programming language)|Ceylon",
                "Fantom (programming language)|Fantom",
                "F Sharp (programming language)|F#",
                "Kotlin (programming language)|Kotlin",
                "Lasso (programming language)|Lasso",
                "Red (programming language)|Red"
            ],
            "platform": "* Java virtual machine|JVM\n* JavaScript ([https://scala-js.org Scala.js])\n* LLVM ([http://scala-native.org Scala Native]) (experimental)",
            "license": "Apache License 2.0",
            "website": "https://www.scala-lang.org",
            "wikibooks": "Scala",
            "year": "2004|01|20",
            "programming_language": "Scala",
            "latest_release_version": "2.13.3",
            "latest_release_date": "2020|06|25",
            "influenced_by": [
                "Common Lisp",
                "Eiffel (programming language)|Eiffel",
                "Erlang (programming language)|Erlang",
                "Haskell (programming language)|Haskell",
                "Java (programming language)|Java",
                "OCaml",
                "Oz (programming language)|Oz",
                "Pizza (programming language)|Pizza",
                "Scheme (programming language)|Scheme",
                "Smalltalk",
                "Standard ML"
            ],
            "file_ext": [
                ".scala",
                ".sc"
            ]
        }
    },
    {
        "id": 569,
        "name": "Scheme (programming language)",
        "url": "https://en.wikipedia.org/wiki/Scheme_(programming_language)",
        "summary": "<p><b>Scheme</b> is a minimalist dialect of the Lisp family of programming languages. Scheme consists of a small standard core with powerful tools for language extension.</p><p>Scheme was created during the 1970s at the MIT AI Lab and released by its developers, Guy L. Steele and Gerald Jay Sussman, via a series of memos now known as the Lambda Papers. It was the first dialect of Lisp to choose lexical scope and the first to require implementations to perform tail-call optimization, giving stronger support for functional programming and associated techniques such as recursive algorithms. It was also one of the first programming languages to support first-class continuations.  It had a significant influence on the effort that led to the development of Common Lisp.</p><p>The Scheme language is standardized in the official IEEE standard and a <i>de facto</i> standard called the <i>Revised<span><sup>n</sup></span> Report on the Algorithmic Language Scheme</i> (R<i>n</i>RS). The most widely implemented standard is R5RS (1998); a new standard, R6RS, was ratified in 2007. Scheme has a diverse user base due to its compactness and elegance, but its minimalist philosophy has also caused wide divergence between practical implementations, so much that the Scheme Steering Committee calls it \"the world's most unportable programming language\" and \"a <i>family</i> of dialects\" rather than a single language.</p>",
        "infobox": {
            "name": "Scheme",
            "logo": "File:Lambda lc.svg|100px",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: functional programming|functional",
                "imperative programming|imperative",
                "metaprogramming|meta"
            ],
            "family": "Lisp (programming language)|Lisp",
            "year": "1975",
            "designers": "Guy L. Steele and Gerald Jay Sussman",
            "latest release version": "R7RS",
            "latest release date": "2013",
            "typing": [
                "Dynamic typing|Dynamic",
                "latent typing|latent",
                "strong typing|strong"
            ],
            "scope": "Scope (computer science)#Lexical scoping and dynamic scoping|Lexical",
            "file_ext": [
                ".scm",
                ".ss"
            ],
            "implementations": "Many<br/>(see :Category:Scheme (programming language) implementations|Scheme implementations)",
            "influenced by": [
                "ALGOL",
                "Lisp (programming language)|Lisp",
                "MDL (programming language)|MDL"
            ],
            "influenced": [
                "Clojure",
                "Common Lisp",
                "Dylan (programming language)|Dylan",
                "EuLisp",
                "Haskell (programming language)|Haskell",
                "Hop (software)|Hop",
                "JavaScript",
                "Julia (programming language)|Julia",
                "Lua (programming language)|Lua",
                "MultiLisp",
                "R (programming language)|R",
                "Racket (programming language)|Racket",
                "Ruby (programming language)|Ruby",
                "Rust (programming language)|Rust",
                "S (programming language)|S",
                "Scala (programming language)|Scala",
                "T (programming language)|T"
            ],
            "wikibooks": "Scheme"
        }
    },
    {
        "id": 570,
        "name": "Scilab",
        "url": "https://en.wikipedia.org/wiki/Scilab",
        "summary": "<p><b>Scilab</b> is a free and open-source, cross-platform numerical computational package and a high-level, numerically oriented programming language.  It can be used for signal processing, statistical analysis, image enhancement, fluid dynamics simulations, numerical optimization, and modeling, simulation of explicit and implicit dynamical systems and (if the corresponding toolbox is installed) symbolic manipulations.\n</p><p>Scilab is one of the two major open-source alternatives to MATLAB, the other one being GNU Octave. Scilab puts less emphasis on syntactic compatibility with MATLAB than Octave does, but it is similar enough that some authors suggest that it is easy to transfer skills between the two systems.</p>",
        "infobox": {
            "name": "Scilab",
            "screenshot": "Image:Screenshot scilab 3.png|300px|A screenshot of Scilab running",
            "caption": "A screenshot of Scilab running",
            "developer": "ESI Group",
            "latest release version": "6.1.0",
            "latest release date": "release date and age|2020|02|25",
            "programming language": [
                "Scilab",
                "C (programming language)|C",
                "C++",
                "Java (programming language)|Java",
                "Fortran"
            ],
            "operating system": [
                "BSDs (e.g.",
                "FreeBSD)",
                "Linux",
                "macOS",
                "Microsoft Windows|Windows"
            ],
            "language": [
                "English language|English",
                "German language|German",
                "Spanish language|Spanish",
                "French language|French",
                "Italian language|Italian",
                "Japanese language|Japanese",
                "Portuguese language|Portuguese&nbsp;(Brazil)",
                "Russian language|Russian",
                "Ukrainian language|Ukrainian",
                "Chinese language|Chinese",
                "Czech language|Czech",
                "Polish language|Polish"
            ],
            "genre": "List of numerical analysis software|Technical computing",
            "license": [
                "GPLv2",
                "previously CeCILL"
            ],
            "website": "http://www.scilab.org"
        }
    },
    {
        "id": 571,
        "name": "Scratch (programming language)",
        "url": "https://en.wikipedia.org/wiki/Scratch_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Scratch</b> is a block-based visual programming language and website targeted primarily at children. Users of the site can create online projects using a block-like interface. The service is developed by the MIT Media Lab, has been translated into 70+ languages, and is used in most parts of the world. Scratch is taught and used in after-school centers, schools, and colleges, as well as other public knowledge institutions. As of April 2020, community statistics on the language's official website show more than 52 million projects shared by over 54 million users, and almost 55 million monthly website visits.</p><p>Scratch takes its name from a technique used by disk jockeys called \"scratching\", where vinyl records are clipped together and manipulated on a turntable to produce different sound effects and music. Like scratching, the website lets users mix together different media (including graphics, sound, and other programs) in creative ways by creating and remixing projects, like video games and animations.</p>",
        "infobox": {
            "logo": "Scratchlogo.svg",
            "logo_alt": "Scratch logo",
            "paradigm": [
                "Event-driven programming|Event-driven",
                "Visual programming language|visual",
                "Block-based programming language|block-based programming language"
            ],
            "year": "2002 (first prototype)<br/> 2005 (second prototype)<br /> 2007|5|15 (public launch) <br/> 2013|5|9 (Scratch 2.0)<br> 2019|1|2 (Scratch 3.0)",
            "influenced by": [
                "Logo (programming language)|Logo",
                "Smalltalk",
                "HyperCard",
                "StarLogo",
                "AgentSheets",
                "AgentCubes",
                "Etoys (programming language)|Etoys"
            ],
            "influenced": [
                "ScratchJr ",
                "Snap! (programming language)|Snap! ",
                "mBlock"
            ],
            "programming language": [
                "Squeak (programming language)|Squeak (Scratch 0.x",
                "1.x)<br />ActionScript (Scratch 2.0)<br />JavaScript (Scratch 3.0)"
            ],
            "operating system": [
                "Microsoft Windows|Windows",
                "macOS",
                "Linux (runs on most browsers)"
            ],
            "license": "GNU General Public License|GPLv2 and Scratch Source Code License",
            "file_ext": [
                ".scratch (Scratch 0.x)<br />.sb",
                ".sprite (Scratch 1.x)<br />.sb2",
                ".sprite2 (Scratch 2.0)<br />.sb3",
                ".sprite3 (Scratch 3.0)<br />"
            ],
            "website": "https://scratch.mit.edu/",
            "latest version": "Scratch 3.3.5.4 alpha (on Lego)<br /> Scratch 3.0 (online)<br /> Scratch 3.6.0 (offline)",
            "repository": "https://github.com/LLK/scratch-gui/"
        }
    },
    {
        "id": 572,
        "name": "Script.NET",
        "url": "https://en.wikipedia.org/wiki/Script.NET",
        "summary": "<p><b>Script.NET</b> or <b>S#</b> is a metaprogramming language that provides scripting functionality in Microsoft .NET applications, allowing runtime execution of custom functionality, similar to VBA in Microsoft Office applications. The syntax of Script.NET is similar to JavaScript. It is designed to be simple and efficient scripting language allowing to customize .NET applications. The language has a true runtime interpreter, and it is executed without generating additional in-memory assemblies. </p><p>Script.NET is an open-source project.\n</p>",
        "infobox": {
            "name": "Script.NET",
            "paradigm": [
                "imperative programming|imperative",
                "metaprogramming|meta",
                "scripting language|scripting"
            ],
            "developer": "Microsoft",
            "latest_release_date": "2007-10-02",
            "typing": "dynamic typing|dynamic",
            "influenced_by": "JavaScript",
            "platform": ".NET Framework",
            "license": "Free"
        }
    },
    {
        "id": 573,
        "name": "Scripting language",
        "url": "https://en.wikipedia.org/wiki/Scripting_language",
        "summary": "<p>A <b>scripting</b> or <b>script language</b> is a programming language for a special run-time environment that automates the execution of tasks; the tasks could alternatively be executed one-by-one by a human operator. Scripting languages are often interpreted, rather than compiled. </p><p>Primitives are usually the elementary tasks or API calls, and the language allows them to be combined into more programs. Environments that can be automated through scripting include software <b>applications</b>, web pages within a web browser, usage of the shells of operating systems (OS), embedded systems, as well as numerous games. A scripting language can be viewed as a domain-specific language for a particular environment; in the case of scripting an application, it is also known as an <b>extension language</b>. Scripting languages are also sometimes referred to as very high-level programming languages, as they operate at a high level of abstraction, or as <b>control languages</b>, particularly for job control languages on mainframes.\n</p><p>The term \"scripting language\" is also used loosely to refer to dynamic high-level general-purpose languages, such as Perl, PowerShell, Python, and Tcl with the term \"script\" often used for small programs (up to a few thousand lines of code) in such languages, or in domain-specific languages such as the text-processing languages sed and AWK. Some of these languages were originally developed for use within a particular environment, and later developed into portable domain-specific or general-purpose languages.\nConversely, many general-purpose languages have dialects that are used as scripting languages. This article discusses scripting languages in the narrow sense of languages for a specific environment.\n</p><p>The spectrum of scripting languages ranges from very small and highly domain-specific languages to general-purpose programming languages used for scripting. Standard examples of scripting languages for specific environments include: Bash, for the Unix or Unix-like operating systems; ECMAScript (JavaScript), for web browsers; and Visual Basic for Applications, for Microsoft Office applications. Lua is a language designed and widely used as an extension language. Python is a general-purpose language that is also commonly used as an extension language, while ECMAScript is still primarily a scripting language for web browsers, but is also used as a general-purpose language. The Emacs Lisp dialect of Lisp (for the Emacs editor) and the Visual Basic for Applications dialect of Visual Basic are examples of scripting language dialects of general-purpose languages. Some game systems, notably the Second Life virtual world and the Trainz franchise of Railroad simulators have been extensively extended in functionality by scripting extensions (Linden Scripting Language and TrainzScript). In other games like Wesnoth, the variety of actual games played by players are scripts written by other users.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 574,
        "name": "Secure Operations Language",
        "url": "https://en.wikipedia.org/wiki/Secure_Operations_Language",
        "summary": "<p>The <b>Secure Operations Language</b> (<b>SOL</b>) was developed jointly by the United States Naval Research Laboratory and Utah State University in the United States. SOL is a  domain-specific synchronous programming language for developing distributed applications and is based on software engineering principles developed in the Software Cost Reduction project at the Naval Research Laboratory in the late 1970s and early 1980s. SOL is intended to be a domain-specific language for developing service-based systems. Concurrently, a domain-specific extension of Java (SOLj) is being developed (FTDCS 2007) Application domains include sensor networks, defense and space systems, healthcare delivery, power control, etc.\n</p><p>The investigators of the project are Dr. Ramesh Bharadwaj from the Naval Research Laboratory and Dr. Supratik Mukhopadhyay from Utah State University.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 575,
        "name": "Sed",
        "url": "https://en.wikipedia.org/wiki/Sed",
        "summary": "<p><span></span> </p><p><b>sed</b> (\"stream editor\") is a Unix utility that parses and transforms text, using a simple, compact programming language. sed was developed from 1973 to 1974 by Lee E. McMahon of Bell Labs,\nand is available today for most operating systems. sed was based on the scripting features of the interactive editor ed (\"editor\", 1971) and the earlier qed (\"quick editor\", 1965–66). sed was one of the earliest tools to support regular expressions, and remains in use for text processing, most notably with the substitution command. Popular alternative tools for plaintext string manipulation and \"stream editing\" include AWK and Perl.\n</p>",
        "infobox": {
            "name": "sed",
            "paradigm": "scripting language|scripting",
            "released": "start date and age|1974",
            "designer": "Lee E. McMahon",
            "programming_language": "C (programming language)|C",
            "influenced by": "ed (text editor)|ed",
            "influenced": [
                "Chomski",
                "Perl",
                "AWK"
            ]
        }
    },
    {
        "id": 576,
        "name": "Seed7",
        "url": "https://en.wikipedia.org/wiki/Seed7",
        "summary": "<p><b>Seed7</b> is an extensible general-purpose programming language designed by Thomas Mertes. It is syntactically similar to Pascal and Ada. Along with many other features, it provides an extension mechanism. Seed7 supports introducing new syntax elements and their semantics into the language, and allows new language constructs to be defined and written in Seed7. For example, programmers can introduce syntax and semantics of new statements and user defined operator symbols. The implementation of Seed7 differs significantly from that of languages with hard-coded syntax and semantics. </p>",
        "infobox": {
            "name": "Seed7",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: extensible programming|extensible",
                "object-oriented programming|object-oriented",
                "imperative programming|imperative",
                "structured programming|structured",
                "generic programming|generic",
                "reflective programming|reflective"
            ],
            "typing": [
                "static typing|static",
                "type system#Strong and weak typing|strong",
                "type system#Safely and unsafely typed systems|safe",
                "nominative type system|nominative",
                "manifest typing|manifest"
            ],
            "implementations": "open source reference implementation",
            "year": "2005",
            "designer": "Thomas Mertes",
            "latest release version": "2020-06-28",
            "latest release date": "age in days|2020|06|28|show unit|=|full ago",
            "influenced by": [
                "Pascal (programming language)|Pascal",
                "Modula-2",
                "Ada (programming language)|Ada",
                "ALGOL 68",
                "C (programming language)|C",
                "C++",
                "Java (programming language)|Java"
            ],
            "operating system": [
                "Cross-platform: BSD",
                "Linux",
                "OS X",
                "Unix",
                "Microsoft Windows|Windows"
            ],
            "license": [
                "GNU General Public License|GPL",
                "GNU Lesser General Public License|LGPL (for the runtime library)"
            ],
            "file ext": [
                ".sd7",
                ".s7i"
            ]
        }
    },
    {
        "id": 577,
        "name": "Self (programming language)",
        "url": "https://en.wikipedia.org/wiki/Self_(programming_language)",
        "summary": "<p><b>Self</b> is an object-oriented programming language based on the concept of <i>prototypes</i>. Self began as a dialect of Smalltalk, being dynamically typed and using just-in-time compilation (JIT) as well as the prototype-based approach to objects: it was first used as an experimental test system for language design in the 1980s and 1990s. In 2006, Self was still being developed as part of the Klein project, which was a Self virtual machine written fully in Self. The latest version is 2017.1 released in May 2017.</p><p>Several just-in-time compilation techniques were pioneered and improved in Self research as they were required to allow a very high level object oriented language to perform at up to half the speed of optimized C. Much of the development of Self took place at Sun Microsystems, and the techniques they developed were later deployed for Java's HotSpot virtual machine. </p><p>At one point a version of Smalltalk was implemented in Self. Because it was able to use the JIT, this also gave extremely good performance.</p>",
        "infobox": {
            "name": "Self",
            "logo": "File:Self-logo.svg|200px|Logo",
            "paradigm": "Object-oriented programming|object-oriented (prototype-based programming|prototype-based)",
            "year": "1987",
            "designer": [
                "David Ungar",
                "Randall Smith"
            ],
            "developer": [
                "David Ungar",
                "Randall Smith",
                "Stanford University",
                "Sun Microsystems"
            ],
            "latest release version": "2017.1",
            "latest release date": "2017|05|24",
            "typing": [
                "Type system|dynamic",
                "Strongly-typed programming language|strong"
            ],
            "implementations": "Self",
            "influenced_by": "Smalltalk",
            "influenced": [
                "NewtonScript",
                "JavaScript",
                "Io (programming language)|Io",
                "Agora (programming language)|Agora",
                "Squeak",
                "Lua (programming language)|Lua",
                "Factor (programming language)|Factor",
                "REBOL"
            ],
            "license": "BSD-like license",
            "website": "www.selflanguage.org"
        }
    },
    {
        "id": 578,
        "name": "SenseTalk",
        "url": "https://en.wikipedia.org/wiki/SenseTalk",
        "summary": "<p><b>SenseTalk</b> is an intuitive, People Oriented Programming language designed to be both readable and expressive. Being readable makes it easier for a person unfamiliar with a particular script (or even with programming in general) to understand what the script does. Being expressive allows people to describe actions to be taken using high-level human-task-oriented terms rather than in terms of the low-level operations the computer must perform to carry out those tasks.  </p>",
        "infobox": {
            "name": "SenseTalk",
            "screenshot": "Image:ST-HelloWorld2.png|250px",
            "caption": "SenseTalk in the OS X Terminal/CLI & Eggplant Dev Environment",
            "paradigm": [
                "People Oriented Programming",
                " Multi-paradigm programming language|Multi-paradigm",
                "Object-oriented programming|Object-oriented"
            ],
            "family": "Scripting language",
            "typing": "duck typing|Duck",
            "designer": "Douglas Simons",
            "influenced_by": [
                "xTalk",
                "HyperTalk"
            ],
            "released": "1992",
            "developer": "Eggplant (software)",
            "latest_release_version": "2.00",
            "latest_release_date": "2020|04|01",
            "File extensions": "flatlist|\n* <code>.script</code>\n* <code>.st</code>",
            "license": "Proprietary software|Proprietary",
            "website": "url|http://www.sensetalk.com/"
        }
    },
    {
        "id": 579,
        "name": "SequenceL",
        "url": "https://en.wikipedia.org/wiki/SequenceL",
        "summary": "<p><b>SequenceL</b> is a general purpose functional programming language and auto-parallelizing (Parallel computing) compiler and tool set, whose primary design objectives are performance on multi-core processor hardware, ease of programming, platform portability/optimization, and code clarity and readability.  Its main advantage is that it can be used to write straightforward code that automatically takes full advantage of all the processing power available, without programmers needing to be concerned with identifying parallelisms, specifying vectorization, avoiding race conditions, and other challenges of manual directive-based programming approaches such as OpenMP. </p><p>Programs written in SequenceL can be compiled to multithreaded code that runs in parallel, with no explicit indications from a programmer of how or what to parallelize. As of 2015, versions of the SequenceL compiler generate parallel code in C++ and OpenCL, which allows it to work with most popular programming languages, including C, C++, C#, Fortran, Java, and Python.  A platform-specific runtime manages the threads safely, automatically providing parallel performance according to the number of cores available, currently supporting x86, POWER8, and ARM platforms.\n</p>",
        "infobox": {
            "name": "SequenceL",
            "paradigms": [
                "Parallel computing",
                "Functional programming|Functional",
                "Purely functional programming|Purely functional",
                "Declarative programming"
            ],
            "designers": "Dr. Daniel Cooke,<br/>Dr. Nelson Rushton,<br/>Dr. Brad Nemanich",
            "developers": "Texas Tech University,<br/>Texas Multicore Technologies",
            "released": "1989",
            "typing": [
                "Type system#Static type checking|Static",
                "type inference"
            ],
            "platform": [
                "x86",
                "IBM POWER microprocessors|POWER",
                "ARM architecture|ARM"
            ],
            "operating system": [
                "Microsoft Windows|Windows",
                "macOS",
                "Linux"
            ],
            "website": "texasmulticore.com Dead link|date|=|May 2018",
            "license": "Proprietary software|Proprietary"
        }
    },
    {
        "id": 580,
        "name": "Shell script",
        "url": "https://en.wikipedia.org/wiki/Shell_script",
        "summary": "<p>A <b>shell script</b> is a computer program designed to be run by the Unix shell, a command-line interpreter. The various dialects of shell scripts are considered to be scripting languages. Typical operations performed by shell scripts include file manipulation, program execution, and printing text. A script which sets up the environment, runs the program, and does any necessary cleanup, logging, etc. is called a <b>wrapper</b>. </p><p>The term is also used more generally to mean the automated mode of running an operating system shell; in specific operating systems they are called other things such as batch files (MSDos-Win95 stream, OS/2), command procedures (VMS), and shell scripts (Windows NT stream and third-party derivatives like 4NT—article is at cmd.exe), and mainframe operating systems are associated with a number of terms.\n</p><p>The typical Unix/Linux/POSIX-compliant installation includes the KornShell (<code>ksh</code>) in several possible versions such as ksh88, Korn Shell '93 and others. The oldest shell still in common use is the Bourne shell (<code>sh</code>); Unix systems invariably also include the C shell (<code>csh</code>), Bash (<code>bash</code>), a Remote Shell (<code>rsh</code>), a Secure Shell (<code>ssh</code>) for SSL telnet connections, and a shell which is a main component of the Tcl/Tk installation usually called <code>tclsh</code>; wish is a GUI-based Tcl/Tk shell. The C and Tcl shells have syntax quite similar to that of said programming languages, and the Korn shells and Bash are developments of the Bourne shell, which is based on the ALGOL language with elements of a number of others added as well. On the other hand, the various shells plus tools like awk, sed, grep, and BASIC, Lisp, C and so forth contributed to the Perl programming language.</p><p>Other shells available on a machine or available for download and/or purchase include Almquist shell (<code>ash</code>), PowerShell (<code>msh</code>), Z shell (<code>zsh</code>, a particularly common enhanced KornShell), the Tenex C Shell (<code>tcsh</code>), a Perl-like shell (<code>psh</code>). Related programs such as shells based on Python, Ruby, C, Java, Perl, Pascal, Rexx &amp;c in various forms are also widely available. Another somewhat common shell is osh, whose manual page states it \"is an enhanced, backward-compatible port of the standard command interpreter from Sixth Edition UNIX.\"</p><p>Windows-Unix interoperability software such as the MKS Toolkit, Cygwin, UWIN, Interix and others make the above shells and Unix programming available on Windows systems, providing functionality all the way down to signals and other inter-process communication, system calls and APIs. The Hamilton C shell is a Windows shell that is very similar to the Unix C Shell. Microsoft distributed Windows Services for UNIX for use with its NT-based operating systems in particular, which have a POSIX environmental subsystem.\n</p>\n\n\n",
        "infobox": "N/A"
    },
    {
        "id": 581,
        "name": "SiMPLE",
        "url": "https://en.wikipedia.org/wiki/SiMPLE",
        "summary": "<p><b>SiMPLE</b> (a recursive acronym for SiMPLE Modular Programming Language &amp; Environment) is a programming development system that was created to provide easy programming capabilities for everybody, especially non-professionals. </p><p>Following the death of SiMPLE creator Bob Bishop, the SiMPLE Codeworks website and forums are now offline, however they can be accessed via the internet archive archive.org. \n</p>",
        "infobox": "N/A"
    },
    {
        "id": 582,
        "name": "Simula",
        "url": "https://en.wikipedia.org/wiki/Simula",
        "summary": "<p><b>Simula</b> is the name of two simulation programming languages, Simula I and Simula 67, developed in the 1960s at the Norwegian Computing Center in Oslo, by Ole-Johan Dahl and Kristen Nygaard. Syntactically, it is a fairly faithful superset of ALGOL 60, also influenced by the design of Simscript.</p><p>Simula 67 introduced objects, classes, inheritance and subclasses, virtual procedures, coroutines, and discrete event simulation, and features garbage collection. Also other forms of subtyping (besides inheriting subclasses) were introduced in Simula derivatives.</p><p>Simula is considered the first object-oriented programming language. As its name suggests, the first Simula version by 1962 was designed for doing simulations; Simula 67 though was designed to be a general-purpose programming language and provided the framework for many of the features of object-oriented languages today. </p><p>Simula has been used in a wide range of applications such as simulating very-large-scale integration (VLSI) designs, process modeling, communication protocols, algorithms, and other applications such as typesetting, computer graphics, and education. The influence of Simula is often understated, and Simula-type objects are reimplemented in C++, Object Pascal, Java, C#, and many other languages. Computer scientists such as Bjarne Stroustrup, creator of C++, and James Gosling, creator of Java, have acknowledged Simula as a major influence.</p>",
        "infobox": {
            "name": "Simula",
            "logo": "Simula - logo.svg",
            "paradigms": [
                "Multi-paradigm programming language|Multi-paradigm: Procedural programming|procedural",
                "Imperative programming|imperative",
                "Structured programming|structured",
                "Object-oriented programming|object-oriented"
            ],
            "family": "ALGOL",
            "designer": "Ole-Johan Dahl",
            "developer": "Kristen Nygaard",
            "released": "1962",
            "latest release version": [
                "Simula 67",
                "Simula I"
            ],
            "typing": [
                "Static type|Static",
                "Nominal type system|nominative"
            ],
            "scope": "Scope (computer science)|Lexical",
            "programming language": "ALGOL 60 (primarily; some components Simscript)",
            "influenced_by": [
                "ALGOL 60",
                "Simscript"
            ],
            "influenced": "List of object-oriented programming languages|Object-oriented programming languages",
            "operating system": [
                "Unix-like",
                "Windows",
                "z/OS",
                "TOPS-10",
                "MVS"
            ],
            "website": "www.simula67.info"
        }
    },
    {
        "id": 583,
        "name": "Simulink",
        "url": "https://en.wikipedia.org/wiki/Simulink",
        "summary": "<p><b>Simulink</b> is a MATLAB-based graphical programming environment for modeling, simulating and analyzing multidomain dynamical systems. Its primary interface is a graphical block diagramming tool and a customizable set of block libraries. It offers tight integration with the rest of the MATLAB environment and can either drive MATLAB or be scripted from it. Simulink is widely used in automatic control and digital signal processing for multidomain simulation and model-based design.</p> \n\n",
        "infobox": {
            "name": "Simulink",
            "logo": "Simulink Logo (non-wordmark).png",
            "logo size": "100px",
            "screenshot": "Image:Simulink model of a wind turbine.tif|300px|Simulink model of a wind turbine",
            "caption": "Simulink model of a wind turbine",
            "developer": "MathWorks",
            "latest release version": "9.3 (part of R2019a)",
            "latest release date": "2019|03|20",
            "operating system": [
                "Linux",
                "macOS",
                "Microsoft Windows"
            ],
            "license": "Proprietary software|Proprietary",
            "website": "https://www.mathworks.com/products/simulink.html|mathworks.com"
        }
    },
    {
        "id": 584,
        "name": "Singularity (operating system)",
        "url": "https://en.wikipedia.org/wiki/Singularity_(operating_system)",
        "summary": "<p><b>Singularity</b> is an experimental operating system (OS) which was built by Microsoft Research between 2003 and 2010.  It was designed as a high dependability OS in which the kernel, device drivers, and application software were all written in managed code. Internal security uses type safety instead of hardware memory protection. </p>",
        "infobox": {
            "name": "Singularity Project",
            "screenshot": "Singularity v1.png",
            "caption": "Singularity after boot-up",
            "developer": "Microsoft Corporation",
            "source model": "Source-available software|Source-available (through Shared Source Initiative)",
            "kernel type": "Microkernel Language-based system|language-based",
            "supported platforms": "x86",
            "ui": "Command-line interface",
            "family": "Language-based systems",
            "released": "2007",
            "discontinued": "Yes",
            "latest release version": "2.0",
            "latest release date": "2008|11|14",
            "programmed in": [
                "Assembly language",
                "C (programming language)|C",
                "C++",
                "C Sharp (programming language)|C#",
                "Sing Sharp|Sing#"
            ],
            "language": "English",
            "working state": "Discontinued",
            "license": "Microsoft Research License",
            "website": "research.microsoft.com/en-us/projects/singularity"
        }
    },
    {
        "id": 585,
        "name": "Smalltalk",
        "url": "https://en.wikipedia.org/wiki/Smalltalk",
        "summary": "<p><b>Smalltalk</b> is an object-oriented, dynamically typed reflective programming language. Smalltalk was created as the language underpinning the \"new world\" of computing exemplified by \"human–computer symbiosis\". It was designed and created in part for educational use, specifically for constructionist learning, at the Learning Research Group (LRG)  of  Xerox PARC by Alan Kay, Dan Ingalls, Adele Goldberg, Ted Kaehler, Diana Merry, Scott Wallace, and others during the 1970s. </p><p>The language was first generally released as Smalltalk-80. Smalltalk-like languages are in active development and have gathered loyal communities of users around them. ANSI Smalltalk was ratified in 1998 and represents the standard version of Smalltalk.</p><p>Smalltalk took second place for \"most loved programming language\" in the Stack Overflow Developer Survey in 2017, but it was not among the 26 most loved programming languages of the 2018 survey.</p>",
        "infobox": {
            "name": "Smalltalk",
            "logo": "Smalltalk80book.jpg",
            "caption": [
                "''Smalltalk-80: The Language and its Implementation''",
                "a.k.a. the \"Blue book\"",
                "an original book on the language"
            ],
            "paradigm": "Object-oriented programming|Object-oriented",
            "year": "1972 (development began in 1969)",
            "designer": [
                "Alan Kay",
                "Dan Ingalls",
                "Adele Goldberg (computer scientist)|Adele Goldberg"
            ],
            "developer": [
                "Alan Kay",
                "Dan Ingalls",
                "Adele Goldberg",
                "Ted Kaehler",
                "Diana Merry",
                "Scott Wallace",
                "L. Peter Deutsch|Peter Deutsch and PARC (company)|Xerox PARC"
            ],
            "latest release version": "Smalltalk-80 version 2",
            "latest release date": "1980",
            "typing": [
                "strong typing|Strong",
                "dynamic typing|dynamic"
            ],
            "implementations": [
                "Amber Smalltalk|Amber",
                "Dolphin Smalltalk",
                "Gemstone (database)|GemStone/S",
                "GNU Smalltalk",
                "Pharo",
                "Smalltalk/X",
                "Squeak",
                "IBM VisualAge|VA Smalltalk",
                "VisualWorks"
            ],
            "influenced by": [
                "Lisp (programming language)|Lisp",
                "Simula",
                "Euler (programming language)|Euler",
                "IMP (programming language)|IMP",
                "Planner (programming language)|Planner",
                "Logo (programming language)|Logo",
                "Sketchpad",
                "ARPAnet",
                "Burroughs B5000"
            ],
            "influenced": [
                "AppleScript",
                "Common Lisp Object System",
                "Dart (programming language)|Dart",
                "Dylan (programming language)|Dylan",
                "Erlang (programming language)|Erlang",
                "Etoys (programming language)|Etoys",
                "Go (programming language)|Go",
                "Groovy (programming language)|Groovy",
                "Io (programming language)|Io",
                "Ioke (programming language)|Ioke",
                "Java (programming language)|Java",
                "Lasso (programming language)|Lasso",
                "Logtalk",
                "Newspeak (programming language)|Newspeak",
                "NewtonScript",
                "Object REXX",
                "Objective-C",
                "PHP 5",
                "Python (programming language)|Python",
                "Raku (programming language)|Raku",
                "Ruby (programming language)|Ruby",
                "Scala (programming language)|Scala",
                "Scratch (programming language)|Scratch",
                "Self (programming language)|Self"
            ],
            "operating system": "Cross-platform (multi-platform)",
            "wikibooks": "Smalltalk",
            "website": "hide"
        }
    },
    {
        "id": 586,
        "name": "Snap! (programming language)",
        "url": "https://en.wikipedia.org/wiki/Snap!_(programming_language)",
        "summary": "<p><b>Snap!</b> (formerly Build Your Own Blocks or BYOB) is a free, blocks-based educational graphical programming language and online community aimed at students to explore, create and re-mix interactive animations, games, stories, and more, while learning about mathematical and computational ideas. While inspired by Scratch, Snap! has many advanced features. The Snap! editor, and programs created in it, are web applications that run in the browser (like Scratch 2 and 3) without requiring installation. </p>",
        "infobox": {
            "name": "Snap! (BYOB) #tag:ref|Program versions pre-4.0|group|=|Note",
            "logo": "File:Snap!.png|180px",
            "caption": [
                "\"Alonzo\" is the mascot of Snap!",
                "named after Alonzo Church"
            ],
            "paradigm": [
                "Object-oriented programming|object-oriented",
                "educational programming language|educational",
                "Event-driven programming|event-driven"
            ],
            "year": "start date and age|2011",
            "designer": "Brian Harvey (lecturer)|Brian Harvey and [https://github.com/jmoenig/ Jens Mönig]",
            "developer": "[https://github.com/jmoenig/ Jens Mönig]",
            "latest release version": "6.0.0",
            "latest release date": "2020|7|8",
            "typing": "Type system|dynamic",
            "programming language": [
                "JavaScript (Snap!)",
                "previously Squeak (BYOB version)"
            ],
            "influenced by": [
                "Scratch (programming language)|Scratch",
                "Scheme (programming language)|Scheme",
                "Logo (programming language)|Logo",
                "Smalltalk"
            ],
            "influenced": [
                "BeetleBlocks",
                "Snapi",
                "Dragme IDE"
            ],
            "operating system": "Cross-platform",
            "license": "Affero General Public License|AGPL",
            "website": "snap.berkeley.edu",
            "file ext": ".xml (Snap''!'')"
        }
    },
    {
        "id": 587,
        "name": "Snowball programming language",
        "url": "https://en.wikipedia.org/wiki/Snowball_(programming_language)",
        "summary": "<p><b>Snowball</b> is a small string processing programming language designed for creating stemming algorithms for use in information retrieval.</p><p>The Snowball compiler translates a Snowball script (a  .sbl file) into either a thread-safe ANSI C program or a Java program. For ANSI C, each Snowball script produces a program file and corresponding header file (with  .c  and  .h  extensions). The Snowball compiler checks the consistency of its script, and this check was used to discover a typo in a seminal academic paper by Lovins which had remained undetected for 30 years.</p><p>The basic datatypes handled by Snowball are strings of characters, signed integers, and boolean truth values, or more simply strings, integers and booleans. Snowball's characters are either 8-bit wide, or 16-bit, depending on the mode of use. In particular, both ASCII and 16-bit Unicode are supported. Like the SNOBOL programming language, the flow of control in Snowball is arranged by the implicit use of signals (each statement returns a true or false value), rather than the explicit use of constructs such as if, then, and break found in C and many other programming languages.</p><p>The name Snowball was chosen as a tribute to the SNOBOL programming language, with which it shares the concept of string patterns delivering signals that are used to control the flow of the program. The creator of Snowball, Dr. Martin Porter, \"toyed with the idea of calling it 'strippergram' \", because it \"effectively provides a 'suffix STRIPPER GRAMmar' \".</p>",
        "infobox": "N/A"
    },
    {
        "id": 588,
        "name": "Solidity",
        "url": "https://en.wikipedia.org/wiki/Solidity",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Solidity</b> is an object-oriented programming language for writing smart contracts. It is used for implementing smart contracts on various blockchain platforms, most notably, Ethereum. It was developed by Christian Reitwiessner, Alex Beregszaszi, Yoichi Hirai and several former Ethereum core contributors to enable writing smart contracts on blockchain platforms such as Ethereum.</p>",
        "infobox": {
            "name": "Solidity",
            "logo": "Solidity logo.svg",
            "logo caption": "The Solidity language logo",
            "logo size": "200px",
            "influenced_by": [
                "JavaScript",
                "C++",
                "Python (programming language)|Python",
                "PowerShell"
            ],
            "website": "github.com/ethereum/solidity"
        }
    },
    {
        "id": 589,
        "name": "Source (programming language)",
        "url": "https://en.wikipedia.org/wiki/Source_(programming_language)",
        "summary": "<p><b>Source</b> is a family of sublanguages of JavaScript, developed for the textbook Structure and Interpretation of Computer Programs, JavaScript Adaptation (SICP JS). The JavaScript sublanguages Source §1, Source §2, Source §3 and Source §4 are designed to be just powerful enough to support all examples of the respective chapter of the textbook.  </p>",
        "infobox": {
            "name": "source",
            "paradigm": [
                "Multi-paradigm: scripting language|scripting",
                "imperative programming|imperative",
                "procedural programming|procedural",
                "  functional programming|functional"
            ],
            "year": "df|=|yes|2017",
            "latest_release_version": "2021 (Knight)",
            "latest_release_date": "2020|07|17",
            "typing": [
                "Dynamic typing|Dynamic",
                "Duck typing|duck"
            ],
            "implementations": [
                "Safari (web browser)|Safari (Safari's JavaScript is Tail call|properly tail recursive)",
                "[https://source-academy.github.io/sicp/ Source Academy]"
            ],
            "dialects": [
                "Source §1",
                "Source §2",
                "Source §3",
                "Source §4"
            ],
            "influenced_by": [
                "JavaScript",
                "Scheme (programming language)|Scheme"
            ],
            "operating_system": "browser-based",
            "license": "Apache License",
            "website": "https://source-academy.github.io/source/",
            "file ext": ".js"
        }
    },
    {
        "id": 590,
        "name": "Speakeasy (computational environment)",
        "url": "https://en.wikipedia.org/wiki/Speakeasy_(computational_environment)",
        "summary": "<p><b>Speakeasy</b> is a numerical computing interactive environment also featuring an interpreted programming language. It was initially developed for internal use at the Physics Division of Argonne National Laboratory by the theoretical physicist Stanley Cohen. He eventually founded Speakeasy Computing Corporation to make the program available commercially. </p><p>Speakeasy is a very long-lasting numerical package. In fact, the original version of the environment was built around a core dynamic data repository called \"Named storage\" developed in the early 1960s, while the most recent version has been released in 2006.\n</p><p>Speakeasy was aimed to make the computational work of the physicists at the Argonne National Laboratory easier. It was initially conceived to work on mainframes (the only kind of computers at that time), and was subsequently ported to new platforms (minicomputers, personal computers) as they became available. The porting of the same code on different platforms was made easier by using Mortran metalanguage macros to face systems dependencies and compilers deficiencies and differences. Speakeasy is currently available on several platforms: PCs running Windows, macOS, Linux, departmental computers and workstations running several flavors of Linux, AIX or Solaris.\n</p><p>Speakeasy was also among the first interactive numerical computing environments, having been implemented in such a way on a CDC 3600 system, and later on IBM TSO machines as one was in beta-testing at the Argonne National Laboratory at the time.\n</p><p>Almost since the beginning (as the dynamic linking functionality was made available in the operating systems) Speakeasy features the capability of expanding its operational vocabulary using separated modules, dynamically linked to the core processor as they are needed. For that reason such modules  were called \"linkules\" (LINKable-modULES). They are functions with a generalized interface, which can be written in  FORTRAN or in C.\nThe independence of each of the new modules from the others and from the main processor is of great help in improving the system, especially it was in the old days.\n</p><p>This easy way of expanding the functionalities of the main processor was often exploited by the users to develop their own specialized packages. Besides the programs, functions and subroutines the user can write in the Speakeasy's own interpreted language, linkules add functionalities carried out with the typical performances of compiled programs.\n</p><p>Among the packages developed by the users, one of the most important is \"Modeleasy\", originally developed as \"FEDeasy\" in the early 1970s at the research department of the Federal Reserve Board of Governors in Washington D.C..\nModeleasy implements special objects and functions for large econometric models estimation and simulation.\nIts evolution led eventually to its distribution as an independent product.\n</p>",
        "infobox": {
            "name": "Speakeasy",
            "logo": "Speakeasy Red Logo.png",
            "developer": "Speakeasy Computing Corporation",
            "latest_release_version": "IV Iota",
            "latest_release_date": "2006",
            "programming language": [
                "Mortran",
                "FORTRAN",
                "C (programming language)|C Citation needed|date|=|August 2013"
            ],
            "operating_system": [
                "Windows",
                "macOS",
                "RedHat Linux",
                "SUSE Linux",
                "Mandrake Linux",
                "Debian",
                "Solaris (operating system)|Solaris",
                "HP-UX"
            ],
            "genre": "List of numerical analysis software|Technical computing",
            "license": "Trialware",
            "website": "speakeasy.com"
        }
    },
    {
        "id": 591,
        "name": "Speedcoding",
        "url": "https://en.wikipedia.org/wiki/Speedcoding",
        "summary": "<p><b>Speedcoding</b> or <b>Speedcode</b> was the first high-level programming language created for an IBM computer. The language was developed by John Backus in 1953 for the IBM 701 to support computation with  floating point numbers. Here high level means symbolic and aiming for natural language expressivity as a goal as opposed to machine or hardware instruction oriented coding. </p><p>The idea arose from the difficulty of programming the IBM SSEC machine when Backus was hired to calculate astronomical positions in early 1950.\nThe speedcoding system was an interpreter and focused on ease of use at the expense of system resources. It provided pseudo-instructions for common mathematical functions: logarithms, exponentiation, and trigonometric operations. The resident software analyzed pseudo-instructions one by one and called the appropriate subroutine. Speedcoding was also the first implementation of decimal input/output operations. Although it substantially reduced the effort of writing many jobs, the running time of a program that was written with the help of Speedcoding was usually ten to twenty times that of machine code. The interpreter took 310 memory words, about 30% of the memory available on a 701.</p>",
        "infobox": {
            "name": "Speedcoding",
            "paradigm": [
                "structured programming|structured",
                "Object-oriented programming|object-oriented",
                "Generic programming|generic"
            ],
            "year": "1953",
            "designer": "John Backus",
            "developer": "John Backus and IBM",
            "typing": [
                "strongly typed programming language|strong",
                "Type system|static",
                "manifest typing|manifest"
            ],
            "influenced_by": [
                "Assembly language",
                "machine code"
            ],
            "influenced": [
                "Fortran",
                "ALGOL 58",
                "BASIC",
                "C (programming language)|C",
                "PL/I",
                "PACT I",
                "MUMPS",
                "Ratfor"
            ]
        }
    },
    {
        "id": 592,
        "name": "Squeak",
        "url": "https://en.wikipedia.org/wiki/Squeak",
        "summary": "<p>The <b>Squeak</b> programming language is a dialect of Smalltalk. It is object-oriented, class-based, and reflective. </p><p>It was derived directly from Smalltalk-80 by a group at Apple Computer that included some of the original Smalltalk-80 developers. Its development was continued by the same group at Walt Disney Imagineering, where it was intended for use in internal Disney projects. Later on the group moved on to be supported by HP labs, SAP Labs and most recently  Y Combinator.\n</p><p>Squeak is cross-platform. Programs produced on one platform run bit-identical on all other platforms, and versions are available for many platforms including the obvious Windows/macOS/linux versions. The Squeak system includes code for generating a new version of the virtual machine (VM) on which it runs. It also includes a VM simulator written in Squeak. For these reasons, it is easily ported.\n</p>",
        "infobox": {
            "name": "Squeak",
            "logo": "File:Squeak.svg|100px",
            "logo caption": "Original 1996 logo by Tim Rowledge",
            "screenshot": "File:Squeak 51 morphic interface screenshot.png|225px|Screenshot of the Squeak/Smalltalk Morphic User Interface",
            "screenshot caption": "Screenshot of the Squeak Morphic user interface.",
            "paradigm": "Object-oriented programming|object-oriented",
            "year": "1996",
            "designers": [
                "Alan Kay",
                "Dan Ingalls",
                "Adele Goldberg (computer scientist)|Adele Goldberg"
            ],
            "developers": "The Squeak Community",
            "latest release version": "5.3",
            "latest release date": "2020|03|04",
            "typing": "Type system|Dynamic",
            "implementations": [
                "Squeak",
                "Croquet Project|Croquet"
            ],
            "dialects": [
                "Pharo",
                "Croquet Project|Croquet"
            ],
            "influenced by": [
                "Smalltalk",
                "Lisp (programming language)|Lisp",
                "Logo (programming language)|Logo; Sketchpad",
                "Simula; Self (programming language)|Self"
            ],
            "influenced": [
                "Etoys (programming language)|Etoys",
                "Tweak",
                "Croquet Project|Croquet",
                "Scratch (programming language)|Scratch"
            ],
            "platform": "Cross-platform",
            "operating system": [
                "Cross-platform: Unix-like",
                "macOS",
                "iOS",
                "Microsoft Windows|Windows",
                "more"
            ],
            "license": [
                "MIT License|MIT",
                "Apache License|Apache"
            ],
            "website": "www.squeak.org"
        }
    },
    {
        "id": 593,
        "name": "Squirrel (programming language)",
        "url": "https://en.wikipedia.org/wiki/Squirrel_(programming_language)",
        "summary": "<p><b>Squirrel</b> is a high level imperative, object-oriented programming language, designed to be a lightweight scripting language that fits in the size, memory bandwidth, and real-time requirements of applications like video games and embedded systems. </p><p>MirthKit, a simple toolkit for making and distributing open source, cross-platform 2D games, uses Squirrel for its platform. It is used extensively by Code::Blocks for scripting and was also used in <i>Final Fantasy Crystal Chronicles: My Life as a King</i>. It is also used in <i>Left 4 Dead 2</i>, <i>Portal 2</i> and <i>Thimbleweed Park</i> for scripted events and in NewDark, an unofficial Thief 2: The Metal Age engine update, to facilitate additional, simplified means of scripting mission events, aside of the regular C scripting.</p>",
        "infobox": {
            "name": "Squirrel",
            "file_ext": ".nut",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: Scripting language|scripting",
                "Imperative programming|imperative",
                "Functional programming|functional",
                "Object-oriented programming|object-oriented"
            ],
            "year": "2003",
            "designer": "Alberto Demichelis",
            "latest_release_version": "3.1",
            "latest_release_date": "2016|03|27",
            "typing": "Type system#Dynamic typing|Dynamic",
            "influenced_by": [
                "C++",
                "JavaScript",
                "Lua (programming language)|Lua",
                "Python (programming language)|Python"
            ],
            "influenced": "MiniD",
            "operating_system": "Cross-platform",
            "license": "MIT license",
            "website": "http://squirrel-lang.org/"
        }
    },
    {
        "id": 594,
        "name": "Standard ML",
        "url": "https://en.wikipedia.org/wiki/Standard_ML",
        "summary": "<p><b>Standard ML</b> (<b>SML</b>) is a general-purpose, modular, functional programming language with compile-time type checking and type inference. It is popular among compiler writers and programming language researchers, as well as in the development of theorem provers. </p><p>SML is a modern dialect of ML, the programming language used in the Logic for Computable Functions (LCF) theorem-proving project. It is distinctive among widely used languages in that it has a formal specification, given as typing rules and operational semantics in <i>The Definition of Standard ML</i>.</p>",
        "infobox": {
            "name": "Standard ML",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: functional programming language|functional",
                "imperative programming|imperative",
                "modular programming|modular"
            ],
            "family": "ML (programming language)|ML",
            "year": "1983",
            "latest release version": "Standard ML '97",
            "latest release date": "1997",
            "typing": [
                "Type inference|Inferred",
                "static typing|static",
                "strong typing|strong"
            ],
            "implementations": [
                "Standard ML of New Jersey|SML/NJ",
                "MLton"
            ],
            "dialects": [
                "Alice (programming language)|Alice",
                "Concurrent ML",
                "Dependent ML"
            ],
            "influenced_by": [
                "ML programming language|ML",
                "Hope (programming language)|Hope",
                "Pascal (programming language)|Pascal"
            ],
            "influenced": [
                "Elm (programming language)|Elm",
                "F Sharp (programming language)|F#",
                "F* (programming language)|F*",
                "Haskell_(programming_language)|Haskell",
                "OCaml",
                "Python (programming language)|Python",
                "Rust (programming language)|Rust",
                "Scala (programming language)|Scala"
            ],
            "file_ext": ".sml"
        }
    },
    {
        "id": 595,
        "name": "Starlogo",
        "url": "https://en.wikipedia.org/wiki/StarLogo",
        "summary": "<p><b>StarLogo</b> is an agent-based simulation language developed by Mitchel Resnick, Eric Klopfer, and others at the Massachusetts Institute of Technology (MIT) Media Lab and Scheller Teacher Education Program in Massachusetts. It is an extension of the Logo programming language, a dialect of Lisp. Designed for education, StarLogo can be used by students to model or simulate the behavior of decentralized systems. </p><p>The first StarLogo ran on a Connection Machine 2 parallel computer. A subsequent version ran on Macintosh computers. It was later renamed MacStarLogo, and now is named MacStarLogo Classic. The current StarLogo is written in the language Java and works on most computers.\n</p><p>StarLogo is also available in a version named <i>OpenStarLogo</i>. Its source code is available online, but the license under which it is released is not an open-source license according to The Open Source Definition, because of restrictions on the commercial use of the code.\n</p>",
        "infobox": {
            "name": "StarLogo",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: Educational programming language|educational",
                "Procedural programming|procedural",
                "Agent-based model|agent-based",
                "Simulation language|simulation"
            ],
            "family": "Lisp (programming language)|Lisp",
            "designers": [
                "Mitchel Resnick",
                "Eric Klopfer",
                "Daniel Wendel"
            ],
            "developers": [
                "Massachusetts Institute of Technology|MIT: MIT Media Lab|Media Lab",
                "Scheller Teacher Education Program"
            ],
            "released": "2001",
            "latest release version": "StarLogo Nova 2.1",
            "latest release date": "2018|11|24",
            "typing": [
                "Duck typing|duck",
                "dynamic typing|dynamic",
                "strong typing|strong"
            ],
            "programming language": [
                "Java (programming language)|Java",
                "C (programming language)|C"
            ],
            "platform": "Java virtual machine",
            "operating system": [
                "Microsoft Windows|Windows",
                "macOS"
            ],
            "license": "Various",
            "website": "www.slnova.org",
            "implementations": [
                "[http://education.mit.edu/starlogo-tng/ StarLogo TNG]",
                "StarLogo",
                "MacStarLogo Classic",
                "[https://web.archive.org/web/20060831053042/http://education.mit.edu/openstarlogo/ OpenStarLogo]",
                "[http://ccl.northwestern.edu/cm/starlogoT/ starlogoT]"
            ],
            "influenced by": "Logo (programming language)|Logo",
            "influenced": [
                "NetLogo",
                "Etoys (programming language)|Etoys"
            ]
        }
    },
    {
        "id": 596,
        "name": "Stata",
        "url": "https://en.wikipedia.org/wiki/Stata",
        "summary": "<p><b>Stata</b> is a general-purpose statistical software package created in 1985 by StataCorp. Most of its users work in research, especially in the fields of economics, sociology, political science, biomedicine, and epidemiology.</p><p>Stata's capabilities include data management, statistical analysis, graphics, simulations, regression, and custom programming. It also has a system to disseminate user-written programs that lets it grow continuously. </p><p>The name <i>Stata</i> is a syllabic abbreviation of the words <i>statistics</i> and <i>data</i>. The FAQ for the official forum of Stata insists that the correct English pronunciation of <i>Stata</i> \"must remain a mystery\"; any of \"Stay-ta\", \"Sta-ta\" or \"Stah-ta\" are considered acceptable. More recent updates indicate that Stata employees pronounce it \"Stay-ta.\" </p><p>There are four major builds of each version of Stata:</p>\n<ul><li>Stata/MP for multiprocessor computers (including dual-core and multicore processors)</li>\n<li>Stata/SE for large databases</li>\n<li>Stata/IC, which is the standard version</li>\n<li>Numerics by Stata, supports any of the data sizes listed above in an embedded environment</li></ul><p>Small Stata, which was the smaller, student version for educational purchase only, is no longer available.\n</p>\n\n\n",
        "infobox": {
            "name": "Stata",
            "logo": "stata_logo_med_blue.png",
            "caption": "Stata 15 on Microsoft Windows|Windows",
            "author": "William Gould",
            "developer": "StataCorp",
            "released": "1985",
            "latest release version": "16",
            "latest release date": "2019|06|26",
            "programming language": "C (programming language)|C",
            "operating system": [
                "Microsoft Windows|Windows",
                "macOS",
                "Linux"
            ],
            "genre": "Statistical analysis",
            "license": "Proprietary software|Proprietary",
            "website": "https://www.stata.com/"
        }
    },
    {
        "id": 597,
        "name": "Stateflow",
        "url": "https://en.wikipedia.org/wiki/Stateflow",
        "summary": "<p><b>Stateflow</b> (developed by MathWorks) is a control logic tool used to model reactive systems via state machines and flow charts within a Simulink model.  Stateflow uses a variant of the finite-state machine notation established by David Harel, enabling the representation of hierarchy, parallelism and history within a state chart. Stateflow also provides state transition tables and truth tables. </p>",
        "infobox": {
            "name": "Stateflow",
            "screenshot": "Automatic Transmission Logic.png",
            "caption": "Control logic for an automatic transmission system",
            "developer": "MathWorks",
            "latest release version": "R2018b",
            "latest release date": "2018|09|12",
            "latest preview version": "R2018b",
            "latest preview date": "2018|06|14",
            "operating_system": [
                "Windows",
                "macOS",
                "Linux"
            ],
            "platform": "x64",
            "license": "Proprietary software|Proprietary",
            "genre": "Application software",
            "website": "[http://www.mathworks.com/products/stateflow?s_cid=wiki_stateflow_2 Stateflow product page]"
        }
    },
    {
        "id": 598,
        "name": "Strand (programming language)",
        "url": "https://en.wikipedia.org/wiki/Strand_(programming_language)",
        "summary": "<p><b>Strand</b> is a high-level symbolic language for parallel computing, similar in syntax to Prolog. </p><p>Artificial Intelligence Ltd were awarded the British Computer Society Award for Technical Innovation 1989 for Strand88.\nThe language was created by computer scientists Ian Foster and Stephen Taylor.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 599,
        "name": "Strongtalk",
        "url": "https://en.wikipedia.org/wiki/Strongtalk",
        "summary": "<p><b>Strongtalk</b> is a Smalltalk environment with optional static typing support. Strongtalk can make some compile time checks, and offer <i>stronger</i> type safety guarantees; this is the source of its name. It is non-commercial, though it was originally a commercial project developed by a small startup company named <i>LongView Technologies</i> (trading as <i>Animorphic Systems</i>). </p>",
        "infobox": {
            "name": "Strongtalk",
            "paradigm": "Object-oriented programming|Object-oriented",
            "family": "Smalltalk",
            "designers": "Gilad Bracha; David Griswold",
            "developers": [
                "Animorphic Systems",
                "Sun Microsystems"
            ],
            "released": "2002|07|01",
            "latest release version": "2.0",
            "latest release date": "2006|08|09",
            "typing": [
                "Type system|Dynamic",
                "optional Static typing|static"
            ],
            "programming language": "Smalltalk",
            "discontinued": "Stalled",
            "platform": "Cross-platform",
            "operating system": "Cross-platform",
            "license": "Open-source software|Open-source",
            "website": "www.strongtalk.org",
            "influenced by": [
                "Smalltalk",
                "Self (programming language)|Self"
            ],
            "influenced": "Java (programming language)|Java HotSpot"
        }
    },
    {
        "id": 600,
        "name": "Subtext (programming language)",
        "url": "https://en.wikipedia.org/wiki/Subtext_(programming_language)",
        "summary": "<p><b>Subtext</b> is a moderately visual programming language and environment, for writing application software. It is an experimental, research attempt to develop a new programming model, called Example Centric Programming, by treating copied blocks as first class prototypes, for program structure. It uses live text, similar to what occurs in spreadsheets as users update cells, for frequent feedback. It is intended to eventually be developed enough to become a practical language for daily use. It is planned to be open software; the license is not yet determined. </p><p>Subtext was created by Jonathan Edwards who submitted a paper on the language to OOPSLA. It was accepted as part of the 2005 conference.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 601,
        "name": "SuperCollider",
        "url": "https://en.wikipedia.org/wiki/SuperCollider",
        "summary": "<p><b>SuperCollider</b> is an environment and programming language originally released in 1996 by James McCartney for real-time audio synthesis and algorithmic composition.</p><p>Since then it has been evolving into a system used and further developed by both scientists and artists working with sound. It is an efficient and expressive dynamic programming language providing a framework for acoustic research, algorithmic music, interactive programming and live coding. </p><p>Released under the terms of the GPLv2 in 2002, SuperCollider is free and open-source software.\n</p>",
        "infobox": {
            "logo": "SuperCollider logo.svg",
            "logo size": "100px",
            "author": "James McCartney",
            "released": "1996",
            "latest release version": "3.11.0",
            "latest release date": "2020|03|10",
            "repo": "https://github.com/supercollider/supercollider",
            "programming language": "C++",
            "operating system": [
                "FreeBSD",
                "Linux",
                "macOS",
                "Windows"
            ],
            "genre": "Audio programming language",
            "license": "GPL#Version 3|GPLv3",
            "website": "supercollider.github.io"
        }
    },
    {
        "id": 602,
        "name": "SuperTalk",
        "url": "https://en.wikipedia.org/wiki/SuperTalk",
        "summary": "<p><b>SuperTalk</b> is the scripting language used in SuperCard. SuperTalk is a descendant of HyperTalk. </p>",
        "infobox": "N/A"
    },
    {
        "id": 603,
        "name": "Superbase database",
        "url": "https://en.wikipedia.org/wiki/Superbase_(database)",
        "summary": "<p><b>Superbase</b> is an end-user desktop database program that started on the Commodore 64 and was ported from that to various operating systems over the course of more than 20 years. It also has generally included a programming language to automate database-oriented tasks, and with later versions included WYSIWYG form and report designers as well as more sophisticated programming capabilities. </p>",
        "infobox": {
            "name": "Superbase",
            "author": "Precision Software",
            "developer": "Precision Software",
            "released": "1983",
            "operating system": "Cross-platform",
            "genre": "Database software",
            "website": "www.superbase.com"
        }
    },
    {
        "id": 604,
        "name": "Swift (parallel scripting language)",
        "url": "https://en.wikipedia.org/wiki/Swift_(parallel_scripting_language)",
        "summary": "<p><b>Swift</b> is an implicitly parallel programming language that allows writing scripts that distribute program execution across distributed computing resources, including clusters, clouds, grids, and supercomputers. Swift implementations are open-source software under the Apache License, version 2.0. </p>",
        "infobox": {
            "title": "Swift",
            "name": "Swift",
            "logo": "File:Swift (programing language) logo.png|150px",
            "paradigms": [
                "Dataflow",
                "Distributed computing|distributed",
                "Grid computing|grid",
                "Concurrent computing|concurrent",
                "Scientific workflow system|scientific workflow",
                "Scripting language|scripting"
            ],
            "developers": "University of Chicago,<br />Argonne National Laboratory",
            "released": "2007",
            "latest release version": "0.96.2",
            "latest release date": "2015|08|05",
            "typing": "Strong and weak typing|Strong",
            "platform": "Cross-platform: Java (programming language)|Java",
            "operating system": "Cross-platform: Java (programming language)|Java",
            "license": "Apache License|Apache 2.0",
            "website": "swift-lang.org",
            "influenced by": [
                "C (programming language)|C syntax",
                "functional programming"
            ]
        }
    },
    {
        "id": 605,
        "name": "Swift (programming language)",
        "url": "https://en.wikipedia.org/wiki/Swift_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Swift</b> is a general-purpose, multi-paradigm, compiled programming language developed by Apple Inc. for iOS, iPadOS, macOS, watchOS, tvOS, and Linux. Swift is designed to work with Apple's Cocoa and Cocoa Touch frameworks and the large body of existing Objective-C code written for Apple products. It is built with the open source LLVM compiler framework and has been included in Xcode since version 6, released in 2014. On Apple platforms, it uses the Objective-C runtime library which allows C, Objective-C, C++ and Swift code to run within one program.</p><p>Apple intended Swift to support many core concepts associated with Objective-C, notably dynamic dispatch, widespread late binding, extensible programming and similar features, but in a \"safer\" way, making it easier to catch software bugs; Swift has features addressing some common programming errors like null pointer dereferencing and provides syntactic sugar to help avoid the pyramid of doom. Swift supports the concept of protocol extensibility, an extensibility system that can be applied to types, structs and classes, which Apple promotes as a real change in programming paradigms they term \"protocol-oriented programming\" (similar to traits).</p><p>Swift was introduced at Apple's 2014 Worldwide Developers Conference (WWDC). It underwent an upgrade to version 1.2 during 2014 and a more major upgrade to Swift 2 at WWDC 2015. Initially a proprietary language, version 2.2 was made open-source software under the Apache License 2.0 on December 3, 2015, for Apple's platforms and Linux.</p><p>Through version 3.0 the syntax of Swift went through significant evolution, with the core team making source stability a focus in later versions. In the first quarter of 2018 Swift surpassed Objective-C in measured popularity.</p><p>Swift 4.0, released in 2017, introduced several changes to some built-in classes and structures. Code written with previous versions of Swift can be updated using the migration functionality built into Xcode. Swift 5, released in March 2019, introduced a stable binary interface on Apple platforms, allowing the Swift runtime to be incorporated into Apple operating systems. It is source compatible with Swift 4.</p><p>Swift 5.1 was officially released in September 2019. Swift 5.1 builds on the previous version of Swift 5 by extending the stable features of the language to compile-time with the introduction of module stability. The introduction of module stability makes it possible to create and share binary frameworks that will work with future releases of Swift.</p>",
        "infobox": {
            "name": "Swift (programming language)",
            "title": "Swift",
            "logo": "Swift logo with text.svg",
            "logo size": "200px",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: Protocol (object-oriented programming)|protocol-oriented",
                "Object-oriented programming|object-oriented",
                "Functional programming|functional",
                "Imperative programming|imperative",
                "Block (programming)|block structured Declarative_programming|Declarative programming"
            ],
            "released": "start date and age|2014|6|2",
            "designer": [
                "Chris Lattner",
                "Doug Gregor",
                "John McCall",
                "Ted Kremenek",
                "Joe Groff",
                "and Apple Inc."
            ],
            "developer": "Apple Inc.",
            "latest release version": "5.2.4",
            "latest release date": "start date and age|2020|05|20",
            "latest preview version": "5.3 branch",
            "typing": [
                "Type system#Static type-checking|Static",
                "strong typing|strong",
                "type inference|inferred"
            ],
            "operating system": [
                "macOS",
                "Darwin (operating system)|Darwin",
                "Linux",
                "Windows",
                "Android (operating system)|Android"
            ],
            "license": "Apache License 2.0 (Swift 2.2 and later)<br />Proprietary software|Proprietary (up to Swift 2.2)",
            "website": "https://swift.org",
            "file ext": ".swift",
            "influenced_by": [
                "Objective-C",
                "Rust (programming language)|Rust",
                "Haskell (programming language)|Haskell",
                "Ruby (programming language)|Ruby",
                "Python (programming language)|Python",
                "C Sharp (programming language)|C#",
                "CLU (programming language)|CLU",
                "D (programming language)|D"
            ],
            "influenced": "Rust (programming language)|Rust"
        }
    },
    {
        "id": 606,
        "name": "SystemVerilog",
        "url": "https://en.wikipedia.org/wiki/SystemVerilog",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p><b>SystemVerilog</b>, standardized as <b>IEEE 1800</b>, is a hardware description and hardware verification language used to model, design, simulate, test and implement electronic systems. SystemVerilog is based on Verilog and some extensions, and since 2008 Verilog is now part of the same IEEE standard. It is commonly used in the semiconductor and electronic design industry as an evolution of Verilog.\n</p>",
        "infobox": {
            "name": "SystemVerilog",
            "logo": "SystemVerilog logo.png",
            "logo caption": "SystemVerilog logo",
            "file ext": [
                ".sv",
                "header file|.svh"
            ],
            "paradigm": "structured programming|Structured (design)<br/>object-oriented programming|Object-oriented (verification)",
            "released": "2002",
            "designer": [
                "Synopsys",
                "later IEEE"
            ],
            "latest release version": "IEEE 1800-2017",
            "latest release date": "start date and age|2018|02|22",
            "typing": [
                "Type system|Static",
                "Weak typing|weak"
            ],
            "influenced by": [
                "Design: Verilog",
                "VHDL",
                "C++",
                "\nVerification: OpenVera",
                "Java (programming language)|Java"
            ],
            "logo_size": "240px"
        }
    },
    {
        "id": 607,
        "name": "TACL",
        "url": "https://en.wikipedia.org/wiki/TACL",
        "summary": "<p><b>TACL</b> (the <b>Tandem Advanced Command Language</b>) is the scripting programming language used in Tandem Computers. TACL is the shell. </p>",
        "infobox": "N/A"
    },
    {
        "id": 608,
        "name": "TACPOL (programming language)",
        "url": "https://en.wikipedia.org/wiki/TACPOL_(programming_language)",
        "summary": "<p><b>TACPOL</b> (Tactical Procedure Oriented Language) is a block structured programming language developed by the United States Army for the TACFIRE Tactical Fire Direction command and control application.  TACPOL is similar to PL/I. </p>",
        "infobox": "N/A"
    },
    {
        "id": 609,
        "name": "TADS",
        "url": "https://en.wikipedia.org/wiki/TADS",
        "summary": "<p><b>Text Adventure Development System</b> (<b>TADS</b>) is a prototype-based domain-specific programming language and set of standard libraries for creating interactive fiction (IF) games. </p>",
        "infobox": {
            "name": "TADS",
            "paradigm": [
                "prototype-oriented programming|prototype-based",
                "domain-specific language|domain-specific"
            ],
            "released": "start date and age|1988",
            "designer": "Michael J. Roberts",
            "developer": "Michael J. Roberts",
            "latest release version": "Version 3.1.3",
            "latest release date": "start date and age|2013|5|16",
            "typing": [
                "Strong typing",
                "type inference"
            ],
            "operating system": [
                "Amiga",
                "BeOS",
                "DOS",
                "Microsoft Windows",
                "Unix (Linux",
                "Mac OS X)",
                "others"
            ],
            "license": "TADS 2 Freeware source code clarify|date|=|July 2015",
            "website": "www.tads.org"
        }
    },
    {
        "id": 610,
        "name": "TELCOMP",
        "url": "https://en.wikipedia.org/wiki/TELCOMP",
        "summary": "<p><b>TELCOMP</b> was a programming language developed at Bolt, Beranek and Newman (BBN) in about 1964 and in use until at least 1974. BBN offered TELCOMP as a paid service, with first revenue in October 1965.  The service was sold to a company called On-Line Systems in 1972.  In the United Kingdom, TELCOMP was offered by Time Sharing, Ltd, a partnership between BBN and an entrepreneur named Richard Evans. </p><p>It was an interactive, conversational language based on JOSS, developed by BBN after Cliff Shaw from RAND visited the labs in 1964 as part of the NIH survey.  It was first implemented on the PDP-1 and was used to provide a commercial time sharing service by BBN in the Boston area and later by Time Sharing Ltd. in the United Kingdom.\n</p><p>In 1996, Leo Beranek said \"We even developed a programming language called TELCOMP that to this day, some say was better than the programming language that the industry adopted, namely BASIC.\"</p><p>There were at least three versions: TELCOMP I, TELCOMP II, and TELCOMP III.\n</p><p>TELCOMP I was implemented on the PDP-1, TELCOMP II on the PDP-7 and TELCOMP III on the PDP-10, running on DEC\n's TOPS-10 operating system or on BBN's own TENEX operating system.\n</p><p>TELCOMP programs were normally input via a paper tape reader on a Teletype Model 33, which would be connected to a PDP via a modem and acoustic telephone line.  Data could be read from the paper tape reader or from the Teletype keyboard.  Output was either printed to the Teletype or sent to the paper tape punch.  Early versions had no facility for on-line storage of programs or data.\n</p><p>During data input using a Teletype, the user would type a response to a printed prompt. If, instead of hitting <kbd class=\"keyboard-key nowrap\" style=\"border: 1px solid #aaa; -moz-border-radius: 0.2em; -webkit-border-radius: 0.2em; border-radius: 0.2em; -moz-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); -webkit-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); background-color: #f9f9f9; background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: linear-gradient(to bottom, #eee, #f9f9f9, #eee); color: #000; padding: 0.1em 0.3em; font-family: inherit; font-size: 0.85em;\">Return</kbd>, the user hit <kbd class=\"keyboard-key nowrap\" style=\"border: 1px solid #aaa; -moz-border-radius: 0.2em; -webkit-border-radius: 0.2em; border-radius: 0.2em; -moz-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); -webkit-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); background-color: #f9f9f9; background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: linear-gradient(to bottom, #eee, #f9f9f9, #eee); color: #000; padding: 0.1em 0.3em; font-family: inherit; font-size: 0.85em;\">Tab ↹</kbd>, another, possibly computed, prompt would be printed on the same line.  This process could be repeated for the full width of the line. This unusual feature allowed very compact data entry, comparable to full-screen CRT data entry.  It saved paper, and the input section of the form became part of the program's printed output.\n</p><p>A later derivative of TELCOMP called STRINGCOMP was oriented towards string handling.  Another BBN JOSS-derivative called FILECOMP was developed for the GE MEDINET system, which was cancelled. The implicit file handling system it contained was influential on the MUMPS global database system.\n</p><p>The initial research for LOGO was carried out in TELCOMP, but only the JOSS-style errors and interaction made it through to the actual language.\n</p>",
        "infobox": {
            "name": "TELCOMP",
            "released": "1965",
            "developer": "BBN Technologies|BBN",
            "influenced by": "JOSS",
            "influenced": "MUMPS"
        }
    },
    {
        "id": 611,
        "name": "TMG (language)",
        "url": "https://en.wikipedia.org/wiki/TMG_(language)",
        "summary": "<p><b>TMG</b> (TransMoGrifier) is a recursive descent compiler-compiler created by <span>Robert M. McClure</span> and presented in 1965. TMG ran on systems like OS/360 and early Unix. It was used to build EPL, an early version of PL/I.</p><p>Douglas McIlroy ported TMG to an early version of Unix. According to Ken Thompson, McIlroy wrote TMG on a piece of paper and \"decided to give his piece of paper his piece of paper,\" compiling assembly language that he entered and assembled on Thompson's Unix system running on PDP-7. Thompson used TMG in 1970 as a tool to offer Fortran, but due to memory limitations of PDP-7 ended up creating the B programming language which was much influenced by BCPL.</p><p>Recursive descent algorithm of TMG was studied formally by Alexander Birman and Jeffrey Ullman. Formal description of the algorithms was named <i>TMG recognition scheme</i> (or simply <i>TS</i>).</p>",
        "infobox": {
            "name": "TMG",
            "year": "start date and age|1963",
            "designer": "Robert M. McClure",
            "developer": "Robert M. McClure",
            "dialects": "Unix dialect (by Douglas McIlroy)",
            "influenced": "TROL (by Donald Knuth)"
        }
    },
    {
        "id": 612,
        "name": "TOM (object-oriented programming language)",
        "url": "https://en.wikipedia.org/wiki/TOM_(object-oriented_programming_language)",
        "summary": "<p><b>TOM</b> was an object-oriented programming language developed in the 1990s that built on the lessons learned from Objective-C.  The main purpose of TOM was to allow for \"unplanned reuse\" of code via a well-developed extension mechanism.  This concept was introduced seemingly by accident in Objective-C and later proved to be of wide use, and was applied aggressively in TOM. </p><p>The primary changes in TOM are the addition of multiple inheritance, <i>tuples</i> as a first-class part of the language, cleaner syntax, free of the C requirements for header files and pre-compiler commands, and the ability to use <i>categories</i> (the re-use mechanism) to include anything.\n</p><p>It is this latter ability that represents \"the whole idea\".  Unlike Objective-C's categories that allowed only new methods to be built onto existing classes, TOM allowed the addition of class and instance variables, new methods, even new superclasses.  This results in the redefinition of \"class\" as \"a class is defined by its main definition and any extensions\", these extensions have become a first-class citizen of the language (similarly to Ruby).\n</p><p>The book <i>The Pragmatic Programmer</i> lists TOM as an example for a new language to learn.</p><p>Development of the TOM language has ceased.\n</p>",
        "infobox": {
            "name": "TOM",
            "paradigm": "Object-oriented programming|object-oriented",
            "year": "1999",
            "latest_release_version": "1.1.1",
            "latest_release_date": "start date and age|1999|10|15",
            "latest_preview_version": "snapshots",
            "latest preview date": "start date and age|2001|04|14",
            "influenced_by": "Objective-C",
            "license": "GNU General Public License|GPL",
            "file_ext": ".t"
        }
    },
    {
        "id": 613,
        "name": "TRAC (programming language)",
        "url": "https://en.wikipedia.org/wiki/TRAC_(programming_language)",
        "summary": "<p><b>TRAC</b> (for <b>T</b>ext <b>R</b>eckoning <b>A</b>nd <b>C</b>ompiling) <b>Language</b> is a programming language developed between 1959-1964 by Calvin Mooers and implemented on a PDP-10 in 1964 by L. Peter Deutsch. It was one of three \"first languages\" recommended by Ted Nelson in <i>Computer Lib</i>. TRAC T64 was used until at least 1984, when Mooers updated it to TRAC T84.</p>",
        "infobox": {
            "name": "TRAC",
            "paradigm": "general-purpose macro processor",
            "year": "1964",
            "designer": "Calvin Mooers",
            "influenced_by": "Macro SAP",
            "influenced": [
                "SAM76",
                "ML/I"
            ]
        }
    },
    {
        "id": 614,
        "name": "TTCN",
        "url": "https://en.wikipedia.org/wiki/TTCN",
        "summary": "<p><b>TTCN</b> is a programming language used for testing of communication protocols and web services. A TTCN test suite consists of many test cases written in the TTCN programming language. Until version 2 the language was written in tables and called <i><b>Tree and Tabular Combined Notation</b></i>. Reading and editing this language required special TTCN editors. Beginning with version 3 TTCN was renamed to <i><b>Testing and Test Control Notation</b></i>. It is now closer to current programming languages and can be edited with traditional editors. TTCN-3 is more flexible than TTCN-2 in that it can be used for protocol testing as well as testing traditional software. \n</p><p>All versions of TTCN need dedicated compilers or interpreters for execution.\n</p><p>TTCN is widely used, for example; ETSI, ITU for the testing of telecommunication protocols. Conformance test cases of  ETSI standards like ISDN, DECT, GSM, EDGE, 3G, DSRC have also been written in TTCN. Recently it has also been used for testing various protocol standards e.g. Bluetooth, IP. \n</p><p>Execution of those test cases against products (e.g. phones, mobile phones, service enablers or network elements) is used to verify that the protocol implementation in those products meet the requirements defined by telecommunication standards.\n</p><p>TTCN is often combined with ASN.1.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 615,
        "name": "TTM (programming language)",
        "url": "https://en.wikipedia.org/wiki/TTM_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>TTM</b> is a string oriented, general purpose macro processing programming language developed in 1968 by Steven Caine and E. Kent Gordon at the California Institute of Technology.\n</p>",
        "infobox": {
            "name": "TTM",
            "paradigm": "general-purpose macro processor",
            "year": "1968",
            "designer": "Steven M. Caine and E. Kent Gordon",
            "latest_release_version": "1.0",
            "implementations": "Unidata TTM",
            "influenced_by": [
                "GAP",
                "GPM",
                "TRAC programming language|TRAC"
            ],
            "license": "MIT License|MIT"
        }
    },
    {
        "id": 616,
        "name": "TUTOR (programming language)",
        "url": "https://en.wikipedia.org/wiki/TUTOR",
        "summary": "<p><b>TUTOR</b> (also known as <b>PLATO Author Language</b>) is a programming language developed for use on the PLATO system at the University of Illinois at Urbana-Champaign beginning in roughly 1965.  TUTOR was initially designed by Paul Tenczar for use in computer assisted instruction (CAI) and computer managed instruction (CMI) (in computer programs called \"lessons\") and has many features for that purpose.  For example, TUTOR has powerful answer-parsing and answer-judging commands, graphics, and features to simplify handling student records and statistics by instructors.  TUTOR's flexibility, in combination with PLATO's computational power (running on what was considered a supercomputer in 1972), also made it suitable for the creation of many non-educational lessons—that is, <i>games</i>—including flight simulators, war games, dungeon style multiplayer role-playing games, card games, word games, and medical lesson games such as Bugs and Drugs (BND).  TUTOR lives on today as the programming language for the Cyber1 PLATO System, which runs most of the source code from 1980's PLATO and has roughly 5000 users as of June 2020. </p>",
        "infobox": {
            "name": "TUTOR",
            "paradigm": "Imperative programming|imperative (Procedural programming|procedural)",
            "year": "1969",
            "designer": "Paul Tenczar & Richard Blomme",
            "developer": "Paul Tenczar & University of Illinois at Urbana-Champaign",
            "turing-complete": "Yes",
            "typing": "none",
            "implementations": [
                "TUTOR",
                "Micro-TUTOR"
            ],
            "influenced": [
                "TenCORE",
                "USE (programming language)|USE (Regency Systems R2C|Regency Systems)"
            ]
        }
    },
    {
        "id": 617,
        "name": "TXL (programming language)",
        "url": "https://en.wikipedia.org/wiki/TXL_(programming_language)",
        "summary": "<p><b>TXL</b> is a special-purpose programming language originally designed by Charles Halpern-Hamu and James Cordy at the University of Toronto in 1985.  The acronym \"TXL\" originally stood for \"Turing eXtender Language\" after the language's original purpose, the specification and rapid prototyping of variants and extensions of the Turing programming language, but no longer has any meaningful interpretation. </p><p>Modern TXL is specifically designed for creating, manipulating and rapidly prototyping language-based descriptions, tools and applications using source transformation.   It is a hybrid functional / rule-based language using first order functional programming at the higher level and term rewriting at the lower level.  The formal semantics and implementation of TXL are based on formal term rewriting, but the term structures are largely hidden from the user due to the example-like style of pattern specification.\n</p><p>Each TXL program has two components: a description of the source structures to be transformed, specified as a (possibly ambiguous) context-free grammar using an extended Backus–Naur Form; and a set of tree transformation rules, specified using pattern / replacement pairs combined using first order functional programming.  TXL is designed to allow explicit programmer control over the interpretation, application, order and backtracking of both parsing and rewriting rules, allowing for expression of a wide range of grammar-based techniques such as agile parsing.\n</p><p>The first component parses the input expression into a tree using pattern-matching. The second component uses Term-rewriting in a manner similar to Yacc to produce the transformed output.\n</p><p>TXL is most commonly used in software analysis and reengineering tasks such as design recovery, and in rapid prototyping of new programming languages and dialects.\n</p>",
        "infobox": {
            "name": "TXL",
            "paradigm": "Pattern-matching and Term-rewriting",
            "designer": "Charles Halpern-Hamu <br> James Cordy",
            "developer": "James Cordy <br> Charles Halpern-Hamu <br> Ian Carmichael <br> Eric Promislow"
        }
    },
    {
        "id": 618,
        "name": "T (programming language)",
        "url": "https://en.wikipedia.org/wiki/T_(programming_language)",
        "summary": "<p>The programming language <b>T</b> is a dialect of the language Scheme developed in the early 1980s by Jonathan A. Rees, Kent M. Pitman, and Norman I. Adams of Yale University as an experiment in language design and implementation.</p> \n\n",
        "infobox": {
            "name": "T",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: Object-oriented programming|object-oriented",
                "Imperative programming|imperative",
                "Functional programming|functional",
                "Metaprogramming|meta"
            ],
            "family": "Lisp (programming language)|Lisp",
            "designers": "Jonathan A. Rees<br/>Norman I. Adams",
            "developers": "Jonathan A. Rees<br/>Norman I. Adams",
            "released": "1982",
            "latest release version": "3.0",
            "latest release date": "1984|08|01",
            "typing": [
                "dynamic typing|dynamic",
                "strong typing|strong"
            ],
            "discontinued": "Yes",
            "platform": "Cross-platform",
            "operating system": "Cross-platform",
            "website": "mumble.net/~jar/tproject",
            "influenced by": "Scheme (programming language)|Scheme",
            "influenced": [
                "EuLisp",
                "Joule (programming language)|Joule"
            ]
        }
    },
    {
        "id": 619,
        "name": "Tcl",
        "url": "https://en.wikipedia.org/wiki/Tcl",
        "summary": "<p><b>Tcl</b> (pronounced \"tickle\" or as an initialism) is a high-level, general-purpose, interpreted, dynamic programming language. It was designed with the goal of being very simple but powerful. Tcl casts everything into the mold of a command, even programming constructs like variable assignment and procedure definition. Tcl supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. </p><p>It is commonly used embedded into C applications, for rapid prototyping, scripted applications, GUIs, and testing. Tcl interpreters are available for many operating systems, allowing Tcl code to run on a wide variety of systems. Because Tcl is a very compact language, it is used on embedded systems platforms, both in its full form and in several other small-footprint versions.</p><p>The popular combination of Tcl with the Tk extension is referred to as <b>Tcl/Tk</b>, and enables building a graphical user interface (GUI) natively in Tcl. Tcl/Tk is included in the standard Python installation in the form of Tkinter.\n</p>",
        "infobox": {
            "name": "Tcl",
            "logo": "File:Tcl-powered.svg|70px|Tcl logo",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm: event-driven programming|event-driven",
                "functional programming|functional",
                "imperative programming|imperative",
                "object-oriented programming|object-oriented"
            ],
            "released": "1988",
            "designer": "John Ousterhout",
            "developer": "Tcl Core Team",
            "latest_release_version": "[https://sourceforge.net/projects/tcl/files/Tcl/8.6.10/tcltk-release-notes-8.6.10.txt/view 8.6.10]",
            "latest_release_date": "2019|11|21",
            "latest preview version": "[https://sourceforge.net/projects/tcl/files/Tcl/8.7a3/tcltk-release-notes-8.7a3.txt/view 8.7a3]",
            "latest preview date": "2019|11|25",
            "typing": [
                "Dynamic typing",
                "everything can be treated as a string (programming)|string"
            ],
            "implementations": "[https://www.activestate.com/activetcl ActiveTcl] [https://www.androwish.org Androwish]",
            "dialects": "[http://jim.tcl.tk Jim]",
            "influenced_by": [
                "AWK",
                "Lisp (programming language)|Lisp"
            ],
            "influenced": [
                "PHP",
                "Windows PowerShell|PowerShell",
                "Tea (programming language)|Tea"
            ],
            "license": "BSD licenses|BSD-style",
            "website": "https://www.tcl-lang.org <br> https://www.tcl.tk",
            "file_ext": [
                ".tcl",
                ".tbc"
            ]
        }
    },
    {
        "id": 620,
        "name": "TeX",
        "url": "https://en.wikipedia.org/wiki/TeX",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>TeX</b> (<span></span>, see below), stylized within the system as <span>T<span>e</span>X</span>, is a typesetting system (or a \"formatting system\") which was designed and mostly written by Donald Knuth and released in 1978. TeX is a popular means of typesetting complex mathematical formulae; it has been noted as one of the most sophisticated digital typographical systems.</p><p>TeX is popular in academia, especially in mathematics, computer science, economics, engineering, linguistics, physics, statistics, and quantitative psychology. It has largely displaced Unix troff, the other favored formatting system, in many Unix installations which use both for different purposes. It is also used for many other typesetting tasks, especially in the form of LaTeX, ConTeXt, and other macro packages.\n</p><p>TeX was designed with two main goals in mind: to allow anybody to produce high-quality books with minimal effort, and to provide a system that would give exactly the same results on all computers, at any point in time (together with the Metafont language for font description and the Computer Modern family of typefaces). TeX is free software, which made it accessible to a wide range of users.\n</p>",
        "infobox": {
            "name": "TeX",
            "logo": "File:TeX logo.svg|100px|The TeX logo",
            "developer": "Donald Knuth",
            "released": "start date and age|df|=|yes|1978",
            "latest_release_version": "3.14159265",
            "latest_release_date": "start date and age|df|=|yes|2014|1",
            "operating_system": "Cross-platform",
            "genre": "Typesetting",
            "programming_language": "WEB/Pascal (programming language)|Pascal",
            "status": "Maintained",
            "license": "Permissive free software license|Permissive free software",
            "website": "tug.org"
        }
    },
    {
        "id": 621,
        "name": "Tea (programming language)",
        "url": "https://en.wikipedia.org/wiki/Tea_(programming_language)",
        "summary": "<p><b>Tea</b> is a high-level scripting language for the Java environment. It combines features of Scheme, Tcl, and Java.</p>",
        "infobox": {
            "name": "Tea",
            "released": "1997",
            "paradigm": [
                "Multi-paradigm: Functional programming|Functional",
                "Object-oriented programming|Object-oriented (Class-based programming|class-based)"
            ],
            "developer": "Jorge Nunes",
            "influenced by": [
                "Tcl",
                "Java (programming language)|Java",
                "Scheme (programming language)|Scheme"
            ],
            "website": "[http://www2.pdmfc.com/tea www2.pdmfc.com/tea]"
        }
    },
    {
        "id": 622,
        "name": "TempleOS",
        "url": "https://en.wikipedia.org/wiki/TempleOS",
        "summary": "<p><b>TempleOS</b> (formerly <b>J Operating System</b>, <b>SparrowOS</b> and <b>LoseThos</b>) is a biblical-themed lightweight operating system designed to be the Third Temple prophesied in the Bible. It was created by American programmer Terry A. Davis, who developed it alone over the course of a decade after a series of manic episodes that he later described as a revelation from God. </p><p>The system was characterized as a modern x86-64 Commodore 64, using an interface similar to a mixture of DOS and Turbo C. Davis proclaimed that the system's features, such as its 640x480 resolution, 16-color display and single audio voice, were explicitly instructed to him by God. It was programmed with an original variation of C (named HolyC) in place of BASIC, and included an original flight simulator, compiler and kernel.\n</p><p>TempleOS was released as J Operating System in 2005, as TempleOS in 2013, and was last updated in 2017. It was received with largely favorable reviews in tech communities and Davis amassed a small online following.</p>\n\n\n",
        "infobox": {
            "name": "TempleOS",
            "logo": "File:TempleOS logo.png",
            "screenshot": "File:TempleOS 4.05 session.png",
            "caption": "TempleOS 4.05",
            "developer": "Terry A. Davis",
            "programmed in": "HolyC",
            "released": "2005 (as J Operating System) <br/> 2013 (as TempleOS)",
            "ui": "Text-based",
            "license": "Public domain",
            "source_model": "Open-source software|Open source",
            "latest_release_version": "5.03",
            "latest_release_date": "2017|11|20",
            "kernel_type": "Monolithic",
            "working_state": "Finished",
            "supported_platforms": "x86-64"
        }
    },
    {
        "id": 623,
        "name": "Tensilica Instruction Extension",
        "url": "https://en.wikipedia.org/wiki/Tensilica_Instruction_Extension",
        "summary": "<p><b>Tensilica Instruction Extension</b> refers to the proprietary language that is used to customize Tensilica's Xtensa processor core architecture. </p><p>By using TIE, the user can customize the Xtensa architecture by adding custom instructions and register files, instantiating TIE Ports and Queues for multiprocessor communication, and adding pre-configured extensions (such as Tensilica's DSP).  Software applications can greatly benefit from properly targeted user-defined instructions, while TIE ports and TIE queues facilitate multiprocessor communication by adding separate input and output interfaces to the processor core.  Using the TIE language and Xtensa Xplorer toolkit, the generation and verification of the instructions used to extend the processor ISA are automated. Such automation helps to reduce the hardware verification time that typically consumes a large percentage of the project duration of a typical hardware developed for the same functionality.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 624,
        "name": "Text Editor and Corrector",
        "url": "https://en.wikipedia.org/wiki/TECO_(text_editor)",
        "summary": "<p><b>TECO</b> (Tee'koh / <span></span>), Text Editor &amp; Corrector is both a character-oriented text editor and a programming language, that was developed in 1962 for use on Digital Equipment Corporation computers, and has since become available on PCs and Unix. Dan Murphy developed TECO while a student at the Massachusetts Institute of Technology (MIT).</p><p>According to Murphy, the initial acronym was \"Tape Editor and Corrector\" because \"punched paper tape was the only medium for the storage of program source on our PDP-1. There was no hard disk, floppy disk, magnetic tape (magtape), or network.\" By the time TECO was made available for general use, the name had become \"Text Editor and Corrector,\" since even the PDP-1 version by then supported other media. It was subsequently modified by many other people and is a direct ancestor of Emacs, which was originally implemented in TECO macros.</p>",
        "infobox": {
            "name": "TECO",
            "author": "Daniel Murphy (computer scientist)|Dan Murphy",
            "released": "1962/63",
            "operating system": [
                "OS/8",
                "Incompatible Timesharing System|ITS",
                "TOPS-10",
                "TOPS-20",
                "RT-11",
                "RSTS/E",
                "OpenVMS"
            ],
            "genre": "Text editor"
        }
    },
    {
        "id": 625,
        "name": "Text Executive Programming Language",
        "url": "https://en.wikipedia.org/wiki/Text_Executive_Programming_Language",
        "summary": "<p>In 1979, Honeywell Information Systems announced a new programming language for their time-sharing service named <b>TEX</b>, an acronym for the <b>Text Executive</b> text processing system. <b>TEX</b> was a first generation scripting language, developed around the time of AWK and used by Honeywell initially as an in-house system test automation tool. </p><p><b>TEX</b> extended the <b>Honeywell Time-Sharing service (TSS)</b> line editor with programmable capabilities which allowed the user greater latitude in developing ease-of-use editing extensions as well as write scripts to automate many other time-sharing tasks formerly done by more complex TSS FORTRAN programs.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 626,
        "name": "Text Processing Utility",
        "url": "https://en.wikipedia.org/wiki/DEC_Text_Processing_Utility",
        "summary": "<p><b>DEC Text Processing Utility</b> (or <b>DECTPU</b>) was a language developed by Digital Equipment Corporation (DEC) for developing text editors. </p><p>In 1986, DEC developed a new version of EDT written in TPU, \nhaving released EVE, also a TPU-based editor, by mid-1985.</p><p>TPU is distributed with OpenVMS. It is designed to be used on a terminal or console, so that it is not necessary to have DECwindows installed to use it.\n</p><p>Among other things the Language-Sensitive Editor and EVE (Extensible Versatile Editor) are implemented using DECTPU.\n</p><p>TPU provides text buffer management APIs in concert with Window management APIs which were targeted for the VT-XXX line of terminals.  This allowed split screen windows with scrolling and hence multiple views of the same buffer content.  There were also key mapping APIs provided allowing a wide range of functionality over all for editing text.  A version of the VI editor was created by Gregg Wonderly at Oklahoma State University called TPUVI and also VITPU by some parties.  VITPU is still made available for use via the DECUS archives on line.</p>",
        "infobox": "N/A"
    },
    {
        "id": 627,
        "name": "Timeline of programming languages",
        "url": "https://en.wikipedia.org/wiki/Timeline_of_programming_languages",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p>This is a record of historically important programming languages, by decade.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 628,
        "name": "Toi (programming language)",
        "url": "https://en.wikipedia.org/wiki/Toi_(programming_language)",
        "summary": "<p><b>Toi</b> is an imperative, type-sensitive language that provides the basic functionality of a programming language. The language was designed and developed from the ground-up by Paul Longtine. Written in C, Toi was created with the intent to be an educational experience and serves as a learning tool (or toy, hence the name) for those looking to familiarize themselves with the inner-workings of a programming language.</p>",
        "infobox": "N/A"
    },
    {
        "id": 629,
        "name": "Tom (pattern matching language)",
        "url": "https://en.wikipedia.org/wiki/Tom_(pattern_matching_language)",
        "summary": "<p><b>Tom</b> is a programming language particularly well-suited for programming various transformations on tree structures and XML based documents. Tom is a language extension which adds new matching primitives to C and Java as well as support for rewrite rules systems. The rules can be controlled using a strategy language. </p><p>Tom is good for:\n</p>\n<ul><li>programming by pattern matching</li>\n<li>developing compilers and DSL</li>\n<li>transforming XML documents</li>\n<li>implementing rule based systems</li>\n<li>describing algebraic transformations</li></ul>",
        "infobox": {
            "name": "Tom",
            "logo": "Tom (pattern matching language) logo.png",
            "developer": "INRIA",
            "latest release version": "2.10",
            "latest release date": "2013-03-21",
            "genre": "program transformation language",
            "license": [
                "GPL",
                "BSD licenses"
            ],
            "website": "tom.loria.fr"
        }
    },
    {
        "id": 630,
        "name": "Transact-SQL",
        "url": "https://en.wikipedia.org/wiki/Transact-SQL",
        "summary": "<p><b>Transact-SQL</b> (<b>T-SQL</b>) is Microsoft's and Sybase's proprietary extension to the SQL (Structured Query Language) used to interact with relational databases. T-SQL expands on the SQL standard to include procedural programming, local variables, various support functions for string processing, date processing, mathematics, etc. and changes to the DELETE and UPDATE statements. </p><p>Transact-SQL is central to using Microsoft SQL Server. All applications that communicate with an instance of SQL Server do so by sending Transact-SQL statements to the server, regardless of the user interface of the application.\n</p><p>Stored procedures in SQL Server are executable server-side routines. The advantage of stored procedures is the ability to pass parameters.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 631,
        "name": "Transaction Application Language",
        "url": "https://en.wikipedia.org/wiki/Transaction_Application_Language",
        "summary": "<p><b>Transaction Application Language</b> or <b>TAL</b> (originally \"Tandem Application Language\") is a block-structured, procedural language optimized for use on Tandem hardware. TAL resembles a cross between C and Pascal. It was the original system programming language for the Tandem CISC machines, which had no assembler. </p><p>The design concept of TAL, an evolution of Hewlett Packard's SPL, was intimately associated and optimized with a microprogrammed CISC instruction set. Each TAL statement could easily compile into a sequence of instructions that manipulated data on a transient floating register stack. The register stack itself floated at the crest of the program's memory allocation and call stack.\n</p><p>The language itself has the appearance of ALGOL or Pascal, with BEGIN and END statements. However, its semantics are far more like C. It does not permit indefinite levels of procedure nesting, it does not pass complex structured arguments by value, and it does not strictly type most variable references. Programming techniques are much like C using pointers to structures, occasional overlays, deliberate string handling and casts when appropriate.\n</p><p>Available datatypes include 8 bit, 16 bit, 32 bit and (introduced later) 64 bit integers. Microcode level support was available for null terminated character strings. However, this is not commonly used.\n</p><p>Originally the Tandem NonStop operating system was written in TAL. Recently much of it has been rewritten in C and TAL has been deprecated for new development.\n</p><p>In the migration from CISC to RISC TAL was updated/replaced with pTAL - compilers allowed TAL to be accelerated/re-compiled into Native RISC Applications.\n</p><p>In the current migration from RISC to Intel Itanium 2 TAL and pTAL has been replaced with epTAL, again - compilers allow TAL and pTAL code to be accelerated/re-compiled into native Itanium Applications. \n</p><p><span><small>This article is based on material taken from  the <i>Free On-line Dictionary of Computing</i>  prior to 1 November 2008 and incorporated under the \"relicensing\" terms of the GFDL, version 1.3 or later.</small></span>\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 632,
        "name": "Transcript (programming language)",
        "url": "https://en.wikipedia.org/wiki/LiveCode",
        "summary": "<p><b>LiveCode</b> (formerly Revolution and MetaCard) is a cross-platform rapid application development runtime system inspired by HyperCard. It features the <i>LiveCode Script</i> (formerly MetaTalk) programming language which belongs to the family of xTalk scripting languages like HyperCard's HyperTalk.</p><p>The environment was introduced in 2001.  The \"Revolution\" development system was based on the MetaCard engine technology which Runtime Revolution later acquired from MetaCard Corporation in 2003. The platform won the Macworld Annual Editor's Choice Award for \"Best Development Software\" in 2004.  \"Revolution\" was renamed \"LiveCode\" in the fall of 2010.  \"LiveCode\" is developed and sold by Runtime Revolution Ltd., based in Edinburgh, Scotland. In March, 2015, the company was renamed \"LiveCode Ltd.\", to unify the company name with the product. In April 2013 a free/open source version 'LiveCode Community Edition 6.0' was published after a successful crowdfunding campaign at Kickstarter. The code base was re-licensed and made available as free and open source software with a version in April 2013. </p><p>LiveCode runs on iOS, Android, OS X, Windows 95 through Windows 10, Raspberry Pi and several variations of Unix, including Linux, Solaris, and BSD. It can be used for mobile, desktop and server/CGI applications. The iOS (iPhone and iPad) version was released in December 2010. The first version to deploy to the Web was released in 2009. It is the most widely used HyperCard/HyperTalk clone, and the only one that runs on all major operating systems.\n</p><p>A developer release of v.8 was announced in New York on March 12, 2015. This major enhancement to the product includes a new, separate development language, known as \"LiveCode Builder\",  which is capable of creating new object classes called \"widgets\". In earlier versions, the set of object classes was fixed, and could be enhanced only via the use of ordinary procedural languages such as C. The new language, which runs in its own IDE, is a departure from the transitional x-talk paradigm in that it permits typing of variables. But the two environments are fully integrated, and apart from the ability to create new objects, development in LiveCode proceeds in the normal way, within the established IDE.\n</p><p>A second crowdfunding campaign to Bring HTML5 to LiveCode reached funding goals of nearly $400,000 USD on July 31, 2014. LiveCode developer release 8.0 DP4 (August 31, 2015) was the first to include a standalone deployment option to HTML5.\n</p>",
        "infobox": {
            "name": "LiveCode",
            "developer": "LiveCode (company)|LiveCode Ltd.",
            "released": "2001|07|11",
            "latest_release_version": "9.5.1",
            "latest_release_date": "2019|12|16",
            "latest preview version": "9.6.0DP4",
            "latest preview date": "2020|04|16",
            "operating_system": [
                "macOS",
                "Windows (operating system)|Windows",
                " Linux",
                "Unix",
                "Android (operating system)|Android",
                "iOS",
                "HTML5"
            ],
            "genre": "Programming language|Programming",
            "license": [
                "GPL",
                "Proprietary software|Proprietary"
            ],
            "website": "livecode.org Official URL"
        }
    },
    {
        "id": 633,
        "name": "Turing (programming language)",
        "url": "https://en.wikipedia.org/wiki/Turing_(programming_language)",
        "summary": "<p><b>Turing</b> is a Pascal-like programming language developed in 1982 by Ric Holt and James Cordy, then of University of Toronto, in Toronto, Ontario, Canada. Turing is a descendant of Euclid, Pascal and SP/k that features a clean syntax and precise machine-independent semantics. </p><p>Turing 4.1.0 is the latest stable version of Turing. Turing 4.1.1 and Turing 4.1.2 do not allow for stand alone .EXE files to be created and versions before Turing 4.1.0 have outdated syntax and outdated functions.\n</p>",
        "infobox": {
            "name": "Turing",
            "logo": "File:Turing logo.gif",
            "paradigm": [
                "Multi-paradigm programming language|multi-paradigm: Object-oriented programming|object-oriented",
                "procedural programming|procedural"
            ],
            "year": "1982",
            "designer": "Ric Holt and James Cordy",
            "developer": "Holt Software Associates",
            "typing": [
                "static typing|static",
                "manifest typing|manifest"
            ],
            "implementations": [
                "Turing",
                "TPlus",
                "OpenT"
            ],
            "dialects": [
                "Object-Oriented Turing",
                "Turing Plus"
            ],
            "influenced_by": [
                "Euclid (programming language)|Euclid",
                "Pascal (programming language)|Pascal",
                "SP/k"
            ],
            "operating_system": "Microsoft Windows"
        }
    },
    {
        "id": 634,
        "name": "Tynker",
        "url": "https://en.wikipedia.org/wiki/Tynker",
        "summary": "<p><b>Tynker</b> is an educational programming platform aimed at teaching children how to make games and programs.  Instead of typing the source code, you visually drag blocks of code and snap them together. The visual design and principles are based on the free Scratch, just like Hopscotch and Snap!. Tynker is based on HTML5 and JavaScript, and can be used in the browser without plugins, as well as on tablets and smartphones. Another difference is that Scratch is a free open source project, while Tynker is a commercial product, aimed at selling courses. Tynker offers self-paced online courses for children to learn coding at home, as well as an engaging programming curriculum for schools and camps. It makes it easier for kids to learn coding as it teaches kids coding through creating games like Minecraft, Hour of Code etc. </p>",
        "infobox": {
            "logo": "Tynker logo.png",
            "logo_size": "frameless",
            "name": "Tynker IDE",
            "screenshot": "Tynker - Sample - Ghost hunter.png",
            "caption": [
                "Screenshot of Tynker web IDE",
                "editing a project"
            ],
            "developer": "Tynker",
            "genre": "Educational Programming Language",
            "website": "url|tynker.com"
        }
    },
    {
        "id": 635,
        "name": "TypeScript",
        "url": "https://en.wikipedia.org/wiki/TypeScript",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p><b>TypeScript</b> is an open-source programming language developed and maintained by Microsoft. It is a strict syntactical superset of JavaScript and adds optional static typing to the language. TypeScript is designed for development of large applications and transcompiles to JavaScript. As TypeScript is a superset of JavaScript, existing JavaScript programs are also valid TypeScript programs.\n</p><p>TypeScript may be used to develop JavaScript applications for both client-side and server-side execution (as with Node.js or Deno). There are multiple options available for transcompilation. Either the default TypeScript Checker can be used, or the Babel compiler can be invoked to convert TypeScript to JavaScript.\n</p><p>TypeScript supports definition files that can contain type information of existing JavaScript libraries, much like C++ header files can describe the structure of existing object files. This enables other programs to use the values defined in the files as if they were statically typed TypeScript entities. There are third-party header files for popular libraries such as jQuery, MongoDB, and D3.js. TypeScript headers for the Node.js basic modules are also available, allowing development of Node.js programs within TypeScript.</p><p>The TypeScript compiler is itself written in TypeScript and compiled to JavaScript. It is licensed under the Apache License 2.0. TypeScript is included as a first-class programming language in Microsoft Visual Studio 2013 Update 2 and later, beside C# and other Microsoft languages. An official extension allows Visual Studio 2012 to support TypeScript as well. Anders Hejlsberg, lead architect of C# and creator of Delphi and Turbo Pascal, has worked on the development of TypeScript.</p>\n\n\n",
        "infobox": {
            "name": "TypeScript",
            "logo": "File:TypeScript Logo.svg|frameless",
            "paradigm": [
                "Multi-paradigm programming language|Multi-paradigm: functional programming|functional",
                "generic programming|generic",
                "imperative programming|imperative",
                "object-oriented programming|object-oriented"
            ],
            "released": "2012|10|01",
            "designer": "Microsoft",
            "developer": "Microsoft",
            "latest release version": "3.9.7",
            "latest release date": "df|=|yes|2020|07|06",
            "latest preview version": "3.9 RC",
            "latest preview date": "df|=|yes|2020|04|28",
            "typing": [
                "Duck typing|Duck",
                "Gradual typing|gradual",
                "Structural type system|structural"
            ],
            "influenced by": [
                "C Sharp (programming language)|C#",
                "Java (programming language)|Java",
                "JavaScript"
            ],
            "influenced": [
                "AtScript",
                "AssemblyScript"
            ],
            "license": "Apache License 2.0",
            "file ext": [
                ".ts",
                ".tsx"
            ],
            "website": "https://www.typescriptlang.org"
        }
    },
    {
        "id": 636,
        "name": "UCSD Pascal",
        "url": "https://en.wikipedia.org/wiki/UCSD_Pascal",
        "summary": "<p><b>UCSD Pascal</b> is a Pascal programming language system that runs on the <b>UCSD p-System</b>, a portable, highly machine-independent operating system. UCSD Pascal was first released in 1977. It was developed at the University of California, San Diego (UCSD). </p>",
        "infobox": {
            "name": "UCSD Pascal/p-System",
            "logo": "File:UCSD p-System.svg|150px",
            "logo caption": "Logo of Version IV",
            "developer": [
                "University of California",
                "San Diego",
                "SofTech",
                "Inc.|SofTech",
                "Pecan"
            ],
            "kernel_type": "p-code machine|p-code virtual machine",
            "supported_platforms": [
                "Apple II",
                "Digital Equipment Corporation|DEC PDP-11",
                "Zilog Z80",
                "MOS 6502",
                "Motorola 68000",
                "x86 architecture|x86",
                "Osborne Executive",
                "Pascal MicroEngine",
                "TI 99/4A"
            ],
            "family": "p-code machine|p-code operating systems",
            "released": "1977|08",
            "latest_release_version": "IV.2.1 R3.3",
            "latest_release_date": "1984|11",
            "prog_language": "Pascal (programming language)|Pascal",
            "language": "English language|English",
            "working_state": "Historic"
        }
    },
    {
        "id": 637,
        "name": "UNITY (programming language)",
        "url": "https://en.wikipedia.org/wiki/UNITY_(programming_language)",
        "summary": "<p><b>UNITY</b> is a programming language constructed by K. Mani Chandy and Jayadev Misra for their book <i>Parallel Program Design: A Foundation</i>. It is a theoretical language which focuses on <i>what</i>, instead of <i>where</i>, <i>when</i> or <i>how</i>. The language contains no method of flow control, and program statements run in a nondeterministic way until statements cease to cause changes during execution. This allows for programs to run indefinitely, such as auto-pilot or power plant safety systems, as well as programs that would normally terminate (which here converge to a fixed point). </p>",
        "infobox": "N/A"
    },
    {
        "id": 638,
        "name": "Ubercode",
        "url": "https://en.wikipedia.org/wiki/Ubercode",
        "summary": "<p><b>Ubercode</b> is a high level programming language designed by Ubercode Software and released in 2005 for Microsoft Windows. Ubercode is influenced by Eiffel and BASIC. It is proprietary software and can be tried out for free for 30 days. Ubercode has the following design goals: </p>\n<ol><li><i>Compilable language</i>—compiled into Windows EXE files.</li>\n<li><i>Automatic memory management</i>—memory is allocated / freed automatically, and the language has no memory management primitives.</li>\n<li><i>Pre and post conditions</i>—these are run-time assertions which are attached to function declarations, as in Eiffel.</li>\n<li><i>High-level data types</i>—resizable arrays, lists and tables may contain arbitrary components.</li>\n<li><i>Integrated file handling</i>—primitives for transparent handling of text, binary, CSV, XML and dBase files.</li>\n<li><i>Ease of use</i>—language structure is relatively simple, making the language accessible to beginners.</li></ol>",
        "infobox": "N/A"
    },
    {
        "id": 639,
        "name": "Umple",
        "url": "https://en.wikipedia.org/wiki/Umple",
        "summary": "<p><b>Umple</b> is a language for both object-oriented programming and modelling with class diagrams and state diagrams. The name Umple is a portmanteau of \"UML\", \"ample\" and \"Simple\", indicating that it is designed to provide ample features to extend programming languages with UML capabilities.\n</p>\n\n\n",
        "infobox": {
            "name": "Umple",
            "logo": "File:Umple Logo.png|200px",
            "paradigm": "object-oriented programming|object-oriented",
            "year": "2008",
            "designer": "University of Ottawa",
            "developer": [
                "Cruise Group in the Department of Electrical Engineering and Computer Science",
                "Led by Timothy Lethbridge at University of Ottawa"
            ],
            "latest_release_version": "[https://github.com/umple/umple/releases/tag/v1.30.0 1.30.0]",
            "latest_release_date": "release date|2020|07|23",
            "typing": "static typing|static",
            "influenced_by": [
                "Java (programming language)|Java",
                "C++",
                "Unified Modeling Language|UML",
                "Ruby (programming language)|Ruby",
                "PHP"
            ],
            "platform": "JVM",
            "license": "MIT License",
            "website": "http://www.umple.org/",
            "file_ext": ".ump"
        }
    },
    {
        "id": 640,
        "name": "Unicon (programming language)",
        "url": "https://en.wikipedia.org/wiki/Unicon_(programming_language)",
        "summary": "<p><b>Unicon</b> is a programming language designed by American computer scientist Clint Jeffery with collaborators including Shamim Mohamed, Jafar Al Gharaibeh, Robert Parlett and others. Unicon descended from Icon and a preprocessor for Icon called IDOL. Compared with Icon, Unicon offers better access to the operating system as well as support for object-oriented programming. Unicon began life as a merger of three popular Icon extensions: an OO preprocessor named Idol, a POSIX filesystem and networking interface, and an ODBC facility. The name is shorthand for \"Unified Extended Dialect of Icon.\" </p>",
        "infobox": {
            "name": "Unicon",
            "paradigm": [
                "object-oriented programming|object-oriented",
                "procedural programming|procedural"
            ],
            "designer": "Clint Jeffery",
            "influenced by": "Icon programming language|Icon",
            "operating system": [
                "Cross-platform: Microsoft Windows|Windows",
                "Unix"
            ],
            "license": "GNU General Public License",
            "website": "url|http://unicon.sourceforge.net/"
        }
    },
    {
        "id": 641,
        "name": "Uniface (programming language)",
        "url": "https://en.wikipedia.org/wiki/Uniface_(programming_language)",
        "summary": "<p><b>Uniface</b> is a development and deployment platform for enterprise applications that can run in a large range of runtime environments, including mobile, mainframe, web, Service-oriented architecture (SOA), Windows, Java EE and .NET.  Uniface is a model-driven, Rapid Application Development (RAD) environment used to create mission-critical applications. </p><p>Uniface applications are database- and platform-independent. Uniface provides an integration framework that enables Uniface applications to integrate with all major DBMS products such as Oracle, Microsoft SQL Server, MySQL and IBM DB2. In addition, Uniface also supports file systems such as RMS (HP OpenVMS), Sequential files, operating system text files  and a wide range of other technologies, such as mainframe-based products (CICS, IMS), web services, SMTP and POP email, LDAP directories, .NET, ActiveX, Component Object Model (COM), C(++) programs, and Java. Uniface operates under Microsoft Windows, Windows Mobile, various flavors of Unix and Linux, VMS, IBM iSeries, and  z/OS.\n</p><p>Uniface can be used in complex systems that maintain critical enterprise data supporting mission-critical business processes such as point-of sale and web-based online shopping, financial transactions, salary administration, and inventory control. It is currently used by thousands of companies in more than 30 countries, with an effective installed base of millions of end-users. Uniface applications range from client/server to web, and from data entry to workflow, as well as portals that are accessed locally, via intranets and the internet.\n</p><p>Originally developed in the Netherlands by Inside Automation, later Uniface B.V., the product and company were acquired by Detroit-based Compuware Corp in 1994, and in 2014 was acquired by Marlin Equity Partners and is now an independent company. Uniface B.V. global headquarters are in Amsterdam.\n</p>",
        "infobox": {
            "logo": "Uniface_Logo.jpg",
            "name": "Uniface",
            "developer": "Uniface (company)|Uniface (1986–present)",
            "author": "Inside Automation (1984-1986)",
            "latest_release_version": "Uniface 10.3.01",
            "latest_release_date": "Release date and age|2018|08|08",
            "operating system": [
                "Windows",
                "Windows Mobile",
                "Unix-like",
                "VMS (operating system)|VMS",
                "IBM System i|IBM iSeries",
                "z/OS"
            ],
            "language": "English",
            "genre": "Integrated Development Environment",
            "license": "Commercial software|Commercial",
            "website": "uniface.com"
        }
    },
    {
        "id": 642,
        "name": "Unix shell",
        "url": "https://en.wikipedia.org/wiki/Unix_shell",
        "summary": "<p>A <b>Unix shell</b> is a command-line interpreter or shell that provides a command line user interface for Unix-like operating systems.  The shell is both an interactive command language and a scripting language, and is used by the operating system to control the execution of the system using shell scripts.</p><p>Users typically interact with a Unix shell using a terminal emulator; however, direct operation via serial hardware connections or Secure Shell are common for server systems.  All Unix shells provide filename wildcarding, piping, here documents, command substitution, variables and control structures for condition-testing and iteration. </p>",
        "infobox": "N/A"
    },
    {
        "id": 643,
        "name": "UnrealScript",
        "url": "https://en.wikipedia.org/wiki/Unreal_Engine",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p>The <b>Unreal Engine</b> is a game engine developed by Epic Games, first showcased in the 1998 first-person shooter game <i>Unreal</i>. Although initially developed for first-person shooters, it has been successfully used in a variety of other genres, including platformers, fighting games, MMORPGs, and other RPGs. Written in C++, the Unreal Engine features a high degree of portability, supporting a wide range of platforms.\n</p><p>The latest release is Unreal Engine 4, which launched in 2014 under a subscription model. Since 2015, it can be downloaded for free, with its source code available on GitHub. Epic allows for its use in commercial products based on a royalty model, typically asking developers for 5% of revenues from sales, though with the success of <i>Fortnite</i>, which has become a testbed for Unreal Engine for Epic, Epic waives this fee for developers that publish their games through the Epic Games Store. On May 13th, 2020, Epic announced that their portion of royalties for games developed in Unreal Engine are waived until developers have earned their first <span>US$1 million</span> in revenue, retroactively applying to January 1st, 2020. Epic has announced Unreal Engine 5 to be released by late-2021.\n</p>\n\n\n",
        "infobox": {
            "name": "Unreal Engine",
            "logo": "UE Logo Black Centered.svg",
            "logo size": "100px",
            "screenshot": "Unreal Engine 4 screenshot.png",
            "caption": "Screenshot of Unreal Engine 4.20",
            "author": "Tim Sweeney (game developer)|Tim Sweeney",
            "developer": "Epic Games",
            "programming language": "C++",
            "license": "Source-available commercial software with Royalty payment|royalty model for commercial use",
            "alexa": "Alexa|up|3,178|As of|2020|06|10|df|=|US|inline|=|y As of|2020|06|10|df|=|US",
            "website": "http://www.unrealengine.com|unrealengine.com",
            "games list": "List of Unreal Engine games"
        }
    },
    {
        "id": 644,
        "name": "VHDL",
        "url": "https://en.wikipedia.org/wiki/VHDL",
        "summary": "<p><b>VHDL</b> (<b>VHSIC-HDL</b>, <b>Very High Speed Integrated Circuit Hardware Description Language</b>) is a hardware description language used in electronic design automation to describe digital and mixed-signal systems such as field-programmable gate arrays and integrated circuits. VHDL can also be used as a general-purpose parallel programming language. </p>",
        "infobox": {
            "name": "VHDL",
            "paradigm": [
                "Concurrent computing|concurrent",
                "Reactive programming|reactive",
                "Dataflow programming|dataflow"
            ],
            "year": "1980s",
            "latest_release_version": "IEEE 1076-2019",
            "latest_release_date": "start date and age|df|=|yes|2019|12|23",
            "typing": "Strongly typed programming language|strong",
            "dialects": "VHDL-AMS",
            "influenced_by": [
                "Ada (programming language)|Ada",
                "Pascal (programming language)|Pascal"
            ],
            "File extensions": ".vhd",
            "website": "[http://www.eda-twiki.org/cgi-bin/view.cgi/P1076/WebHome IEEE VASG]",
            "wikibooks": "Programmable Logic/VHDL"
        }
    },
    {
        "id": 645,
        "name": "VSXu",
        "url": "https://en.wikipedia.org/wiki/VSXu",
        "summary": "<p><i><b>VSXu</b></i> (<i><b>VSX Ultra</b></i>) is an OpenGL-based, music visualizer and modular programming environment which creates 3D effects in real-time. <i>VSXu Player</i> is available for Windows through Steam and <i>VSXu Artiste</i> is available as a download for Windows and GNU/Linux. It is developed by Vovoid Media Technologies AB. <i>VSXu</i> allows third parties to create / program visualization presets (\"visuals\" or \"states\").</p>",
        "infobox": {
            "name": "VSXu",
            "paradigm": "Visual programming language|Visual programming",
            "year": "2004",
            "designer": [
                "Robert Wenzel",
                "Jonatan Wallmander"
            ],
            "developer": "Vovoid Media Technologies AB",
            "latest_release_version": "0.8.1",
            "latest_release_date": "2020|01|01",
            "typing": "Strong typing|Strong",
            "influenced_by": [
                "Pure Data",
                "OpenGL",
                "C++"
            ],
            "programming_language": "C++",
            "operating_system": [
                "Microsoft Windows",
                "Linux"
            ],
            "license": "Proprietary / GPL / LGPL",
            "website": "vsxu.com"
        }
    },
    {
        "id": 646,
        "name": "Vala (programming language)",
        "url": "https://en.wikipedia.org/wiki/Vala_(programming_language)",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Vala</b> is an object-oriented programming language with a self-hosting compiler that generates C code and uses the GObject system.\n</p><p>Vala is syntactically similar to C# and includes notable features such as anonymous functions, signals, properties, generics, assisted memory management, exception handling, type inference, and foreach statements. Its developers, Jürg Billeter and Raffaele Sandrini, wanted to bring these features to the plain C runtime with little overhead and no special runtime support by targeting the GObject object system. Rather than compiling directly to machine code or assembly language, it compiles to a lower-level intermediate language. It source-to-source compiles to C, which is then compiled with a C compiler for a given platform, such as GCC.</p><p>For memory management, the GObject system provides reference counting. In C, a programmer must manually manage adding and removing references, but in Vala, managing such reference counts is automated if a programmer uses the language's built-in reference types rather than plain pointers.\n</p><p>Using functionality from native code libraries requires writing vapi files, defining the library interfacing. Writing these interface definitions is well-documented for C libraries, especially when based on GObject. However, C++ libraries are not supported. Vapi files are provided for a large portion of the GNOME platform, including GTK.\n</p><p>Vala was conceived by Jürg Billeter and was implemented by him and Raffaele Sandrini, finishing a self-hosting compiler in May 2006.</p>",
        "infobox": {
            "name": "Vala",
            "logo": "File:Vala Logo.svg",
            "paradigm": [
                "Programming paradigm|Multi-paradigm: imperative programming|imperative",
                "structured programming|structured",
                "object-oriented programming|object-oriented"
            ],
            "developer": [
                "Jürg Billeter",
                "Raffaele Sandrini"
            ],
            "latest release version": "0.48.6",
            "latest release date": "release date and age|2020|5|18",
            "typing": [
                "static typing|static",
                "Strong and weak typing|strong"
            ],
            "influenced by": [
                "C (programming language)|C",
                "C++",
                "C Sharp (programming language)|C#",
                "D (programming language)|D",
                "Java (programming language)|Java",
                "Boo (programming language)|Boo"
            ],
            "operating system": [
                "Cross-platform all supported by GLib",
                "but distributed as source code only."
            ],
            "license": "GNU Lesser General Public License|LGPLv2.1+",
            "website": "https://wiki.gnome.org/Projects/Vala",
            "year": "df|=|yes|2006",
            "file ext": [
                ".vala",
                ".vapi"
            ]
        }
    },
    {
        "id": 647,
        "name": "Verilog",
        "url": "https://en.wikipedia.org/wiki/Verilog",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p><b>Verilog</b>, standardized as <b>IEEE 1364</b>, is a hardware description language (HDL) used to model electronic systems. It is most commonly used in the design and verification of digital circuits at the register-transfer level of abstraction. It is also used in the verification of analog circuits and mixed-signal circuits, as well as in the design of genetic circuits. In 2009, the Verilog standard (IEEE 1364-2005) was merged into the SystemVerilog standard, creating IEEE Standard 1800-2009. Since then, Verilog is officially part of the SystemVerilog language. The current version is IEEE standard 1800-2017.</p>",
        "infobox": {
            "name": "Verilog",
            "file ext": [
                ".v",
                "header file|.vh"
            ],
            "paradigm": "structured programming|Structured",
            "released": "1984",
            "discontinued": "Merged into SystemVerilog",
            "latest release version": "IEEE 1364-2005",
            "latest release date": "start date and age|df|=|yes|2005|11|9",
            "typing": [
                "Type system|Static",
                "Weak typing|weak"
            ],
            "dialects": "Verilog-AMS",
            "influenced by": [
                "C (programming language)|C",
                "Fortran"
            ],
            "influenced": "SystemVerilog",
            "wikibooks": "Programmable Logic/Verilog"
        }
    },
    {
        "id": 648,
        "name": "Vim (text editor)",
        "url": "https://en.wikipedia.org/wiki/Vim_(text_editor)",
        "summary": "<p><b>Vim</b> (<span></span>; a contraction of <b>Vi IMproved</b>) is a clone, with additions, of Bill Joy's vi text editor program for Unix. Vim's author, Bram Moolenaar, based it on the source code for a port of the Stevie editor to the Amiga and released a version to the public in 1991. Vim is designed for use both from a command-line interface and as a standalone application in a graphical user interface. Vim is free and open-source software and is released under a license that includes some charityware clauses, encouraging users who enjoy the software to consider donating to children in Uganda. The license is compatible with the GNU General Public License through a special clause allowing distribution of modified copies \"under the GNU GPL version 2 or any later version\".</p><p>Since its release for the Amiga, cross-platform development has made it available on many other systems. In 2006, it was voted the most popular editor amongst <i>Linux Journal</i> readers; in 2015 the Stack Overflow developer survey found it to be the third most popular text editor, and the fifth most popular development environment in 2019.</p> \n\n",
        "infobox": {
            "name": "Vim",
            "logo": "Vimlogo.svg",
            "screenshot": "Vim-(logiciel)-console.png",
            "caption": "Vim running in a terminal emulator",
            "author": "Bram Moolenaar",
            "released": "1991|11|02",
            "programming language": [
                "C (programming language)|C",
                "#Vim script|Vim script"
            ],
            "operating system": [
                "Unix",
                "Linux",
                "Windows NT",
                "MS-DOS",
                "macOS",
                "iOS",
                "Android (operating system)|Android",
                "AmigaOS",
                "MorphOS"
            ],
            "genre": "Text editor",
            "license": [
                "free software license|Free software ([https://vimhelp.org/uganda.txt.html#license Vim License])",
                "charityware"
            ],
            "website": "official url"
        }
    },
    {
        "id": 649,
        "name": "Visual DataFlex",
        "url": "https://en.wikipedia.org/wiki/DataFlex",
        "summary": "<p><b>DataFlex</b> is an object-oriented high-level programming language and a fourth generation visual tool 4GL for developing Windows, web and mobile software applications on one framework-based platform. It was introduced and developed by <i>Data Access Corporation</i> beginning in 1982. </p>",
        "infobox": {
            "screenshot": "DF Logo Compact RGB.png",
            "developer": "Data Access Worldwide",
            "latest release version": "19.1.",
            "latest release date": "2019|04|10",
            "operating system": "Microsoft Windows",
            "genre": [
                "Object-oriented programming|Object-oriented",
                "Integrated development environment",
                "programming language",
                "application framework",
                "Structured programming|structured",
                "Imperative programming|imperative"
            ],
            "license": "Commercial software|Commercial proprietary software",
            "website": "www.DataAccess.com/DataFlex"
        }
    },
    {
        "id": 650,
        "name": "Visual DialogScript",
        "url": "https://en.wikipedia.org/wiki/Visual_DialogScript",
        "summary": "<p><b>Visual DialogScript</b> (VDS) is an interpreted programming language for Microsoft Windows. It can be used to create small, fast programs. VDS has a large number of dialog and graphical elements available to create professional looking programs. VDS programs have access to the Windows API; therefore, it is possible to write applications that can perform the same advanced tasks as other programming languages such as Visual Basic, C++, or Delphi. </p>",
        "infobox": "N/A"
    },
    {
        "id": 651,
        "name": "Visual FoxPro",
        "url": "https://en.wikipedia.org/wiki/Visual_FoxPro",
        "summary": "<p><b>Visual FoxPro</b> is a discontinued Microsoft data-centric procedural programming language that subsequently became object-oriented. </p><p>It was derived from FoxPro (originally known as FoxBASE) which was developed by Fox Software beginning in 1984. Fox Technologies merged with Microsoft in 1992, after which the software acquired further features and the prefix \"Visual\". FoxPro 2.6 worked on Mac OS, DOS, Windows, and Unix.\n</p><p>Visual FoxPro 3.0, the first \"Visual\" version, reduced platform support to only Mac and Windows, and later versions 5, 6, 7, 8 and 9 were Windows-only. The current version of Visual FoxPro is COM-based and Microsoft has stated that they do not intend to create a Microsoft .NET version.\n</p><p>Version 9.0, released in December 2004 and updated in October 2007 with the SP2 patch, was the final version of the product.\n</p>",
        "infobox": {
            "screenshot": "VisualFoxProScreenshot.png",
            "caption": "Visual FoxPro v9 running on Windows XP",
            "developer": "Microsoft",
            "discontinued": "yes",
            "latest release version": "v9.0 SP2",
            "latest release date": "2007|10|16",
            "operating system": [
                "Windows 2000",
                "Windows XP",
                "and Windows Server 2003"
            ],
            "platform": "IA-32",
            "language": [
                "'''IDE:''' English",
                "German",
                "Spanish<br />'''Runtime:''' Above plus French",
                "Chinese",
                "Russian",
                "Czech",
                "Korean"
            ],
            "status": "Discontinued",
            "genre": [
                "Integrated development environment",
                "programming language"
            ],
            "license": "Commercial software|Commercial proprietary software",
            "website": "msdn.microsoft.com/vfoxpro"
        }
    },
    {
        "id": 652,
        "name": "Visual J++",
        "url": "https://en.wikipedia.org/wiki/Visual_J%2B%2B",
        "summary": "<p><b>Visual J++</b> <i>(pronounced \"Jay Plus Plus\")</i> is Microsoft's discontinued implementation of Java. Syntax, keywords, and grammatical conventions were the same as Java's. It was introduced in 1996 and discontinued in January 2004, replacing it to a certain extent with J# and C#. </p>",
        "infobox": "N/A"
    },
    {
        "id": 653,
        "name": "Visual Objects",
        "url": "https://en.wikipedia.org/wiki/Visual_Objects",
        "summary": "<p><b>Visual Objects</b> is an object-oriented computer programming language that is used to create computer programs that operate primarily under Windows. Although it can be used as a general-purpose programming tool, it is almost exclusively used to create database programs. </p><p>The original Visual Objects project (code-named <b>Aspen</b>) was started as part of Nantucket's attempts to bring the Clipper language to Windows, and move from the procedural to the object-oriented style. It also converted Clipper from a p-code system to being a true native compiler and introduced more elements of the C language (such as typed variables), while including Windows extensions (such as COM, ODBC, and later ADO). With its symbol datatype, it offers the ability to form name-based linkages, which may be used to connect menu events to object methods or form direct linkages between server columns and controls.\n</p><p>The Windows version was finally brought to market by Computer Associates.  Unfortunately it was released before it was market-ready and in almost head-to-head competition with the first release of Borland's Delphi product. The language is still in use however the last release by GrafX Software was in 2012 of version 2.8 sp4 (version number 2838). GrafX announced that after this no new versions would be released. The next incarnation of the Visual Objects language is Vulcan.NET, written by GrafX from scratch to be both Visual Objects compatible and be a true CLS compliant .NET language, taking full advantage of the .NET framework.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 654,
        "name": "Visual Prolog",
        "url": "https://en.wikipedia.org/wiki/Visual_Prolog",
        "summary": "<p><b>Visual Prolog</b>, formerly known as <b>PDC Prolog</b> and <b>Turbo Prolog</b>, is a strongly typed object-oriented extension of Prolog.  As Turbo Prolog, it was marketed by Borland but it is now developed and marketed by the Danish firm Prolog Development Center (PDC) that originally developed it. Visual Prolog can build Microsoft Windows GUI-applications, console applications, DLLs (dynamic link libraries), and CGI-programs. It can also link to COM components and to databases by means of ODBC. </p><p>Logic languages are traditionally interpreted, but Visual Prolog is compiled. This provides the important improvement of converting traditional Prolog-typical run-time errors to compiler warnings, which ensures a better robustness of the finished applications.\n</p><p>The core of Visual Prolog are Horn clauses, algebraic datatypes, pattern matching and controlled non-determinism like in traditional Prolog, but unlike traditional Prolog, Visual Prolog has always been strongly and statically typed.\n</p>",
        "infobox": {
            "name": "Visual Prolog",
            "screenshot": "Visual Prolog IDE Screenshot.png",
            "caption": "IDE Screenshot",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: Logic programming|logical",
                "functional programming|functional",
                "object-oriented programming|object-oriented",
                "imperative programming|imperative"
            ],
            "developer": "PDC A/S",
            "latest release version": "9 build 905",
            "latest release date": "2020|05|14",
            "typing": [
                "static typing|static",
                "strong typing|strong",
                "type inference|inferred"
            ],
            "operating system": "Microsoft Windows",
            "license": "Proprietary",
            "website": "//www.visual-prolog.com"
        }
    },
    {
        "id": 655,
        "name": "WATFIV (programming language)",
        "url": "https://en.wikipedia.org/wiki/WATFIV",
        "summary": "<p><b>WATFIV</b>, or <b>WAT</b>erloo <b>F</b>ORTRAN <b>IV</b>,  developed at the University of Waterloo, Canada is an implementation of the Fortran computer programming language. It is the successor of <b>WATFOR</b>. </p><p>WATFIV was used from the late 1960s into the mid-1980s. WATFIV was in turn succeeded by later versions of WATFOR.\nBecause it could complete the three usual steps (\"compile-link-go\") in just one pass, the system became popular for teaching students computer programming.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 656,
        "name": "WebAssembly",
        "url": "https://en.wikipedia.org/wiki/WebAssembly",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n\n<p><b>WebAssembly</b> (often shortened to <b>Wasm</b>) is an open standard that defines a portable binary-code format for executable programs, and a corresponding textual assembly language, as well as interfaces for facilitating interactions between such programs and their host environment. The main goal of WebAssembly is to enable high-performance applications on web pages, but the format is designed to be executed and integrated in other environments as well.</p><p>WebAssembly (i.e. WebAssembly Core Specification and WebAssembly JavaScript Interface) became World Wide Web Consortium recommendations on 5 December 2019 and, alongside HTML, CSS, and JavaScript, is the fourth language to run natively in browsers. In order to use Wasm in browsers, users may use Emscripten SDK to compile C++ (or any other LLVM-supported language such as D or Rust) source code into a binary file which runs in the same sandbox as regular JavaScript code. Emscripten provides bindings for several commonly used environment interfaces like WebGL.  There is no direct Document Object Model (DOM) access; however, it is possible to create proxy functions for this, for example through stdweb, web_sys, and js_sys when using Rust language.\n</p><p>WebAssembly is usually either ahead-of-time (AOT) or just-in-time (JIT) compiled, while there's also available \"WebAssembly Micro Runtime (WAMR), an interpreter-based WebAssembly runtime for embedded devices\".</p><p>The World Wide Web Consortium (W3C) maintains the standard with contributions from Mozilla, Microsoft, Google, Apple, Fastly, Intel, and Red Hat.</p>",
        "infobox": {
            "title": "WebAssembly",
            "logo": "WebAssembly Logo.svg",
            "paradigm": [
                "Imperative programming|Imperative",
                "Structured programming|structured",
                "Expression-oriented programming language|expression-oriented"
            ],
            "released": "df|=|yes|2017|3",
            "designer": "World Wide Web Consortium|W3C",
            "developer": "Unbulleted list|World Wide Web Consortium|W3C|Mozilla|Microsoft|Google|Apple Inc.|Apple",
            "typing": "Type system|Static",
            "influenced by": "Hlist|asm.js|Google Native Client|PNaCl",
            "license": "Apache License 2.0",
            "file extensions": "Unbulleted list|.wat|.wasm"
        }
    },
    {
        "id": 657,
        "name": "WebDNA",
        "url": "https://en.wikipedia.org/wiki/WebDNA",
        "summary": "<p><b>WebDNA</b> is a server-side scripting, interpreted language with an embedded database system, specifically designed for the World Wide Web.  Its primary use is in creating database-driven dynamic web page applications. Released in 1995, the name was registered as a trademark in 1998. WebDNA is currently maintained by WebDNA Software Corporation. </p>",
        "infobox": "N/A"
    },
    {
        "id": 658,
        "name": "Whiley (programming language)",
        "url": "https://en.wikipedia.org/wiki/Whiley_(programming_language)",
        "summary": "<p><b>Whiley</b> is an experimental programming language that combines features from the functional and imperative paradigms, and supports formal specification through function preconditions, postconditions and loop invariants. The language uses flow-sensitive typing also known as \"flow typing.\" </p><p>The Whiley project began in 2009 in response to the \"Verifying Compiler Grand Challenge\" put forward by Tony Hoare in 2003. The first public release of Whiley was in June, 2010.</p><p>Primarily developed by David Pearce, Whiley is an open source project with contributions from a small community. The system has been used for student research projects and in teaching undergraduate classes.  It was supported between 2012 and 2014 by the Royal Society of New Zealand's Marsden Fund.</p><p>The Whiley compiler generates code for the Java virtual machine and can inter-operate with Java and other JVM based languages.\n</p>",
        "infobox": {
            "name": "Whiley",
            "paradigm": [
                "Imperative programming|Imperative",
                "Functional programming language|Functional"
            ],
            "released": "June 2010",
            "designer": "David J. Pearce",
            "latest release version": "0.4.2",
            "latest release date": "2018|4|11",
            "typing": [
                "Type system|Strong",
                "safe",
                "structural",
                "flow-sensitive"
            ],
            "influenced by": [
                "Java (programming language)|Java",
                "C (programming language)|C",
                "Python (programming language)|Python",
                "Rust (programming language)|Rust"
            ],
            "license": "BSD",
            "website": "whiley.org"
        }
    },
    {
        "id": 659,
        "name": "Winbatch",
        "url": "https://en.wikipedia.org/wiki/Winbatch",
        "summary": "<p><b>Winbatch</b> is a Microsoft Windows scripting language originally developed by Wilson WindowWare and currently supported, maintained and enhanced by Island Lake Consulting LLC. Its environment includes an interpreter and a code editor along with a dialog designer and optional compiler to create self-contained executables. </p><p>Its language structure and syntax is a cross between DOS batch command, Basic, Fortran, and C.   It has been developed over the years with functions added and support for things like .Net, ActiveX controls, COM (OLE), Unicode, UAC and code signing.\n</p>",
        "infobox": {
            "name": "Winbatch",
            "developer": "Wilson WindowWare and Island Lake Consulting LLC",
            "latest_release_version": "2017B",
            "latest_release_date": "release date and age|2017|04|12",
            "operating_system": "Microsoft Windows",
            "genre": "Scripting language Automation Graphical user interface|GUI Utility software|utility",
            "license": "Proprietary software|Proprietary",
            "website": "http://www.winbatch.com"
        }
    },
    {
        "id": 660,
        "name": "Wolfram Language",
        "url": "https://en.wikipedia.org/wiki/Wolfram_Language",
        "summary": "<p>The <b>Wolfram Language</b> is a general multi-paradigm computational language developed by Wolfram Research. It emphasizes symbolic computation, functional programming, and rule-based programming and can employ arbitrary structures and data. It is the programming language of the mathematical symbolic computation program Mathematica.</p>",
        "infobox": {
            "name": "Wolfram Language",
            "logo": "Wolfram Language Logo 2016.svg",
            "paradigm": [
                "Programming paradigm#Multi-paradigm programming language|Multi-paradigm: term-rewriting",
                "Functional programming|functional",
                "Procedural programming|procedural",
                "Array programming|array"
            ],
            "year": "1988",
            "typing": [
                "dynamic typing|Dynamic",
                "strong typing|strong"
            ],
            "designer": "Stephen Wolfram",
            "developer": "Wolfram Research",
            "latest release version": "12.1",
            "latest release date": "start date and age|2020|03|18",
            "implementations": [
                "Wolfram Mathematica|Mathematica",
                "[http://www.wolfram.com/wolfram-one/ Wolfram&#124;One]",
                "[https://github.com/mathics/Mathics Mathics]",
                "[https://github.com/corywalker/expreduce Expreduce]",
                "[https://web.archive.org/web/20160119224638/http://www.cs.berkeley.edu/~fateman/lisp/mma4max/ MockMMA]"
            ],
            "genre": [
                "Computer algebra system|Computer algebra",
                "List of numerical analysis software|numerical computations",
                "information visualization",
                "List of statistical packages|statistics",
                "Graphical user interface|user interface creation"
            ],
            "influenced_by": "startflatlist *APL (programming language)|APL\n*C (programming language)|C\n*C++\n*FORTRAN\n*Lisp (programming language)|Lisp\n*Pascal (programming language)|Pascal \n*Prolog\n*Simula \n*Smalltalk *Symbolic Manipulation Program|SMP endflatlist",
            "influenced": "startflatlist *Julia (programming language)|Julia *Clojure|Clojure endflatlist",
            "operating_system": "Cross-platform",
            "license": "Proprietary license|Proprietary (available at no-cost for some platforms)",
            "website": "https://www.wolfram.com/language/",
            "file_ext": [
                ".nb",
                ".m",
                ".wl"
            ]
        }
    },
    {
        "id": 661,
        "name": "Wyvern (programming language)",
        "url": "https://en.wikipedia.org/wiki/Wyvern_(programming_language)",
        "summary": "<p><b>Wyvern</b> is a computer programming language created by Jonathan Aldrich and Alex Potanin for the development of web and mobile applications with security and assurance being number one priority. Wyvern supports object capabilities, it is structurally typed, and aims to make secure way of programming <i>easier</i> than insecure - as described in the Wyvern Manifesto. One of the early available features that make Wyvern special is a way to safely use multiple programming languages within the same program so programmers can use the language most appropriate for each function while at the same time increasing the program's security. </p><p>It is currently in a prototype stage and distributed under a GPLv2 license.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 662,
        "name": "X++",
        "url": "https://en.wikipedia.org/wiki/Microsoft_Dynamics_AX",
        "summary": "<p><b>Microsoft Dynamics AX</b> is one of Microsoft's enterprise resource planning software products. It is part of the Microsoft Dynamics family. </p>",
        "infobox": {
            "name": "Microsoft Dynamics AX",
            "developer": "Microsoft",
            "latest release version": "7.0.4127.16103",
            "latest release date": "release date|2016|05|27",
            "operating system": "Plainlist|\n* Windows Server 2008 SP2 and later|ref| name=\"sys-req\" |Rp|9|\n* Windows Vista SP2 and later|ref| name=\"sys-req\"|cite web|title=Microsoft Dynamics AX 2012 System Requirements|url=https://www.microsoft.com/en-us/download/details.aspx?id=11094|website=Download Center|publisher=Microsoft|date=6 June 2017|</ref>|Rp|20| Rp|9 * Windows Vista SP2 and later Rp|20",
            "platform": ".NET Framework 4.6",
            "language": [
                "Arabic",
                "Simplified Chinese",
                "Czech",
                "Danish",
                "Dutch",
                "English",
                "Estonian",
                "Finnish",
                "French",
                "German",
                "Hungarian",
                "Icelandic",
                "Italian",
                "Japanese",
                "Latvian",
                "Lithuanian",
                "Norwegian Bokmål",
                "Polish",
                "Portuguese",
                "Russian",
                "Spanish",
                "Swedish",
                "Thai",
                "Turkish"
            ],
            "genre": "Enterprise resource planning",
            "license": "Shareware",
            "website": "https://dynamics.microsoft.com/en-us/"
        }
    },
    {
        "id": 663,
        "name": "X10 (programming language)",
        "url": "https://en.wikipedia.org/wiki/X10_(programming_language)",
        "summary": "<p><b>X10</b> is a programming language being developed by IBM at the Thomas J. Watson Research Center as part of the Productive, Easy-to-use, Reliable Computing System (PERCS) project funded by DARPA's High Productivity Computing Systems (HPCS) program. Its primary authors are Saravanan Arumugam (Aswath), Kemal Ebcioğlu, Vijay Saraswat, and Vivek Sarkar.</p><p>X10 is designed specifically for parallel computing using the partitioned global address space (PGAS) model. A computation is divided among a set of <i>places</i>, each of which holds some data and hosts one or more <i>activities</i> that operate on those data.  It has a constrained type system for object-oriented programming, a form of dependent types. Other features include user-defined primitive <i>struct</i> types; globally distributed <i>arrays</i>, and structured and unstructured parallelism.</p><p>X10 uses the concept of parent and child relationships for activities to prevent the lock stalemate that can occur when two or more processes wait for each other to finish before they can complete.  An activity may spawn one or more child activities, which may themselves have children.  Children cannot wait for a parent to finish, but a parent can wait for a child using the <i>finish</i> command.</p>",
        "infobox": {
            "name": "X10",
            "paradigm": "object-oriented programming|Object-oriented",
            "year": "2004",
            "designer": [
                "Kemal Ebcioğlu",
                "Vijay Saraswat",
                "and Vivek Sarkar"
            ],
            "developer": "IBM",
            "latest release version": "[http://x10-lang.org/releases/x10-release-262.html 2.6.2]",
            "latest release date": "2019|01|08",
            "typing": [
                "type system|Static",
                "strong",
                "safe",
                "constrained"
            ],
            "influenced by": [
                "C++",
                "Java (programming language)|Java"
            ],
            "operating system": [
                "IBM AIX",
                "Linux",
                "Mac OS X",
                "Windows"
            ],
            "license": "Eclipse Public License 1.0",
            "file ext": ".x10",
            "website": "x10-lang.org"
        }
    },
    {
        "id": 664,
        "name": "XAML",
        "url": "https://en.wikipedia.org/wiki/Extensible_Application_Markup_Language",
        "summary": "<p><b>Extensible Application Markup Language</b> (<b>XAML</b> <span> <span>(<span><span><span></span>listen</span></span>)</span></span>) is a declarative XML-based language developed by Microsoft that is used for initializing structured values and objects. It is available under Microsoft's Open Specification Promise. The acronym originally stood for Extensible Avalon Markup Language, <i>Avalon</i> being the code-name for Windows Presentation Foundation (WPF).</p><p>XAML is used extensively in .NET Framework 3.0 &amp; .NET Framework 4.0 technologies, particularly Windows Presentation Foundation (WPF), Silverlight, Windows Workflow Foundation (WF), Windows Runtime XAML Framework and Windows Store apps. In WPF, XAML forms a user interface markup language to define UI elements, data binding, events, and other features. In WF, workflows can be defined using XAML. XAML can also be used in Silverlight applications, Windows 10 Mobile (previously Windows Phone) and Universal Windows Platform apps, also called Windows Store apps. </p><p>XAML elements map directly to Common Language Runtime object instances, while XAML attributes map to Common Language Runtime properties and events on those objects. XAML files can be created and edited with visual design tools like Microsoft Expression Blend, Microsoft Visual Studio, and the hostable Windows Workflow Foundation visual designer. They can also be created and edited with a standard text editor, a code editor like XAMLPad, or a graphical editor like Vector Architect.\n</p><p>Anything that is created or implemented in XAML can be expressed using a more traditional .NET language, such as C# or Visual Basic .NET. However, a key aspect of the technology is the reduced complexity needed for tools to process XAML, because it is based on XML. Consequently, a variety of products are emerging, particularly in the WPF space, which create XAML-based applications. As XAML is simply based on XML, developers and designers are able to share and edit content freely amongst themselves without requiring compilation. XAML also benefits from being a declarative definition of the UI rather than procedural code to generate it.\n</p>",
        "infobox": {
            "name": "Extensible Application Markup Language (XAML)",
            "extension": "<tt>.xaml</tt>",
            "mime": "application/xaml+xml",
            "owner": "Microsoft",
            "released": "2008|06",
            "latest release version": "v2009",
            "latest release date": "2010|04|16",
            "genre": "User interface markup language",
            "extended from": "XML"
        }
    },
    {
        "id": 665,
        "name": "XBL",
        "url": "https://en.wikipedia.org/wiki/XBL",
        "summary": "<p><b>XBL</b> (<i>XML Binding Language</i>) is an XML-based markup language for altering the behavior of XUL widgets. It has only ever been implemented in the Mozilla codebase. </p><p>Mozilla deprecated XBL in 2017 and completed the process of removing it from the Firefox web browser codebase in 2019. However, the UXP fork of the codebase intends to continue supporting XBL indefinitely.</p><p>The Shadow DOM specification acknowledges XBL as a strong influence.</p>",
        "infobox": "N/A"
    },
    {
        "id": 666,
        "name": "XBase",
        "url": "https://en.wikipedia.org/wiki/XBase",
        "summary": "<p><span></span> </p><p><b>xBase</b> is the generic term for all programming languages that derive from the original dBASE (Ashton-Tate) programming language and database formats. These are sometimes informally known as dBASE \"clones\". While there was a non-commercial predecessor to the Ashton-Tate product (Vulcan written by Wayne Ratliff), most clones are based on Ashton-Tate's 1986 dBASE III+ release — scripts written in the dBASE III+ dialect are most likely to run on all the clones.\n</p>\n\n\n",
        "infobox": "N/A"
    },
    {
        "id": 667,
        "name": "XBase++",
        "url": "https://en.wikipedia.org/wiki/XBase%2B%2B",
        "summary": "<p><b>Xbase++</b> is an object oriented programming language which has multiple inheritance and polymorphism. It is based on the XBase language dialect and conventions. It is 100% Clipper compatible language supporting multiple inheritance, polymorphism, object oriented programming. It supports the xBase data types, including Codeblocks. With Xbase++ it is possible to generate applications for Windows NT, 95, 98, Me, 2000, XP, VISTA and Windows 7, 8, 10.</p>",
        "infobox": "N/A"
    },
    {
        "id": 668,
        "name": "XC (programming language)",
        "url": "https://en.wikipedia.org/wiki/XC_(programming_language)",
        "summary": "<p>In computers, <b>XC</b> is a programming language for real-time embedded parallel processors, targeted at the XMOS XCore processor architecture.</p><p>XC is an imperative language, based on the features for parallelism and communication in occam, and the syntax and sequential features of C. It provides primitive features that correspond to the various architectural resources provided, namely: channel ends, locks, ports and timers. </p><p>In combination with XCore processors, XC is used to build embedded systems with levels of I/O, real-time performance and computational ability usually attributed to field-programmable gate arrays (FPGAs) or application-specific integrated circuit (ASIC) devices.\n</p>",
        "infobox": {
            "name": "XC",
            "paradigm": [
                "Concurrent programming|concurrent",
                "Parallel programming|parallel",
                "Distributed programming|distributed",
                "Multi-core processor|multi-core",
                "Real-time computing|real-time",
                "Imperative programming|imperative"
            ],
            "year": "2005",
            "latest release date": "2011",
            "typing": [
                "strong typing|strong",
                "static typing|static"
            ],
            "implementations": "xcc",
            "influenced_by": [
                "C (programming language)|C",
                "occam (programming language)|occam",
                "Communicating Sequential Processes|CSP"
            ],
            "file_ext": ".xc"
        }
    },
    {
        "id": 669,
        "name": "XCore XS1",
        "url": "https://en.wikipedia.org/wiki/XCore_Architecture",
        "summary": "<p>The <b>XCore Architecture</b> is a 32-bit RISC microprocessor architecture designed by XMOS. The architecture is designed to be used in multi-core processors for embedded systems. Each XCore executes up to eight concurrent threads, each thread having its own register set, and the architecture directly supports inter-thread and inter-core communication and various forms of thread scheduling. </p><p>Two versions of the XCore architecture exist: the XS1 architecture  and the XS2 architecture.\nProcessors with the XS1 architecture include the XCore XS1-G4 and XCore XS1-L1. Processors with the XS2 architecture include xCORE-200.\n</p><p>The architecture encodes instructions compactly, using 16 bits for frequently used instructions (with up to three operands) and 32 bits for less frequently used instructions (with up to 6 operands). Almost all instructions execute in a single cycle, and the architecture is event-driven in order to decouple the timings that a program needs to make from the execution speed of the program. A program will normally perform its computations and then wait for an event (e.g. a message, time, or external I/O event) before continuing.\n</p>",
        "infobox": {
            "name": [
                "XCore XS1",
                "XCore XS2"
            ],
            "designer": "XMOS",
            "bits": "32-bit",
            "introduced": "2007",
            "version": [
                "XS1",
                "XS2",
                "XS3"
            ],
            "design": "RISC",
            "type": "Load-store architecture|Load-store",
            "encoding": "Variable",
            "branching": "Condition register",
            "endianness": "Little",
            "gpr": "12",
            "fpr": [
                "12 (shared",
                "XS3)"
            ],
            "vpr": [
                "3 (256-bit",
                "XS3)"
            ]
        }
    },
    {
        "id": 670,
        "name": "XHarbour",
        "url": "https://en.wikipedia.org/wiki/XHarbour",
        "summary": "<p><span></span> </p>\n<p><b>xHarbour</b> is a free multi-platform extended Clipper compiler, offering multiple graphic terminals (GTs), including console drivers, GUIs, and hybrid console/GUIs. xHarbour is backward-compatible with Clipper and supports many language syntax extensions, greatly extended run-time libraries, and extensive third party support.\n</p><p>Like most dynamic languages, xHarbour is also available as a scripting language (standalone application, linkable library, MS ActiveScript engine [Windows Script Host, HTML, ASP]) utilizing an interpreter written in the xHarbour language.\n</p><p>The xHarbour Usenet newsgroup <tt>comp.lang.xharbour</tt>  is an active community for discussing xHarbour related questions.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 671,
        "name": "XL (programming language)",
        "url": "https://en.wikipedia.org/wiki/XL_(programming_language)",
        "summary": "<p><b>XL</b> (\"eXtensible Language\") is the first and so far the only computer programming language designed to support concept programming.</p><p>XL features programmer-reconfigurable syntax and semantics. Compiler <i>plug-ins</i> can be used to add new features to the language. A base set of plug-ins implements a relatively standard imperative language. Programmers can write their own plug-ins to implement application-specific notations, such as symbolic differentiation, which can then be used as readily as built-in language features. </p>",
        "infobox": {
            "name": "XL",
            "paradigm": [
                "multi-paradigm programming language|Multi-paradigm: concept programming|concept-oriented",
                "imperative programming|imperative",
                "functional programming|functional"
            ],
            "year": "2000",
            "designer": "Christophe de Dinechin",
            "developer": "Christophe de Dinechin",
            "latest release version": "0.1",
            "latest release date": "2010|2",
            "latest test date": "2010|2|27",
            "typing": "strong typing|strong",
            "influenced by": [
                "Ada (programming language)|Ada",
                "C++"
            ],
            "license": "GPLv2",
            "operating system": "Unix-like",
            "website": "http://xlr.sf.net"
        }
    },
    {
        "id": 672,
        "name": "XOD (programming language)",
        "url": "https://en.wikipedia.org/wiki/XOD_(programming_language)",
        "summary": "<p><b>XOD</b> – is an open-source visual programming language for microcontrollers started in 2016. As a supported platform XOD started with Arduino boards compatibility and Raspberry PI.</p>",
        "infobox": {
            "name": "XOD",
            "developer": "XOD",
            "released": "2016",
            "latest release version": "0.31.1",
            "latest release date": "2019-10-08",
            "genre": "Visual programming language",
            "website": "https://xod.io"
        }
    },
    {
        "id": 673,
        "name": "XOTcl",
        "url": "https://en.wikipedia.org/wiki/XOTcl",
        "summary": "<p><b>XOTcl</b> is an object-oriented extension for the Tool Command Language created by Gustaf Neumann and Uwe Zdun. It is a derivative of MIT OTcl. XOTcl is based on a dynamic object system with metaclasses which as influenced by CLOS. Class and method definitions are completely dynamic. XOTcl provides language support for design patterns via filters and decorator mixins. </p>",
        "infobox": {
            "name": "XOTcl",
            "paradigm": [
                "multi-paradigm programming language|multi-paradigm: Object-oriented programming|object-oriented",
                "functional programming|functional",
                "Imperative programming|Imperative",
                "event-driven programming"
            ],
            "year": "2000",
            "designer": "Gustaf Neumann and Uwe Zdun",
            "latest_release_version": "1.6.8",
            "latest_release_date": "start date and age|2014|04|29",
            "typing": [
                "dynamic typing",
                "everything can be treated as a string (programming)|string"
            ],
            "influenced_by": [
                "Tcl",
                "OTcl"
            ],
            "website": "[http://media.wu-wien.ac.at/ media.wu-wien.ac.at]"
        }
    },
    {
        "id": 674,
        "name": "XPL",
        "url": "https://en.wikipedia.org/wiki/XPL",
        "summary": "<p><b>XPL</b> is a programming language based on PL/I, a portable one-pass compiler written in its own language, and a parser generator tool for easily implementing similar compilers for other languages.  XPL was designed in 1967 as a way to teach compiler design principles and as starting point for students to build compilers for their own languages. </p><p>XPL was designed and implemented by William M. McKeeman , David B. Wortman ,        James J. Horning and others at Stanford University. XPL was first announced at the 1968 Fall Joint Computer Conference.  The methods and compiler are described in detail in the 1971 textbook <i>A Compiler Generator</i>.\n</p><p>They called the combined work a 'compiler generator'.  But that implies little or no language- or target-specific programming is required to build a compiler for a new language or new target.  A better label for XPL is a translator writing system.  It helps to write a compiler with less new or changed programming code.\n</p>\n\n\n",
        "infobox": "N/A"
    },
    {
        "id": 675,
        "name": "XPL0",
        "url": "https://en.wikipedia.org/wiki/XPL0",
        "summary": "<p><b>XPL0</b> is a computer programming language that is essentially a cross between Pascal and C. It was created in 1976 by Peter J. R. Boyle who wanted a high-level language for his microcomputer and wanted something more sophisticated than BASIC, which was the dominant language for personal computers at the time.\n</p><p>XPL0 is based on PL/0, an example compiler in the book <i>Algorithms + Data Structures = Programs</i> by Niklaus Wirth. The first XPL0 compiler was written in ALGOL. It generated instructions for a pseudo-machine that was implemented as an interpreter on a Digital Group computer based on the 6502 microprocessor. The compiler was converted from ALGOL to XPL0 and was then able to compile itself and run on a microcomputer.\n</p><p>XPL0 soon proved its worth in a variety of products based on the 6502. These embedded systems would otherwise have had their code written in assembly language, which is much more tedious to do.\n</p><p>Boyle used XPL0 to write a disk operating system called Apex. Beginning in 1980 this was sold, along with XPL0, as an alternative to Apple DOS for the Apple II computer, which was based on the 6502.\n</p><p>Since those early years XPL0 has migrated to other processors and many features have been added. Open source versions of the compilers for IBM-style PCs are available from the link below.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 676,
        "name": "XQuery",
        "url": "https://en.wikipedia.org/wiki/XQuery",
        "summary": "<p><b>XQuery</b> (<b>XML Query</b>) is a query and functional programming language that queries and transforms collections of structured and unstructured data, usually in the form of XML, text and with vendor-specific extensions for other data formats (JSON, binary, etc.). The language is developed by the XML Query working group of the W3C. The work is closely coordinated with the development of XSLT  by the XSL Working Group; the two groups share responsibility for XPath, which is a subset of XQuery. </p><p><b>XQuery 1.0</b> became a W3C Recommendation on January 23, 2007.</p><p><b>XQuery 3.0</b> became a W3C Recommendation on April 8, 2014.</p><p><b>XQuery 3.1</b> became a W3C Recommendation on March 21, 2017.</p>\n<blockquote class=\"templatequote\"><p>\"The mission of the XML Query project is to provide flexible query facilities to extract data from real and virtual documents on the World Wide Web, therefore finally providing the needed interaction between the Web world and the database world. Ultimately, collections of XML files will be accessed like databases.\"</p></blockquote>",
        "infobox": {
            "name": "XQuery",
            "paradigm": [
                "Declarative programming|declarative",
                "Functional programming|functional",
                "Modular programming|modular"
            ],
            "year": "2007",
            "designer": "W3C",
            "latest_release_version": "[http://www.w3.org/TR/xquery-31/ 3.1]",
            "latest_release_date": "2017|03|21",
            "typing": [
                "dynamic typing|dynamic or static",
                "strong typing|strong"
            ],
            "implementations": "[http://www.w3.org/XML/Query#implementations Many]",
            "influenced_by": [
                "XPath",
                "SQL",
                "XSLT"
            ],
            "operating_system": "Cross-platform",
            "website": "http://www.w3.org/XML/Query/",
            "file_ext": [
                ".xq",
                ".xql",
                ".xqm",
                ".xqy",
                ".xquery"
            ],
            "wikibooks": "XQuery"
        }
    },
    {
        "id": 677,
        "name": "XSB",
        "url": "https://en.wikipedia.org/wiki/XSB",
        "summary": "<p><b>XSB</b> is the name of a dialect of the Prolog programming language and its implementation developed at Stony Brook University in collaboration with the Katholieke Universiteit Leuven, the New University of Lisbon, Uppsala University and software vendor XSB, Inc. </p><p>XSB extends Prolog with tabled resolution and HiLog (a standard extension of Prolog permitting limited higher-order logic programming).\n</p><p>The open source XSB implementation includes an interface to the Java programming language.\n</p>",
        "infobox": {
            "name": "XSB",
            "file ext": ".P",
            "paradigm": "Logic Programming",
            "designer": [
                "David S. Warren",
                "Terrance Swift",
                "Kostis Sagonas"
            ],
            "developer": "XSB Research Group",
            "latest release version": "3.8",
            "latest release date": "start date and age|2017|10|29",
            "influenced by": [
                "Prolog",
                "PSB-Prolog",
                "SB-Prolog"
            ],
            "operating system": "Cross-platform",
            "website": "http://xsb.sourceforge.net/"
        }
    },
    {
        "id": 678,
        "name": "XSL Transformations",
        "url": "https://en.wikipedia.org/wiki/XSLT",
        "summary": "<p><b>XSLT</b> (<b>Extensible Stylesheet Language Transformations</b>) is a language for transforming XML documents into other XML documents, or other formats such as HTML for web pages, plain text or XSL Formatting Objects, which may subsequently be converted to other formats, such as PDF, PostScript and PNG. XSLT 1.0 is widely supported in modern web browsers.</p><p>The original document is not changed; rather, a new document is created based on the content of an existing one. Typically, input documents are XML files, but anything from which the processor can build an XQuery and XPath Data Model can be used, such as relational database tables or geographical information systems.</p><p>Although XSLT is designed as a special-purpose language for XML transformation, the language is Turing-complete, making it theoretically capable of arbitrary computations.</p>",
        "infobox": {
            "name": "XSLT",
            "paradigm": "Declarative programming|Declarative",
            "year": "1998",
            "developer": "W3C",
            "latest release version": "3.0",
            "implementations": [
                "libxslt",
                "Saxon XSLT|Saxon",
                "Xalan"
            ],
            "versions": [
                "XSLT 1.0",
                "XSLT 2.0",
                "XSLT 3.0"
            ],
            "influenced by": "DSSSL",
            "website": "[http://www.w3.org/standards/xml/transformation W3C Transformation]"
        }
    },
    {
        "id": 679,
        "name": "XSharp",
        "url": "https://en.wikipedia.org/wiki/XSharp",
        "summary": "<p><b>X#</b>, pronounced <b>X sharp</b> and often written <b>XSharp</b>, is an xBase-compatible programming language for the Microsoft .NET platform. X# has been built on top of Roslyn, the open source architecture behind the current Microsoft C# and Microsoft Visual Basic compilers. </p><p>The X# compiler is intended to support multiple dialects in the xBase programming language family. It supports Core, Visual Objects, Vulcan.NET, xBase++, Harbour, Foxpro and more. The project is intended as an opensource community effort, but is at the moment still partly closed source.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 680,
        "name": "Xojo",
        "url": "https://en.wikipedia.org/wiki/Xojo",
        "summary": "<p>The <b>Xojo</b> programming environment and programming language is developed and commercially marketed by Xojo, Inc. of Austin, Texas for software development targeting macOS, Microsoft Windows, Linux, iOS, the Web and Raspberry Pi. Xojo uses a proprietary object-oriented language.</p>",
        "infobox": {
            "name": "Xojo",
            "logo": "Xojo Company Logo.png",
            "screenshot": "Xojo Integrated Development Environment.png",
            "developer": [
                "Xojo",
                "Inc."
            ],
            "latest release version": "Xojo 2019R3.1",
            "latest release date": "2020|01|23",
            "operating system": "Plainlist|\n* Windows\n* macOS\n* Linux\n* World Wide Web|Web\n* Raspberry Pi\n|<!-- NOT iOS. It can develop for iOS but cannot run on it.-->\n|",
            "language": "English",
            "genre": "Programming language|Programming",
            "license": "Trialware",
            "website": "xojo.com"
        }
    },
    {
        "id": 681,
        "name": "Xtend",
        "url": "https://en.wikipedia.org/wiki/Xtend",
        "summary": "<p><b>Xtend</b> is a general-purpose high-level programming language for the Java Virtual Machine. Syntactically and semantically Xtend has its roots in the Java programming language but focuses on a more concise syntax and some additional functionality such as type inference, extension methods, and operator overloading. Being primarily an object-oriented language, it also integrates features known from functional programming, e.g. lambda expressions. Xtend is statically typed and uses Java's type system without modifications. It is compiled to Java code and thereby seamlessly integrates with all existing Java libraries. </p><p>The language Xtend and its IDE is developed as a project at Eclipse.org and participates in the annual Eclipse release train. The code is open source under the Eclipse Public License. Yet, the language can be compiled and run independently of the Eclipse platform.\n</p>",
        "infobox": {
            "name": "Xtend",
            "logo": "File:Xtend-logo-c.png|200px|Xtend-logo",
            "paradigm": [
                "Object-oriented programming|Object-oriented",
                "Imperative programming|imperative",
                "functional programming|functional"
            ],
            "designer": [
                "Sven Efftinge",
                "Sebastian Zarnekow"
            ],
            "developer": "[http://typefox.io/ typefox]",
            "typing": [
                "Static typing|Static",
                "strong typing|strong",
                "type inference|inferred"
            ],
            "platform": "Java Virtual Machine",
            "license": "Eclipse Public License",
            "website": "http://www.xtend-lang.org",
            "year": "2011",
            "latest_release_version": "2.19",
            "latest_release_date": "2019|09|3",
            "influenced_by": [
                "Java (programming language)|Java",
                "Scala (programming language)|Scala",
                "Groovy (programming language)|Groovy",
                "Smalltalk",
                "[http://wiki.eclipse.org/Xpand Xpand]"
            ],
            "operating_system": "Cross-platform"
        }
    },
    {
        "id": 682,
        "name": "YAML",
        "url": "https://en.wikipedia.org/wiki/YAML",
        "summary": "<p><b>YAML</b> (a recursive acronym for \"YAML Ain't Markup Language\") is a human-readable data-serialization language.  It is commonly used for configuration files and in applications where data is being stored or transmitted.  YAML targets many of the same communications applications as Extensible Markup Language (XML) but has a minimal syntax which intentionally differs from SGML. It uses both Python-style indentation to indicate nesting, and a more compact format that uses <code class=\"mw-highlight mw-highlight-lang-text\" id=\"\" style=\"\" dir=\"ltr\">[...]</code> for lists and <code class=\"mw-highlight mw-highlight-lang-text\" id=\"\" style=\"\" dir=\"ltr\">{...}</code> for maps making YAML 1.2 a superset of JSON.</p><p>Custom data types are allowed, but YAML natively encodes scalars (such as strings, integers, and floats), lists, and associative arrays (also known as maps, dictionaries or hashes). These data types are based on the Perl programming language, though all commonly used high-level programming languages share very similar concepts. The colon-centered syntax, used for expressing key-value pairs, is inspired by electronic mail headers as defined in RFC 0822, and the document separator <code class=\"mw-highlight mw-highlight-lang-text\" id=\"\" style=\"\" dir=\"ltr\">---</code> is borrowed from MIME (RFC 2046).  Escape sequences are reused from C, and whitespace wrapping for multi-line strings is inspired by HTML.  Lists and hashes can contain nested lists and hashes, forming a tree structure; arbitrary graphs can be represented using YAML aliases (similar to XML in SOAP). YAML is intended to be read and written in streams, a feature inspired by SAX.</p><p>Support for reading and writing YAML is available for many programming languages. Some source-code editors such as Emacs and various integrated development environments have features that make editing YAML easier, such as folding up nested structures or automatically highlighting syntax errors. </p><p>The official recommended filename extension for YAML files has been <code class=\"mw-highlight mw-highlight-lang-text\" id=\"\" style=\"\" dir=\"ltr\">.yaml</code> since 2006.</p>",
        "infobox": {
            "name": "YAML",
            "_noextcode": "on",
            "extensions": [
                "code|.yaml ",
                "code|.yml"
            ],
            "_nomimecode": "on",
            "mime": "''Not registered''",
            "released": "start date and age|2001|05|11",
            "latest_release_version": "1.2 (Third Edition)",
            "latest_release_date": "start date and age|2009|10|01",
            "genre": "Data interchange",
            "free": "Yes",
            "url": "https://yaml.org"
        }
    },
    {
        "id": 683,
        "name": "YQL (programming language)",
        "url": "https://en.wikipedia.org/wiki/Yahoo!_Query_Language",
        "summary": "<p><b>Yahoo! Query Language</b> (<b>YQL</b>) is an SQL-like query language created by Yahoo! as part of their Developer Network. YQL is designed to retrieve and manipulate data from APIs through a single Web interface, thus allowing mashups that enable developers to create their own applications.</p><p>Initially launched in October 2008 with access to Yahoo APIs, February 2009 saw the addition of open data tables from third parties such as Google Reader, the <i>Guardian</i>, and <i>The New York Times</i>. Some of these APIs still require an API key to access them. On April 29 of 2009, Yahoo introduced the capability to execute the tables of data built through YQL using JavaScript run on the company's servers for free.. On January 3, 2019 Yahoo retired the YQL API service. </p>",
        "infobox": "N/A"
    },
    {
        "id": 684,
        "name": "YUI Library",
        "url": "https://en.wikipedia.org/wiki/YUI_Library",
        "summary": "<p><b>The Yahoo! User Interface Library</b> (<b>YUI</b>) is a discontinued open-source JavaScript library for building richly interactive web applications using techniques such as Ajax, DHTML, and DOM scripting. YUI includes several core CSS resources. It is available under a BSD License. Development on YUI began in 2005 and Yahoo! properties such as My Yahoo! and the Yahoo! front page began using YUI in the summer of that year. YUI was released for public use in February 2006. It was actively developed by a core team of Yahoo! engineers.\n</p><p>In September 2009, Yahoo! released YUI 3, a new version of YUI rebuilt from the ground up to modernize the library and incorporate lessons learned from YUI 2. Among the enhancements are a CSS selector driven engine, like jQuery, for retrieving DOM elements, a greater emphasis on granularity of modules, a smaller seed file that loads other modules when necessary, and a variety of syntactic changes intended to make writing code faster and easier.</p><p>The YUI Library project at Yahoo! was founded by Thomas Sha and sponsored internally by Yahoo! co-founder Jerry Yang; its principal architects have been Sha, Adam Moore, and Matt Sweeney. The library's developers maintain the YUIBlog; the YUI community discusses the library and implementations in its community forum.\n</p><p>On August 29, 2014, it was announced that active development of YUI by Yahoo! would end, citing the evolution of the JavaScript standards, steadily decreasing interest in large JavaScript libraries by developers, and the proliferation of server-side solutions. Future development will be limited to maintenance releases addressing issues which are \"absolutely critical to Yahoo properties.\"</p>",
        "infobox": {
            "name": "Yahoo! User Interface Library",
            "logo": "Yuilib.jpg",
            "developer": "Yahoo!",
            "released": "release date and age|2006|02|13",
            "latest release version": "3.18.1",
            "latest release date": "release date and age|2014|10|22",
            "operating system": "Cross-platform (JavaScript)",
            "programming language": "JavaScript",
            "genre": "JavaScript library",
            "license": "BSD License",
            "website": "http://yuilibrary.com/",
            "discontinued": "yes"
        }
    },
    {
        "id": 685,
        "name": "Yoix",
        "url": "https://en.wikipedia.org/wiki/Yoix",
        "summary": "<p>In computer programming, <b>Yoix</b> is a high-level, general-purpose, interpreted, dynamic programming language. The Yoix interpreter is implemented using standard Java technology without any add-on packages and requires only a Sun-compliant JVM to operate. Initially developed by AT&amp;T Labs researchers for internal use, it has been available as free and open source software since late 2000. </p>",
        "infobox": {
            "name": "Yoix",
            "logo": "Yoixlogo.png",
            "paradigm": [
                "Multi-paradigm",
                "Object-oriented programming|Object-based",
                "procedural programming|procedural"
            ],
            "year": "2000",
            "designer": "Rich Drechsler and John Mocenigo",
            "latest_release_version": "2.3.1",
            "latest_release_date": "2011|11|25",
            "typing": [
                "Dynamic",
                "Weak"
            ],
            "influenced_by": [
                "C (programming language)|C",
                "Java (programming language)|Java",
                "PostScript"
            ],
            "operating_system": "Cross-platform",
            "license": "Common Public License|Open Source Initiative Common Public License",
            "website": "https://github.com/att/yoix"
        }
    },
    {
        "id": 686,
        "name": "Yorick (programming language)",
        "url": "https://en.wikipedia.org/wiki/Yorick_(programming_language)",
        "summary": "<p><b>Yorick</b> is an interpreted programming language designed for numerics, graph plotting, and steering large scientific simulation codes. It is quite fast due to array syntax, and extensible via C or Fortran routines. It was created in 1996 by David H. Munro of Lawrence Livermore National Laboratory. </p>",
        "infobox": {
            "name": "Yorick",
            "file_ext": ".i",
            "year": "1996",
            "designer": "David H. Munro",
            "latest_release_version": "2.2.04",
            "latest_release_date": "2015|05",
            "operating_system": [
                "Unix-like systems including macOS",
                "Microsoft Windows"
            ],
            "license": "BSD licenses|BSD",
            "website": "yorick.github.com"
        }
    },
    {
        "id": 687,
        "name": "Z++",
        "url": "https://en.wikipedia.org/wiki/Z%2B%2B",
        "summary": "<p><b>Z++</b> (pronounced <i>zed plus plus</i>) is an object-oriented extension to the Z specification language. </p><p>Z++ allows for the definition of classes, and the relation of classes through inheritance, association, or aggregation. The primary construct of Z++ is a class.  A Z++ class consists of a number of clauses which are optional.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 688,
        "name": "ZOPL",
        "url": "https://en.wikipedia.org/wiki/ZOPL",
        "summary": "<p><b>ZOPL</b> is a programming language created by Geac Computer Corporation in the early 1970s for use on their mainframe computer systems used in libraries and banking institutions.  It had similarities to C and Pascal. </p><p>ZOPL stood for \"Version Z, Our Programming Language\".\nZOPL is still in use at CGI Group (formerly known as RealTime Datapro), who ported it to VAX/VMS and Unix in the 1980s, and to Windows in 1998.  by 2010 it had been ported to run on Windows XP/2000/2003 and Red Hat Linux.  The RTM (formerly ZUG) language compiler and runtime framework are written in ZOPL.\n</p><p>Outside of CGI, ZOPL has not been in general use since the late 1980s, although there is still one known working system where it is found embedded in programs written in the KARL programming language.  \n</p>",
        "infobox": "N/A"
    },
    {
        "id": 689,
        "name": "ZPL (programming language)",
        "url": "https://en.wikipedia.org/wiki/ZPL_(programming_language)",
        "summary": "<p><b>ZPL</b> (short for <i>Z-level Programming Language</i>) is an array programming language designed to replace C and C++ programming languages in engineering and scientific applications. Because its design goal was to obtain cross-platform high performance, ZPL programs run fast on both sequential and parallel computers. Highly-parallel ZPL programs are simple and easy to write because it exclusively uses implicit parallelism. </p><p>Originally called <b>Orca C</b>, ZPL was designed and implemented during 1993–1995 by the Orca Project of the Computer Science and Engineering Department at the University of Washington.\n</p>",
        "infobox": {
            "name": "ZPL",
            "paradigm": "Array programming|Array",
            "released": "1993",
            "developer": "Chamberlain ''et al.'' at University of Washington",
            "influenced by": "C (programming language)|C",
            "influenced": "Chapel (programming language)|Chapel",
            "website": "[https://web.archive.org/web/20060211013421/http://www.cs.washington.edu/research/zpl/home/ www.cs.washington.edu]"
        }
    },
    {
        "id": 690,
        "name": "Z notation",
        "url": "https://en.wikipedia.org/wiki/Z_notation",
        "summary": "<p>The <b>Z notation</b> <span></span> is a formal specification language used for describing and modelling computing systems. It is targeted at the clear specification of computer programs and computer-based systems in general. </p>\n\n\n",
        "infobox": "N/A"
    },
    {
        "id": 691,
        "name": "Z shell",
        "url": "https://en.wikipedia.org/wiki/Z_shell",
        "summary": "<p>The <b>Z shell</b> (<b>Zsh</b>) is a Unix shell that can be used as an interactive login shell and as a command interpreter for shell scripting. Zsh is an extended Bourne shell with many improvements, including some features of Bash, ksh, and tcsh. </p>\n\n\n",
        "infobox": {
            "name": "Z shell",
            "screenshot": "Zsh 5.7.1 screenshot.png",
            "screenshot size": "300px",
            "caption": "Screenshot of a Zsh session",
            "author": "Paul Falstad",
            "developer": [
                "Peter Stephenson",
                "et al."
            ],
            "released": "1990",
            "latest release version": "[https://sourceforge.net/projects/zsh/files/zsh/5.8/ 5.8]",
            "latest release date": "2020|02|15",
            "programming language": "C (programming language)|C",
            "operating system": "Cross-platform",
            "genre": "Unix shell",
            "license": "MIT License|MIT-like",
            "website": "https://www.zsh.org/"
        }
    },
    {
        "id": 692,
        "name": "Zebra (programming language)",
        "url": "https://en.wikipedia.org/wiki/Zebra_Programming_Language",
        "summary": "<p><b>Zebra Programming Language</b> (<b>ZPL</b>) is a page description language from Zebra Technologies, used primarily for labeling applications. The original language was superseded by <b>ZPL II</b>, but it is not fully compatible with the older version. Meanwhile, ZPL II is emulated by many label printers of various producers.</p><p>Later, the <b>Zebra BASIC Interpreter</b> (<b>ZBI</b>) was integrated into printer software, which is seen as an advancement to ZPL II by the producer and is ANSI BASIC oriented. Primarily, it is intended to avoid a refactoring of code when changing the printer, if the old printer software was written by a label printer of a competitor.  A possible use of ZBI could be for when the Zebra printer receives a foreign label format, which it would then convert to ZPL II on the fly so it can be printed.</p>",
        "infobox": {
            "title": "Zebra Programming Language",
            "logo": "Zebra Programming Language.png",
            "logo caption": "Zebra logo",
            "operating system": "independent",
            "influenced by": "ANSI BASIC",
            "developer": "Zebra Technologies"
        }
    },
    {
        "id": 693,
        "name": "Zeno (programming language)",
        "url": "https://en.wikipedia.org/wiki/Zeno_(programming_language)",
        "summary": "<p><b>Zeno</b> (after pre-Socratic Greek philosopher Zeno of Elea) is an imperative procedural programming language designed to be easy to learn and user friendly. Zeno is generic in the sense that it contains most of the essential elements used in other languages to develop real applications. </p><p>The Zeno Interpreter was designed for use in Windows 95 and later Microsoft operating systems. The interpreter comes with built-in debugging tools, a source code text editor, and an on-line language reference. \n</p><p>Zeno was created by Stephen R. Schmitt and is maintained by Abecedarical Systems.\n</p>",
        "infobox": "N/A"
    },
    {
        "id": 694,
        "name": "ZetaLisp",
        "url": "https://en.wikipedia.org/wiki/Lisp_Machine_Lisp",
        "summary": "<p class=\"mw-empty-elt\"> </p>\n<p><b>Lisp Machine Lisp</b> is a programming language, a dialect of the language Lisp. A direct descendant of Maclisp, it was initially developed in the mid to late 1970s as the system programming language for the Massachusetts Institute of Technology (MIT) Lisp machines. Lisp Machine Lisp was also the Lisp dialect with the most influence on the design of Common Lisp.\n</p><p>Lisp Machine Lisp branched into three dialects. Symbolics named their variant ZetaLisp. Lisp Machines, Inc. and later Texas Instruments (with the TI Explorer) would share a common code base, but their dialect of Lisp Machine Lisp would differ from the version maintained at the MIT AI Lab by Richard Stallman and others.\n</p><p><br></p>",
        "infobox": {
            "name": "Lisp Machine Lisp",
            "family": "Lisp (programming language)|Lisp",
            "designers": "David A. Moon,<br />Richard Stallman,<br />Daniel Weinreb",
            "developers": "Massachusetts Institute of Technology|MIT,<br />Symbolics,<br />Lisp Machines,<br />Texas Instruments",
            "released": "1976",
            "latest release date": "1995",
            "discontinued": "Yes",
            "platform": "Lisp machines",
            "operating system": [
                "Genera (operating system)|Genera",
                "others"
            ],
            "file ext": [
                "Mono|.lisp ",
                "Mono|.qfasl"
            ],
            "dialects": [
                "Lisp Machine Lisp",
                "ZetaLisp"
            ],
            "influenced by": [
                "Lisp (programming language)|Lisp",
                "Maclisp",
                "Interlisp"
            ],
            "influenced": "Common Lisp"
        }
    }
]